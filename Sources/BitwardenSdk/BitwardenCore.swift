// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(BitwardenCoreFFI)
import BitwardenCoreFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_bitwarden_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_bitwarden_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

fileprivate struct FfiConverterTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Date {
        let seconds: Int64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        if seconds >= 0 {
            let delta = Double(seconds) + (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        } else {
            let delta = Double(seconds) - (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        }
    }

    public static func write(_ value: Date, into buf: inout [UInt8]) {
        var delta = value.timeIntervalSince1970
        var sign: Int64 = 1
        if delta < 0 {
            // The nanoseconds portion of the epoch offset must always be
            // positive, to simplify the calculation we will use the absolute
            // value of the offset.
            sign = -1
            delta = -delta
        }
        if delta.rounded(.down) > Double(Int64.max) {
            fatalError("Timestamp overflow, exceeds max bounds supported by Uniffi")
        }
        let seconds = Int64(delta)
        let nanoseconds = UInt32((delta - Double(seconds)) * 1.0e9)
        writeInt(&buf, sign * seconds)
        writeInt(&buf, nanoseconds)
    }
}


public struct Attachment {
    public let id: String?
    public let url: String?
    public let size: String?
    /**
     * Readable size, ex: "4.2 KB" or "1.43 GB"
     */
    public let sizeName: String?
    public let fileName: EncString?
    public let key: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: String?, 
        url: String?, 
        size: String?, 
        /**
         * Readable size, ex: "4.2 KB" or "1.43 GB"
         */
        sizeName: String?, 
        fileName: EncString?, 
        key: EncString?) {
        self.id = id
        self.url = url
        self.size = size
        self.sizeName = sizeName
        self.fileName = fileName
        self.key = key
    }
}


extension Attachment: Equatable, Hashable {
    public static func ==(lhs: Attachment, rhs: Attachment) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.sizeName != rhs.sizeName {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(url)
        hasher.combine(size)
        hasher.combine(sizeName)
        hasher.combine(fileName)
        hasher.combine(key)
    }
}


public struct FfiConverterTypeAttachment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Attachment {
        return
            try Attachment(
                id: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                size: FfiConverterOptionString.read(from: &buf), 
                sizeName: FfiConverterOptionString.read(from: &buf), 
                fileName: FfiConverterOptionTypeEncString.read(from: &buf), 
                key: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: Attachment, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.size, into: &buf)
        FfiConverterOptionString.write(value.sizeName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.fileName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.key, into: &buf)
    }
}


public func FfiConverterTypeAttachment_lift(_ buf: RustBuffer) throws -> Attachment {
    return try FfiConverterTypeAttachment.lift(buf)
}

public func FfiConverterTypeAttachment_lower(_ value: Attachment) -> RustBuffer {
    return FfiConverterTypeAttachment.lower(value)
}


public struct AttachmentEncryptResult {
    public let attachment: Attachment
    public let contents: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        attachment: Attachment, 
        contents: Data) {
        self.attachment = attachment
        self.contents = contents
    }
}


extension AttachmentEncryptResult: Equatable, Hashable {
    public static func ==(lhs: AttachmentEncryptResult, rhs: AttachmentEncryptResult) -> Bool {
        if lhs.attachment != rhs.attachment {
            return false
        }
        if lhs.contents != rhs.contents {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attachment)
        hasher.combine(contents)
    }
}


public struct FfiConverterTypeAttachmentEncryptResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentEncryptResult {
        return
            try AttachmentEncryptResult(
                attachment: FfiConverterTypeAttachment.read(from: &buf), 
                contents: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: AttachmentEncryptResult, into buf: inout [UInt8]) {
        FfiConverterTypeAttachment.write(value.attachment, into: &buf)
        FfiConverterData.write(value.contents, into: &buf)
    }
}


public func FfiConverterTypeAttachmentEncryptResult_lift(_ buf: RustBuffer) throws -> AttachmentEncryptResult {
    return try FfiConverterTypeAttachmentEncryptResult.lift(buf)
}

public func FfiConverterTypeAttachmentEncryptResult_lower(_ value: AttachmentEncryptResult) -> RustBuffer {
    return FfiConverterTypeAttachmentEncryptResult.lower(value)
}


public struct AttachmentView {
    public let id: String?
    public let url: String?
    public let size: String?
    public let sizeName: String?
    public let fileName: String?
    public let key: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: String?, 
        url: String?, 
        size: String?, 
        sizeName: String?, 
        fileName: String?, 
        key: EncString?) {
        self.id = id
        self.url = url
        self.size = size
        self.sizeName = sizeName
        self.fileName = fileName
        self.key = key
    }
}


extension AttachmentView: Equatable, Hashable {
    public static func ==(lhs: AttachmentView, rhs: AttachmentView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.sizeName != rhs.sizeName {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(url)
        hasher.combine(size)
        hasher.combine(sizeName)
        hasher.combine(fileName)
        hasher.combine(key)
    }
}


public struct FfiConverterTypeAttachmentView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentView {
        return
            try AttachmentView(
                id: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                size: FfiConverterOptionString.read(from: &buf), 
                sizeName: FfiConverterOptionString.read(from: &buf), 
                fileName: FfiConverterOptionString.read(from: &buf), 
                key: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: AttachmentView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.size, into: &buf)
        FfiConverterOptionString.write(value.sizeName, into: &buf)
        FfiConverterOptionString.write(value.fileName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.key, into: &buf)
    }
}


public func FfiConverterTypeAttachmentView_lift(_ buf: RustBuffer) throws -> AttachmentView {
    return try FfiConverterTypeAttachmentView.lift(buf)
}

public func FfiConverterTypeAttachmentView_lower(_ value: AttachmentView) -> RustBuffer {
    return FfiConverterTypeAttachmentView.lower(value)
}


public struct Card {
    public let cardholderName: EncString?
    public let expMonth: EncString?
    public let expYear: EncString?
    public let code: EncString?
    public let brand: EncString?
    public let number: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        cardholderName: EncString?, 
        expMonth: EncString?, 
        expYear: EncString?, 
        code: EncString?, 
        brand: EncString?, 
        number: EncString?) {
        self.cardholderName = cardholderName
        self.expMonth = expMonth
        self.expYear = expYear
        self.code = code
        self.brand = brand
        self.number = number
    }
}


extension Card: Equatable, Hashable {
    public static func ==(lhs: Card, rhs: Card) -> Bool {
        if lhs.cardholderName != rhs.cardholderName {
            return false
        }
        if lhs.expMonth != rhs.expMonth {
            return false
        }
        if lhs.expYear != rhs.expYear {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.brand != rhs.brand {
            return false
        }
        if lhs.number != rhs.number {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cardholderName)
        hasher.combine(expMonth)
        hasher.combine(expYear)
        hasher.combine(code)
        hasher.combine(brand)
        hasher.combine(number)
    }
}


public struct FfiConverterTypeCard: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Card {
        return
            try Card(
                cardholderName: FfiConverterOptionTypeEncString.read(from: &buf), 
                expMonth: FfiConverterOptionTypeEncString.read(from: &buf), 
                expYear: FfiConverterOptionTypeEncString.read(from: &buf), 
                code: FfiConverterOptionTypeEncString.read(from: &buf), 
                brand: FfiConverterOptionTypeEncString.read(from: &buf), 
                number: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: Card, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.cardholderName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.expMonth, into: &buf)
        FfiConverterOptionTypeEncString.write(value.expYear, into: &buf)
        FfiConverterOptionTypeEncString.write(value.code, into: &buf)
        FfiConverterOptionTypeEncString.write(value.brand, into: &buf)
        FfiConverterOptionTypeEncString.write(value.number, into: &buf)
    }
}


public func FfiConverterTypeCard_lift(_ buf: RustBuffer) throws -> Card {
    return try FfiConverterTypeCard.lift(buf)
}

public func FfiConverterTypeCard_lower(_ value: Card) -> RustBuffer {
    return FfiConverterTypeCard.lower(value)
}


public struct CardView {
    public let cardholderName: String?
    public let expMonth: String?
    public let expYear: String?
    public let code: String?
    public let brand: String?
    public let number: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        cardholderName: String?, 
        expMonth: String?, 
        expYear: String?, 
        code: String?, 
        brand: String?, 
        number: String?) {
        self.cardholderName = cardholderName
        self.expMonth = expMonth
        self.expYear = expYear
        self.code = code
        self.brand = brand
        self.number = number
    }
}


extension CardView: Equatable, Hashable {
    public static func ==(lhs: CardView, rhs: CardView) -> Bool {
        if lhs.cardholderName != rhs.cardholderName {
            return false
        }
        if lhs.expMonth != rhs.expMonth {
            return false
        }
        if lhs.expYear != rhs.expYear {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.brand != rhs.brand {
            return false
        }
        if lhs.number != rhs.number {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cardholderName)
        hasher.combine(expMonth)
        hasher.combine(expYear)
        hasher.combine(code)
        hasher.combine(brand)
        hasher.combine(number)
    }
}


public struct FfiConverterTypeCardView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CardView {
        return
            try CardView(
                cardholderName: FfiConverterOptionString.read(from: &buf), 
                expMonth: FfiConverterOptionString.read(from: &buf), 
                expYear: FfiConverterOptionString.read(from: &buf), 
                code: FfiConverterOptionString.read(from: &buf), 
                brand: FfiConverterOptionString.read(from: &buf), 
                number: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: CardView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.cardholderName, into: &buf)
        FfiConverterOptionString.write(value.expMonth, into: &buf)
        FfiConverterOptionString.write(value.expYear, into: &buf)
        FfiConverterOptionString.write(value.code, into: &buf)
        FfiConverterOptionString.write(value.brand, into: &buf)
        FfiConverterOptionString.write(value.number, into: &buf)
    }
}


public func FfiConverterTypeCardView_lift(_ buf: RustBuffer) throws -> CardView {
    return try FfiConverterTypeCardView.lift(buf)
}

public func FfiConverterTypeCardView_lower(_ value: CardView) -> RustBuffer {
    return FfiConverterTypeCardView.lower(value)
}


public struct Cipher {
    public let id: Uuid?
    public let organizationId: Uuid?
    public let folderId: Uuid?
    public let collectionIds: [Uuid]
    /**
     * More recent ciphers uses individual encryption keys to encrypt the other fields of the Cipher.
     */
    public let key: EncString?
    public let name: EncString
    public let notes: EncString?
    public let type: CipherType
    public let login: Login?
    public let identity: Identity?
    public let card: Card?
    public let secureNote: SecureNote?
    public let favorite: Bool
    public let reprompt: CipherRepromptType
    public let organizationUseTotp: Bool
    public let edit: Bool
    public let viewPassword: Bool
    public let localData: LocalData?
    public let attachments: [Attachment]?
    public let fields: [Field]?
    public let passwordHistory: [PasswordHistory]?
    public let creationDate: DateTime
    public let deletedDate: DateTime?
    public let revisionDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: Uuid?, 
        organizationId: Uuid?, 
        folderId: Uuid?, 
        collectionIds: [Uuid], 
        /**
         * More recent ciphers uses individual encryption keys to encrypt the other fields of the Cipher.
         */
        key: EncString?, 
        name: EncString, 
        notes: EncString?, 
        type: CipherType, 
        login: Login?, 
        identity: Identity?, 
        card: Card?, 
        secureNote: SecureNote?, 
        favorite: Bool, 
        reprompt: CipherRepromptType, 
        organizationUseTotp: Bool, 
        edit: Bool, 
        viewPassword: Bool, 
        localData: LocalData?, 
        attachments: [Attachment]?, 
        fields: [Field]?, 
        passwordHistory: [PasswordHistory]?, 
        creationDate: DateTime, 
        deletedDate: DateTime?, 
        revisionDate: DateTime) {
        self.id = id
        self.organizationId = organizationId
        self.folderId = folderId
        self.collectionIds = collectionIds
        self.key = key
        self.name = name
        self.notes = notes
        self.type = type
        self.login = login
        self.identity = identity
        self.card = card
        self.secureNote = secureNote
        self.favorite = favorite
        self.reprompt = reprompt
        self.organizationUseTotp = organizationUseTotp
        self.edit = edit
        self.viewPassword = viewPassword
        self.localData = localData
        self.attachments = attachments
        self.fields = fields
        self.passwordHistory = passwordHistory
        self.creationDate = creationDate
        self.deletedDate = deletedDate
        self.revisionDate = revisionDate
    }
}


extension Cipher: Equatable, Hashable {
    public static func ==(lhs: Cipher, rhs: Cipher) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.organizationId != rhs.organizationId {
            return false
        }
        if lhs.folderId != rhs.folderId {
            return false
        }
        if lhs.collectionIds != rhs.collectionIds {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.notes != rhs.notes {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.login != rhs.login {
            return false
        }
        if lhs.identity != rhs.identity {
            return false
        }
        if lhs.card != rhs.card {
            return false
        }
        if lhs.secureNote != rhs.secureNote {
            return false
        }
        if lhs.favorite != rhs.favorite {
            return false
        }
        if lhs.reprompt != rhs.reprompt {
            return false
        }
        if lhs.organizationUseTotp != rhs.organizationUseTotp {
            return false
        }
        if lhs.edit != rhs.edit {
            return false
        }
        if lhs.viewPassword != rhs.viewPassword {
            return false
        }
        if lhs.localData != rhs.localData {
            return false
        }
        if lhs.attachments != rhs.attachments {
            return false
        }
        if lhs.fields != rhs.fields {
            return false
        }
        if lhs.passwordHistory != rhs.passwordHistory {
            return false
        }
        if lhs.creationDate != rhs.creationDate {
            return false
        }
        if lhs.deletedDate != rhs.deletedDate {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(organizationId)
        hasher.combine(folderId)
        hasher.combine(collectionIds)
        hasher.combine(key)
        hasher.combine(name)
        hasher.combine(notes)
        hasher.combine(type)
        hasher.combine(login)
        hasher.combine(identity)
        hasher.combine(card)
        hasher.combine(secureNote)
        hasher.combine(favorite)
        hasher.combine(reprompt)
        hasher.combine(organizationUseTotp)
        hasher.combine(edit)
        hasher.combine(viewPassword)
        hasher.combine(localData)
        hasher.combine(attachments)
        hasher.combine(fields)
        hasher.combine(passwordHistory)
        hasher.combine(creationDate)
        hasher.combine(deletedDate)
        hasher.combine(revisionDate)
    }
}


public struct FfiConverterTypeCipher: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cipher {
        return
            try Cipher(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                organizationId: FfiConverterOptionTypeUuid.read(from: &buf), 
                folderId: FfiConverterOptionTypeUuid.read(from: &buf), 
                collectionIds: FfiConverterSequenceTypeUuid.read(from: &buf), 
                key: FfiConverterOptionTypeEncString.read(from: &buf), 
                name: FfiConverterTypeEncString.read(from: &buf), 
                notes: FfiConverterOptionTypeEncString.read(from: &buf), 
                type: FfiConverterTypeCipherType.read(from: &buf), 
                login: FfiConverterOptionTypeLogin.read(from: &buf), 
                identity: FfiConverterOptionTypeIdentity.read(from: &buf), 
                card: FfiConverterOptionTypeCard.read(from: &buf), 
                secureNote: FfiConverterOptionTypeSecureNote.read(from: &buf), 
                favorite: FfiConverterBool.read(from: &buf), 
                reprompt: FfiConverterTypeCipherRepromptType.read(from: &buf), 
                organizationUseTotp: FfiConverterBool.read(from: &buf), 
                edit: FfiConverterBool.read(from: &buf), 
                viewPassword: FfiConverterBool.read(from: &buf), 
                localData: FfiConverterOptionTypeLocalData.read(from: &buf), 
                attachments: FfiConverterOptionSequenceTypeAttachment.read(from: &buf), 
                fields: FfiConverterOptionSequenceTypeField.read(from: &buf), 
                passwordHistory: FfiConverterOptionSequenceTypePasswordHistory.read(from: &buf), 
                creationDate: FfiConverterTypeDateTime.read(from: &buf), 
                deletedDate: FfiConverterOptionTypeDateTime.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: Cipher, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterOptionTypeUuid.write(value.organizationId, into: &buf)
        FfiConverterOptionTypeUuid.write(value.folderId, into: &buf)
        FfiConverterSequenceTypeUuid.write(value.collectionIds, into: &buf)
        FfiConverterOptionTypeEncString.write(value.key, into: &buf)
        FfiConverterTypeEncString.write(value.name, into: &buf)
        FfiConverterOptionTypeEncString.write(value.notes, into: &buf)
        FfiConverterTypeCipherType.write(value.type, into: &buf)
        FfiConverterOptionTypeLogin.write(value.login, into: &buf)
        FfiConverterOptionTypeIdentity.write(value.identity, into: &buf)
        FfiConverterOptionTypeCard.write(value.card, into: &buf)
        FfiConverterOptionTypeSecureNote.write(value.secureNote, into: &buf)
        FfiConverterBool.write(value.favorite, into: &buf)
        FfiConverterTypeCipherRepromptType.write(value.reprompt, into: &buf)
        FfiConverterBool.write(value.organizationUseTotp, into: &buf)
        FfiConverterBool.write(value.edit, into: &buf)
        FfiConverterBool.write(value.viewPassword, into: &buf)
        FfiConverterOptionTypeLocalData.write(value.localData, into: &buf)
        FfiConverterOptionSequenceTypeAttachment.write(value.attachments, into: &buf)
        FfiConverterOptionSequenceTypeField.write(value.fields, into: &buf)
        FfiConverterOptionSequenceTypePasswordHistory.write(value.passwordHistory, into: &buf)
        FfiConverterTypeDateTime.write(value.creationDate, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.deletedDate, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
    }
}


public func FfiConverterTypeCipher_lift(_ buf: RustBuffer) throws -> Cipher {
    return try FfiConverterTypeCipher.lift(buf)
}

public func FfiConverterTypeCipher_lower(_ value: Cipher) -> RustBuffer {
    return FfiConverterTypeCipher.lower(value)
}


public struct CipherListView {
    public let id: Uuid?
    public let organizationId: Uuid?
    public let folderId: Uuid?
    public let collectionIds: [Uuid]
    public let name: String
    public let subTitle: String
    public let type: CipherType
    public let favorite: Bool
    public let reprompt: CipherRepromptType
    public let edit: Bool
    public let viewPassword: Bool
    /**
     * The number of attachments
     */
    public let attachments: UInt32
    public let creationDate: DateTime
    public let deletedDate: DateTime?
    public let revisionDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: Uuid?, 
        organizationId: Uuid?, 
        folderId: Uuid?, 
        collectionIds: [Uuid], 
        name: String, 
        subTitle: String, 
        type: CipherType, 
        favorite: Bool, 
        reprompt: CipherRepromptType, 
        edit: Bool, 
        viewPassword: Bool, 
        /**
         * The number of attachments
         */
        attachments: UInt32, 
        creationDate: DateTime, 
        deletedDate: DateTime?, 
        revisionDate: DateTime) {
        self.id = id
        self.organizationId = organizationId
        self.folderId = folderId
        self.collectionIds = collectionIds
        self.name = name
        self.subTitle = subTitle
        self.type = type
        self.favorite = favorite
        self.reprompt = reprompt
        self.edit = edit
        self.viewPassword = viewPassword
        self.attachments = attachments
        self.creationDate = creationDate
        self.deletedDate = deletedDate
        self.revisionDate = revisionDate
    }
}


extension CipherListView: Equatable, Hashable {
    public static func ==(lhs: CipherListView, rhs: CipherListView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.organizationId != rhs.organizationId {
            return false
        }
        if lhs.folderId != rhs.folderId {
            return false
        }
        if lhs.collectionIds != rhs.collectionIds {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.subTitle != rhs.subTitle {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.favorite != rhs.favorite {
            return false
        }
        if lhs.reprompt != rhs.reprompt {
            return false
        }
        if lhs.edit != rhs.edit {
            return false
        }
        if lhs.viewPassword != rhs.viewPassword {
            return false
        }
        if lhs.attachments != rhs.attachments {
            return false
        }
        if lhs.creationDate != rhs.creationDate {
            return false
        }
        if lhs.deletedDate != rhs.deletedDate {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(organizationId)
        hasher.combine(folderId)
        hasher.combine(collectionIds)
        hasher.combine(name)
        hasher.combine(subTitle)
        hasher.combine(type)
        hasher.combine(favorite)
        hasher.combine(reprompt)
        hasher.combine(edit)
        hasher.combine(viewPassword)
        hasher.combine(attachments)
        hasher.combine(creationDate)
        hasher.combine(deletedDate)
        hasher.combine(revisionDate)
    }
}


public struct FfiConverterTypeCipherListView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherListView {
        return
            try CipherListView(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                organizationId: FfiConverterOptionTypeUuid.read(from: &buf), 
                folderId: FfiConverterOptionTypeUuid.read(from: &buf), 
                collectionIds: FfiConverterSequenceTypeUuid.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                subTitle: FfiConverterString.read(from: &buf), 
                type: FfiConverterTypeCipherType.read(from: &buf), 
                favorite: FfiConverterBool.read(from: &buf), 
                reprompt: FfiConverterTypeCipherRepromptType.read(from: &buf), 
                edit: FfiConverterBool.read(from: &buf), 
                viewPassword: FfiConverterBool.read(from: &buf), 
                attachments: FfiConverterUInt32.read(from: &buf), 
                creationDate: FfiConverterTypeDateTime.read(from: &buf), 
                deletedDate: FfiConverterOptionTypeDateTime.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: CipherListView, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterOptionTypeUuid.write(value.organizationId, into: &buf)
        FfiConverterOptionTypeUuid.write(value.folderId, into: &buf)
        FfiConverterSequenceTypeUuid.write(value.collectionIds, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.subTitle, into: &buf)
        FfiConverterTypeCipherType.write(value.type, into: &buf)
        FfiConverterBool.write(value.favorite, into: &buf)
        FfiConverterTypeCipherRepromptType.write(value.reprompt, into: &buf)
        FfiConverterBool.write(value.edit, into: &buf)
        FfiConverterBool.write(value.viewPassword, into: &buf)
        FfiConverterUInt32.write(value.attachments, into: &buf)
        FfiConverterTypeDateTime.write(value.creationDate, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.deletedDate, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
    }
}


public func FfiConverterTypeCipherListView_lift(_ buf: RustBuffer) throws -> CipherListView {
    return try FfiConverterTypeCipherListView.lift(buf)
}

public func FfiConverterTypeCipherListView_lower(_ value: CipherListView) -> RustBuffer {
    return FfiConverterTypeCipherListView.lower(value)
}


public struct CipherView {
    public let id: Uuid?
    public let organizationId: Uuid?
    public let folderId: Uuid?
    public let collectionIds: [Uuid]
    public let key: EncString?
    public let name: String
    public let notes: String?
    public let type: CipherType
    public let login: LoginView?
    public let identity: IdentityView?
    public let card: CardView?
    public let secureNote: SecureNoteView?
    public let favorite: Bool
    public let reprompt: CipherRepromptType
    public let organizationUseTotp: Bool
    public let edit: Bool
    public let viewPassword: Bool
    public let localData: LocalDataView?
    public let attachments: [AttachmentView]?
    public let fields: [FieldView]?
    public let passwordHistory: [PasswordHistoryView]?
    public let creationDate: DateTime
    public let deletedDate: DateTime?
    public let revisionDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: Uuid?, 
        organizationId: Uuid?, 
        folderId: Uuid?, 
        collectionIds: [Uuid], 
        key: EncString?, 
        name: String, 
        notes: String?, 
        type: CipherType, 
        login: LoginView?, 
        identity: IdentityView?, 
        card: CardView?, 
        secureNote: SecureNoteView?, 
        favorite: Bool, 
        reprompt: CipherRepromptType, 
        organizationUseTotp: Bool, 
        edit: Bool, 
        viewPassword: Bool, 
        localData: LocalDataView?, 
        attachments: [AttachmentView]?, 
        fields: [FieldView]?, 
        passwordHistory: [PasswordHistoryView]?, 
        creationDate: DateTime, 
        deletedDate: DateTime?, 
        revisionDate: DateTime) {
        self.id = id
        self.organizationId = organizationId
        self.folderId = folderId
        self.collectionIds = collectionIds
        self.key = key
        self.name = name
        self.notes = notes
        self.type = type
        self.login = login
        self.identity = identity
        self.card = card
        self.secureNote = secureNote
        self.favorite = favorite
        self.reprompt = reprompt
        self.organizationUseTotp = organizationUseTotp
        self.edit = edit
        self.viewPassword = viewPassword
        self.localData = localData
        self.attachments = attachments
        self.fields = fields
        self.passwordHistory = passwordHistory
        self.creationDate = creationDate
        self.deletedDate = deletedDate
        self.revisionDate = revisionDate
    }
}


extension CipherView: Equatable, Hashable {
    public static func ==(lhs: CipherView, rhs: CipherView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.organizationId != rhs.organizationId {
            return false
        }
        if lhs.folderId != rhs.folderId {
            return false
        }
        if lhs.collectionIds != rhs.collectionIds {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.notes != rhs.notes {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.login != rhs.login {
            return false
        }
        if lhs.identity != rhs.identity {
            return false
        }
        if lhs.card != rhs.card {
            return false
        }
        if lhs.secureNote != rhs.secureNote {
            return false
        }
        if lhs.favorite != rhs.favorite {
            return false
        }
        if lhs.reprompt != rhs.reprompt {
            return false
        }
        if lhs.organizationUseTotp != rhs.organizationUseTotp {
            return false
        }
        if lhs.edit != rhs.edit {
            return false
        }
        if lhs.viewPassword != rhs.viewPassword {
            return false
        }
        if lhs.localData != rhs.localData {
            return false
        }
        if lhs.attachments != rhs.attachments {
            return false
        }
        if lhs.fields != rhs.fields {
            return false
        }
        if lhs.passwordHistory != rhs.passwordHistory {
            return false
        }
        if lhs.creationDate != rhs.creationDate {
            return false
        }
        if lhs.deletedDate != rhs.deletedDate {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(organizationId)
        hasher.combine(folderId)
        hasher.combine(collectionIds)
        hasher.combine(key)
        hasher.combine(name)
        hasher.combine(notes)
        hasher.combine(type)
        hasher.combine(login)
        hasher.combine(identity)
        hasher.combine(card)
        hasher.combine(secureNote)
        hasher.combine(favorite)
        hasher.combine(reprompt)
        hasher.combine(organizationUseTotp)
        hasher.combine(edit)
        hasher.combine(viewPassword)
        hasher.combine(localData)
        hasher.combine(attachments)
        hasher.combine(fields)
        hasher.combine(passwordHistory)
        hasher.combine(creationDate)
        hasher.combine(deletedDate)
        hasher.combine(revisionDate)
    }
}


public struct FfiConverterTypeCipherView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherView {
        return
            try CipherView(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                organizationId: FfiConverterOptionTypeUuid.read(from: &buf), 
                folderId: FfiConverterOptionTypeUuid.read(from: &buf), 
                collectionIds: FfiConverterSequenceTypeUuid.read(from: &buf), 
                key: FfiConverterOptionTypeEncString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                notes: FfiConverterOptionString.read(from: &buf), 
                type: FfiConverterTypeCipherType.read(from: &buf), 
                login: FfiConverterOptionTypeLoginView.read(from: &buf), 
                identity: FfiConverterOptionTypeIdentityView.read(from: &buf), 
                card: FfiConverterOptionTypeCardView.read(from: &buf), 
                secureNote: FfiConverterOptionTypeSecureNoteView.read(from: &buf), 
                favorite: FfiConverterBool.read(from: &buf), 
                reprompt: FfiConverterTypeCipherRepromptType.read(from: &buf), 
                organizationUseTotp: FfiConverterBool.read(from: &buf), 
                edit: FfiConverterBool.read(from: &buf), 
                viewPassword: FfiConverterBool.read(from: &buf), 
                localData: FfiConverterOptionTypeLocalDataView.read(from: &buf), 
                attachments: FfiConverterOptionSequenceTypeAttachmentView.read(from: &buf), 
                fields: FfiConverterOptionSequenceTypeFieldView.read(from: &buf), 
                passwordHistory: FfiConverterOptionSequenceTypePasswordHistoryView.read(from: &buf), 
                creationDate: FfiConverterTypeDateTime.read(from: &buf), 
                deletedDate: FfiConverterOptionTypeDateTime.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: CipherView, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterOptionTypeUuid.write(value.organizationId, into: &buf)
        FfiConverterOptionTypeUuid.write(value.folderId, into: &buf)
        FfiConverterSequenceTypeUuid.write(value.collectionIds, into: &buf)
        FfiConverterOptionTypeEncString.write(value.key, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.notes, into: &buf)
        FfiConverterTypeCipherType.write(value.type, into: &buf)
        FfiConverterOptionTypeLoginView.write(value.login, into: &buf)
        FfiConverterOptionTypeIdentityView.write(value.identity, into: &buf)
        FfiConverterOptionTypeCardView.write(value.card, into: &buf)
        FfiConverterOptionTypeSecureNoteView.write(value.secureNote, into: &buf)
        FfiConverterBool.write(value.favorite, into: &buf)
        FfiConverterTypeCipherRepromptType.write(value.reprompt, into: &buf)
        FfiConverterBool.write(value.organizationUseTotp, into: &buf)
        FfiConverterBool.write(value.edit, into: &buf)
        FfiConverterBool.write(value.viewPassword, into: &buf)
        FfiConverterOptionTypeLocalDataView.write(value.localData, into: &buf)
        FfiConverterOptionSequenceTypeAttachmentView.write(value.attachments, into: &buf)
        FfiConverterOptionSequenceTypeFieldView.write(value.fields, into: &buf)
        FfiConverterOptionSequenceTypePasswordHistoryView.write(value.passwordHistory, into: &buf)
        FfiConverterTypeDateTime.write(value.creationDate, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.deletedDate, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
    }
}


public func FfiConverterTypeCipherView_lift(_ buf: RustBuffer) throws -> CipherView {
    return try FfiConverterTypeCipherView.lift(buf)
}

public func FfiConverterTypeCipherView_lower(_ value: CipherView) -> RustBuffer {
    return FfiConverterTypeCipherView.lower(value)
}


/**
 * Basic client behavior settings. These settings specify the various targets and behavior of the Bitwarden Client.
 * They are optional and uneditable once the client is initialized.
 *
 * Defaults to
 *
 * ```
 * # use bitwarden::client::client_settings::{ClientSettings, DeviceType};
 * let settings = ClientSettings {
 *     identity_url: "https://identity.bitwarden.com".to_string(),
 *     api_url: "https://api.bitwarden.com".to_string(),
 *     user_agent: "Bitwarden Rust-SDK".to_string(),
 *     device_type: DeviceType::SDK,
 * };
 * let default = ClientSettings::default();
 * ```
 */
public struct ClientSettings {
    /**
     * The identity url of the targeted Bitwarden instance. Defaults to `https://identity.bitwarden.com`
     */
    public let identityUrl: String
    /**
     * The api url of the targeted Bitwarden instance. Defaults to `https://api.bitwarden.com`
     */
    public let apiUrl: String
    /**
     * The user_agent to sent to Bitwarden. Defaults to `Bitwarden Rust-SDK`
     */
    public let userAgent: String
    /**
     * Device type to send to Bitwarden. Defaults to SDK
     */
    public let deviceType: DeviceType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The identity url of the targeted Bitwarden instance. Defaults to `https://identity.bitwarden.com`
         */
        identityUrl: String, 
        /**
         * The api url of the targeted Bitwarden instance. Defaults to `https://api.bitwarden.com`
         */
        apiUrl: String, 
        /**
         * The user_agent to sent to Bitwarden. Defaults to `Bitwarden Rust-SDK`
         */
        userAgent: String, 
        /**
         * Device type to send to Bitwarden. Defaults to SDK
         */
        deviceType: DeviceType) {
        self.identityUrl = identityUrl
        self.apiUrl = apiUrl
        self.userAgent = userAgent
        self.deviceType = deviceType
    }
}


extension ClientSettings: Equatable, Hashable {
    public static func ==(lhs: ClientSettings, rhs: ClientSettings) -> Bool {
        if lhs.identityUrl != rhs.identityUrl {
            return false
        }
        if lhs.apiUrl != rhs.apiUrl {
            return false
        }
        if lhs.userAgent != rhs.userAgent {
            return false
        }
        if lhs.deviceType != rhs.deviceType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityUrl)
        hasher.combine(apiUrl)
        hasher.combine(userAgent)
        hasher.combine(deviceType)
    }
}


public struct FfiConverterTypeClientSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientSettings {
        return
            try ClientSettings(
                identityUrl: FfiConverterString.read(from: &buf), 
                apiUrl: FfiConverterString.read(from: &buf), 
                userAgent: FfiConverterString.read(from: &buf), 
                deviceType: FfiConverterTypeDeviceType.read(from: &buf)
        )
    }

    public static func write(_ value: ClientSettings, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identityUrl, into: &buf)
        FfiConverterString.write(value.apiUrl, into: &buf)
        FfiConverterString.write(value.userAgent, into: &buf)
        FfiConverterTypeDeviceType.write(value.deviceType, into: &buf)
    }
}


public func FfiConverterTypeClientSettings_lift(_ buf: RustBuffer) throws -> ClientSettings {
    return try FfiConverterTypeClientSettings.lift(buf)
}

public func FfiConverterTypeClientSettings_lower(_ value: ClientSettings) -> RustBuffer {
    return FfiConverterTypeClientSettings.lower(value)
}


public struct Collection {
    public let id: Uuid?
    public let organizationId: Uuid
    public let name: EncString
    public let externalId: String?
    public let hidePasswords: Bool
    public let readOnly: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: Uuid?, 
        organizationId: Uuid, 
        name: EncString, 
        externalId: String?, 
        hidePasswords: Bool, 
        readOnly: Bool) {
        self.id = id
        self.organizationId = organizationId
        self.name = name
        self.externalId = externalId
        self.hidePasswords = hidePasswords
        self.readOnly = readOnly
    }
}


extension Collection: Equatable, Hashable {
    public static func ==(lhs: Collection, rhs: Collection) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.organizationId != rhs.organizationId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.externalId != rhs.externalId {
            return false
        }
        if lhs.hidePasswords != rhs.hidePasswords {
            return false
        }
        if lhs.readOnly != rhs.readOnly {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(organizationId)
        hasher.combine(name)
        hasher.combine(externalId)
        hasher.combine(hidePasswords)
        hasher.combine(readOnly)
    }
}


public struct FfiConverterTypeCollection: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Collection {
        return
            try Collection(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                organizationId: FfiConverterTypeUuid.read(from: &buf), 
                name: FfiConverterTypeEncString.read(from: &buf), 
                externalId: FfiConverterOptionString.read(from: &buf), 
                hidePasswords: FfiConverterBool.read(from: &buf), 
                readOnly: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Collection, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeUuid.write(value.organizationId, into: &buf)
        FfiConverterTypeEncString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.externalId, into: &buf)
        FfiConverterBool.write(value.hidePasswords, into: &buf)
        FfiConverterBool.write(value.readOnly, into: &buf)
    }
}


public func FfiConverterTypeCollection_lift(_ buf: RustBuffer) throws -> Collection {
    return try FfiConverterTypeCollection.lift(buf)
}

public func FfiConverterTypeCollection_lower(_ value: Collection) -> RustBuffer {
    return FfiConverterTypeCollection.lower(value)
}


public struct CollectionView {
    public let id: Uuid?
    public let organizationId: Uuid
    public let name: String
    public let externalId: String?
    public let hidePasswords: Bool
    public let readOnly: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: Uuid?, 
        organizationId: Uuid, 
        name: String, 
        externalId: String?, 
        hidePasswords: Bool, 
        readOnly: Bool) {
        self.id = id
        self.organizationId = organizationId
        self.name = name
        self.externalId = externalId
        self.hidePasswords = hidePasswords
        self.readOnly = readOnly
    }
}


extension CollectionView: Equatable, Hashable {
    public static func ==(lhs: CollectionView, rhs: CollectionView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.organizationId != rhs.organizationId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.externalId != rhs.externalId {
            return false
        }
        if lhs.hidePasswords != rhs.hidePasswords {
            return false
        }
        if lhs.readOnly != rhs.readOnly {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(organizationId)
        hasher.combine(name)
        hasher.combine(externalId)
        hasher.combine(hidePasswords)
        hasher.combine(readOnly)
    }
}


public struct FfiConverterTypeCollectionView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionView {
        return
            try CollectionView(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                organizationId: FfiConverterTypeUuid.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                externalId: FfiConverterOptionString.read(from: &buf), 
                hidePasswords: FfiConverterBool.read(from: &buf), 
                readOnly: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CollectionView, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeUuid.write(value.organizationId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.externalId, into: &buf)
        FfiConverterBool.write(value.hidePasswords, into: &buf)
        FfiConverterBool.write(value.readOnly, into: &buf)
    }
}


public func FfiConverterTypeCollectionView_lift(_ buf: RustBuffer) throws -> CollectionView {
    return try FfiConverterTypeCollectionView.lift(buf)
}

public func FfiConverterTypeCollectionView_lower(_ value: CollectionView) -> RustBuffer {
    return FfiConverterTypeCollectionView.lower(value)
}


public struct DerivePinKeyResponse {
    /**
     * [UserKey] protected by PIN
     */
    public let pinProtectedUserKey: EncString
    /**
     * PIN protected by [UserKey]
     */
    public let encryptedPin: EncString

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * [UserKey] protected by PIN
         */
        pinProtectedUserKey: EncString, 
        /**
         * PIN protected by [UserKey]
         */
        encryptedPin: EncString) {
        self.pinProtectedUserKey = pinProtectedUserKey
        self.encryptedPin = encryptedPin
    }
}


extension DerivePinKeyResponse: Equatable, Hashable {
    public static func ==(lhs: DerivePinKeyResponse, rhs: DerivePinKeyResponse) -> Bool {
        if lhs.pinProtectedUserKey != rhs.pinProtectedUserKey {
            return false
        }
        if lhs.encryptedPin != rhs.encryptedPin {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pinProtectedUserKey)
        hasher.combine(encryptedPin)
    }
}


public struct FfiConverterTypeDerivePinKeyResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivePinKeyResponse {
        return
            try DerivePinKeyResponse(
                pinProtectedUserKey: FfiConverterTypeEncString.read(from: &buf), 
                encryptedPin: FfiConverterTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: DerivePinKeyResponse, into buf: inout [UInt8]) {
        FfiConverterTypeEncString.write(value.pinProtectedUserKey, into: &buf)
        FfiConverterTypeEncString.write(value.encryptedPin, into: &buf)
    }
}


public func FfiConverterTypeDerivePinKeyResponse_lift(_ buf: RustBuffer) throws -> DerivePinKeyResponse {
    return try FfiConverterTypeDerivePinKeyResponse.lift(buf)
}

public func FfiConverterTypeDerivePinKeyResponse_lower(_ value: DerivePinKeyResponse) -> RustBuffer {
    return FfiConverterTypeDerivePinKeyResponse.lower(value)
}


public struct Field {
    public let name: EncString?
    public let value: EncString?
    public let type: FieldType
    public let linkedId: LinkedIdType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        name: EncString?, 
        value: EncString?, 
        type: FieldType, 
        linkedId: LinkedIdType?) {
        self.name = name
        self.value = value
        self.type = type
        self.linkedId = linkedId
    }
}


extension Field: Equatable, Hashable {
    public static func ==(lhs: Field, rhs: Field) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.linkedId != rhs.linkedId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(value)
        hasher.combine(type)
        hasher.combine(linkedId)
    }
}


public struct FfiConverterTypeField: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Field {
        return
            try Field(
                name: FfiConverterOptionTypeEncString.read(from: &buf), 
                value: FfiConverterOptionTypeEncString.read(from: &buf), 
                type: FfiConverterTypeFieldType.read(from: &buf), 
                linkedId: FfiConverterOptionTypeLinkedIdType.read(from: &buf)
        )
    }

    public static func write(_ value: Field, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.name, into: &buf)
        FfiConverterOptionTypeEncString.write(value.value, into: &buf)
        FfiConverterTypeFieldType.write(value.type, into: &buf)
        FfiConverterOptionTypeLinkedIdType.write(value.linkedId, into: &buf)
    }
}


public func FfiConverterTypeField_lift(_ buf: RustBuffer) throws -> Field {
    return try FfiConverterTypeField.lift(buf)
}

public func FfiConverterTypeField_lower(_ value: Field) -> RustBuffer {
    return FfiConverterTypeField.lower(value)
}


public struct FieldView {
    public let name: String?
    public let value: String?
    public let type: FieldType
    public let linkedId: LinkedIdType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        name: String?, 
        value: String?, 
        type: FieldType, 
        linkedId: LinkedIdType?) {
        self.name = name
        self.value = value
        self.type = type
        self.linkedId = linkedId
    }
}


extension FieldView: Equatable, Hashable {
    public static func ==(lhs: FieldView, rhs: FieldView) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.linkedId != rhs.linkedId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(value)
        hasher.combine(type)
        hasher.combine(linkedId)
    }
}


public struct FfiConverterTypeFieldView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FieldView {
        return
            try FieldView(
                name: FfiConverterOptionString.read(from: &buf), 
                value: FfiConverterOptionString.read(from: &buf), 
                type: FfiConverterTypeFieldType.read(from: &buf), 
                linkedId: FfiConverterOptionTypeLinkedIdType.read(from: &buf)
        )
    }

    public static func write(_ value: FieldView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.value, into: &buf)
        FfiConverterTypeFieldType.write(value.type, into: &buf)
        FfiConverterOptionTypeLinkedIdType.write(value.linkedId, into: &buf)
    }
}


public func FfiConverterTypeFieldView_lift(_ buf: RustBuffer) throws -> FieldView {
    return try FfiConverterTypeFieldView.lift(buf)
}

public func FfiConverterTypeFieldView_lower(_ value: FieldView) -> RustBuffer {
    return FfiConverterTypeFieldView.lower(value)
}


public struct FingerprintRequest {
    /**
     * The input material, used in the fingerprint generation process.
     */
    public let fingerprintMaterial: String
    /**
     * The user's public key encoded with base64.
     */
    public let publicKey: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The input material, used in the fingerprint generation process.
         */
        fingerprintMaterial: String, 
        /**
         * The user's public key encoded with base64.
         */
        publicKey: String) {
        self.fingerprintMaterial = fingerprintMaterial
        self.publicKey = publicKey
    }
}


extension FingerprintRequest: Equatable, Hashable {
    public static func ==(lhs: FingerprintRequest, rhs: FingerprintRequest) -> Bool {
        if lhs.fingerprintMaterial != rhs.fingerprintMaterial {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fingerprintMaterial)
        hasher.combine(publicKey)
    }
}


public struct FfiConverterTypeFingerprintRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FingerprintRequest {
        return
            try FingerprintRequest(
                fingerprintMaterial: FfiConverterString.read(from: &buf), 
                publicKey: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FingerprintRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.fingerprintMaterial, into: &buf)
        FfiConverterString.write(value.publicKey, into: &buf)
    }
}


public func FfiConverterTypeFingerprintRequest_lift(_ buf: RustBuffer) throws -> FingerprintRequest {
    return try FfiConverterTypeFingerprintRequest.lift(buf)
}

public func FfiConverterTypeFingerprintRequest_lower(_ value: FingerprintRequest) -> RustBuffer {
    return FfiConverterTypeFingerprintRequest.lower(value)
}


public struct Folder {
    public let id: Uuid?
    public let name: EncString
    public let revisionDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: Uuid?, 
        name: EncString, 
        revisionDate: DateTime) {
        self.id = id
        self.name = name
        self.revisionDate = revisionDate
    }
}


extension Folder: Equatable, Hashable {
    public static func ==(lhs: Folder, rhs: Folder) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(revisionDate)
    }
}


public struct FfiConverterTypeFolder: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Folder {
        return
            try Folder(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                name: FfiConverterTypeEncString.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: Folder, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeEncString.write(value.name, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
    }
}


public func FfiConverterTypeFolder_lift(_ buf: RustBuffer) throws -> Folder {
    return try FfiConverterTypeFolder.lift(buf)
}

public func FfiConverterTypeFolder_lower(_ value: Folder) -> RustBuffer {
    return FfiConverterTypeFolder.lower(value)
}


public struct FolderView {
    public let id: Uuid?
    public let name: String
    public let revisionDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: Uuid?, 
        name: String, 
        revisionDate: DateTime) {
        self.id = id
        self.name = name
        self.revisionDate = revisionDate
    }
}


extension FolderView: Equatable, Hashable {
    public static func ==(lhs: FolderView, rhs: FolderView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(revisionDate)
    }
}


public struct FfiConverterTypeFolderView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FolderView {
        return
            try FolderView(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: FolderView, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
    }
}


public func FfiConverterTypeFolderView_lift(_ buf: RustBuffer) throws -> FolderView {
    return try FfiConverterTypeFolderView.lift(buf)
}

public func FfiConverterTypeFolderView_lower(_ value: FolderView) -> RustBuffer {
    return FfiConverterTypeFolderView.lower(value)
}


public struct Identity {
    public let title: EncString?
    public let firstName: EncString?
    public let middleName: EncString?
    public let lastName: EncString?
    public let address1: EncString?
    public let address2: EncString?
    public let address3: EncString?
    public let city: EncString?
    public let state: EncString?
    public let postalCode: EncString?
    public let country: EncString?
    public let company: EncString?
    public let email: EncString?
    public let phone: EncString?
    public let ssn: EncString?
    public let username: EncString?
    public let passportNumber: EncString?
    public let licenseNumber: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        title: EncString?, 
        firstName: EncString?, 
        middleName: EncString?, 
        lastName: EncString?, 
        address1: EncString?, 
        address2: EncString?, 
        address3: EncString?, 
        city: EncString?, 
        state: EncString?, 
        postalCode: EncString?, 
        country: EncString?, 
        company: EncString?, 
        email: EncString?, 
        phone: EncString?, 
        ssn: EncString?, 
        username: EncString?, 
        passportNumber: EncString?, 
        licenseNumber: EncString?) {
        self.title = title
        self.firstName = firstName
        self.middleName = middleName
        self.lastName = lastName
        self.address1 = address1
        self.address2 = address2
        self.address3 = address3
        self.city = city
        self.state = state
        self.postalCode = postalCode
        self.country = country
        self.company = company
        self.email = email
        self.phone = phone
        self.ssn = ssn
        self.username = username
        self.passportNumber = passportNumber
        self.licenseNumber = licenseNumber
    }
}


extension Identity: Equatable, Hashable {
    public static func ==(lhs: Identity, rhs: Identity) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.middleName != rhs.middleName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.address1 != rhs.address1 {
            return false
        }
        if lhs.address2 != rhs.address2 {
            return false
        }
        if lhs.address3 != rhs.address3 {
            return false
        }
        if lhs.city != rhs.city {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        if lhs.postalCode != rhs.postalCode {
            return false
        }
        if lhs.country != rhs.country {
            return false
        }
        if lhs.company != rhs.company {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.phone != rhs.phone {
            return false
        }
        if lhs.ssn != rhs.ssn {
            return false
        }
        if lhs.username != rhs.username {
            return false
        }
        if lhs.passportNumber != rhs.passportNumber {
            return false
        }
        if lhs.licenseNumber != rhs.licenseNumber {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(firstName)
        hasher.combine(middleName)
        hasher.combine(lastName)
        hasher.combine(address1)
        hasher.combine(address2)
        hasher.combine(address3)
        hasher.combine(city)
        hasher.combine(state)
        hasher.combine(postalCode)
        hasher.combine(country)
        hasher.combine(company)
        hasher.combine(email)
        hasher.combine(phone)
        hasher.combine(ssn)
        hasher.combine(username)
        hasher.combine(passportNumber)
        hasher.combine(licenseNumber)
    }
}


public struct FfiConverterTypeIdentity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Identity {
        return
            try Identity(
                title: FfiConverterOptionTypeEncString.read(from: &buf), 
                firstName: FfiConverterOptionTypeEncString.read(from: &buf), 
                middleName: FfiConverterOptionTypeEncString.read(from: &buf), 
                lastName: FfiConverterOptionTypeEncString.read(from: &buf), 
                address1: FfiConverterOptionTypeEncString.read(from: &buf), 
                address2: FfiConverterOptionTypeEncString.read(from: &buf), 
                address3: FfiConverterOptionTypeEncString.read(from: &buf), 
                city: FfiConverterOptionTypeEncString.read(from: &buf), 
                state: FfiConverterOptionTypeEncString.read(from: &buf), 
                postalCode: FfiConverterOptionTypeEncString.read(from: &buf), 
                country: FfiConverterOptionTypeEncString.read(from: &buf), 
                company: FfiConverterOptionTypeEncString.read(from: &buf), 
                email: FfiConverterOptionTypeEncString.read(from: &buf), 
                phone: FfiConverterOptionTypeEncString.read(from: &buf), 
                ssn: FfiConverterOptionTypeEncString.read(from: &buf), 
                username: FfiConverterOptionTypeEncString.read(from: &buf), 
                passportNumber: FfiConverterOptionTypeEncString.read(from: &buf), 
                licenseNumber: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: Identity, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.title, into: &buf)
        FfiConverterOptionTypeEncString.write(value.firstName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.middleName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.lastName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.address1, into: &buf)
        FfiConverterOptionTypeEncString.write(value.address2, into: &buf)
        FfiConverterOptionTypeEncString.write(value.address3, into: &buf)
        FfiConverterOptionTypeEncString.write(value.city, into: &buf)
        FfiConverterOptionTypeEncString.write(value.state, into: &buf)
        FfiConverterOptionTypeEncString.write(value.postalCode, into: &buf)
        FfiConverterOptionTypeEncString.write(value.country, into: &buf)
        FfiConverterOptionTypeEncString.write(value.company, into: &buf)
        FfiConverterOptionTypeEncString.write(value.email, into: &buf)
        FfiConverterOptionTypeEncString.write(value.phone, into: &buf)
        FfiConverterOptionTypeEncString.write(value.ssn, into: &buf)
        FfiConverterOptionTypeEncString.write(value.username, into: &buf)
        FfiConverterOptionTypeEncString.write(value.passportNumber, into: &buf)
        FfiConverterOptionTypeEncString.write(value.licenseNumber, into: &buf)
    }
}


public func FfiConverterTypeIdentity_lift(_ buf: RustBuffer) throws -> Identity {
    return try FfiConverterTypeIdentity.lift(buf)
}

public func FfiConverterTypeIdentity_lower(_ value: Identity) -> RustBuffer {
    return FfiConverterTypeIdentity.lower(value)
}


public struct IdentityView {
    public let title: String?
    public let firstName: String?
    public let middleName: String?
    public let lastName: String?
    public let address1: String?
    public let address2: String?
    public let address3: String?
    public let city: String?
    public let state: String?
    public let postalCode: String?
    public let country: String?
    public let company: String?
    public let email: String?
    public let phone: String?
    public let ssn: String?
    public let username: String?
    public let passportNumber: String?
    public let licenseNumber: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        title: String?, 
        firstName: String?, 
        middleName: String?, 
        lastName: String?, 
        address1: String?, 
        address2: String?, 
        address3: String?, 
        city: String?, 
        state: String?, 
        postalCode: String?, 
        country: String?, 
        company: String?, 
        email: String?, 
        phone: String?, 
        ssn: String?, 
        username: String?, 
        passportNumber: String?, 
        licenseNumber: String?) {
        self.title = title
        self.firstName = firstName
        self.middleName = middleName
        self.lastName = lastName
        self.address1 = address1
        self.address2 = address2
        self.address3 = address3
        self.city = city
        self.state = state
        self.postalCode = postalCode
        self.country = country
        self.company = company
        self.email = email
        self.phone = phone
        self.ssn = ssn
        self.username = username
        self.passportNumber = passportNumber
        self.licenseNumber = licenseNumber
    }
}


extension IdentityView: Equatable, Hashable {
    public static func ==(lhs: IdentityView, rhs: IdentityView) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.middleName != rhs.middleName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.address1 != rhs.address1 {
            return false
        }
        if lhs.address2 != rhs.address2 {
            return false
        }
        if lhs.address3 != rhs.address3 {
            return false
        }
        if lhs.city != rhs.city {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        if lhs.postalCode != rhs.postalCode {
            return false
        }
        if lhs.country != rhs.country {
            return false
        }
        if lhs.company != rhs.company {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.phone != rhs.phone {
            return false
        }
        if lhs.ssn != rhs.ssn {
            return false
        }
        if lhs.username != rhs.username {
            return false
        }
        if lhs.passportNumber != rhs.passportNumber {
            return false
        }
        if lhs.licenseNumber != rhs.licenseNumber {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(firstName)
        hasher.combine(middleName)
        hasher.combine(lastName)
        hasher.combine(address1)
        hasher.combine(address2)
        hasher.combine(address3)
        hasher.combine(city)
        hasher.combine(state)
        hasher.combine(postalCode)
        hasher.combine(country)
        hasher.combine(company)
        hasher.combine(email)
        hasher.combine(phone)
        hasher.combine(ssn)
        hasher.combine(username)
        hasher.combine(passportNumber)
        hasher.combine(licenseNumber)
    }
}


public struct FfiConverterTypeIdentityView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityView {
        return
            try IdentityView(
                title: FfiConverterOptionString.read(from: &buf), 
                firstName: FfiConverterOptionString.read(from: &buf), 
                middleName: FfiConverterOptionString.read(from: &buf), 
                lastName: FfiConverterOptionString.read(from: &buf), 
                address1: FfiConverterOptionString.read(from: &buf), 
                address2: FfiConverterOptionString.read(from: &buf), 
                address3: FfiConverterOptionString.read(from: &buf), 
                city: FfiConverterOptionString.read(from: &buf), 
                state: FfiConverterOptionString.read(from: &buf), 
                postalCode: FfiConverterOptionString.read(from: &buf), 
                country: FfiConverterOptionString.read(from: &buf), 
                company: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                phone: FfiConverterOptionString.read(from: &buf), 
                ssn: FfiConverterOptionString.read(from: &buf), 
                username: FfiConverterOptionString.read(from: &buf), 
                passportNumber: FfiConverterOptionString.read(from: &buf), 
                licenseNumber: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.firstName, into: &buf)
        FfiConverterOptionString.write(value.middleName, into: &buf)
        FfiConverterOptionString.write(value.lastName, into: &buf)
        FfiConverterOptionString.write(value.address1, into: &buf)
        FfiConverterOptionString.write(value.address2, into: &buf)
        FfiConverterOptionString.write(value.address3, into: &buf)
        FfiConverterOptionString.write(value.city, into: &buf)
        FfiConverterOptionString.write(value.state, into: &buf)
        FfiConverterOptionString.write(value.postalCode, into: &buf)
        FfiConverterOptionString.write(value.country, into: &buf)
        FfiConverterOptionString.write(value.company, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.phone, into: &buf)
        FfiConverterOptionString.write(value.ssn, into: &buf)
        FfiConverterOptionString.write(value.username, into: &buf)
        FfiConverterOptionString.write(value.passportNumber, into: &buf)
        FfiConverterOptionString.write(value.licenseNumber, into: &buf)
    }
}


public func FfiConverterTypeIdentityView_lift(_ buf: RustBuffer) throws -> IdentityView {
    return try FfiConverterTypeIdentityView.lift(buf)
}

public func FfiConverterTypeIdentityView_lower(_ value: IdentityView) -> RustBuffer {
    return FfiConverterTypeIdentityView.lower(value)
}


public struct InitOrgCryptoRequest {
    /**
     * The encryption keys for all the organizations the user is a part of
     */
    public let organizationKeys: [Uuid: AsymmetricEncString]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The encryption keys for all the organizations the user is a part of
         */
        organizationKeys: [Uuid: AsymmetricEncString]) {
        self.organizationKeys = organizationKeys
    }
}


extension InitOrgCryptoRequest: Equatable, Hashable {
    public static func ==(lhs: InitOrgCryptoRequest, rhs: InitOrgCryptoRequest) -> Bool {
        if lhs.organizationKeys != rhs.organizationKeys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(organizationKeys)
    }
}


public struct FfiConverterTypeInitOrgCryptoRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitOrgCryptoRequest {
        return
            try InitOrgCryptoRequest(
                organizationKeys: FfiConverterDictionaryTypeUuidTypeAsymmetricEncString.read(from: &buf)
        )
    }

    public static func write(_ value: InitOrgCryptoRequest, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeUuidTypeAsymmetricEncString.write(value.organizationKeys, into: &buf)
    }
}


public func FfiConverterTypeInitOrgCryptoRequest_lift(_ buf: RustBuffer) throws -> InitOrgCryptoRequest {
    return try FfiConverterTypeInitOrgCryptoRequest.lift(buf)
}

public func FfiConverterTypeInitOrgCryptoRequest_lower(_ value: InitOrgCryptoRequest) -> RustBuffer {
    return FfiConverterTypeInitOrgCryptoRequest.lower(value)
}


public struct InitUserCryptoRequest {
    /**
     * The user's KDF parameters, as received from the prelogin request
     */
    public let kdfParams: Kdf
    /**
     * The user's email address
     */
    public let email: String
    /**
     * The user's encrypted private key
     */
    public let privateKey: String
    /**
     * The initialization method to use
     */
    public let method: InitUserCryptoMethod

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The user's KDF parameters, as received from the prelogin request
         */
        kdfParams: Kdf, 
        /**
         * The user's email address
         */
        email: String, 
        /**
         * The user's encrypted private key
         */
        privateKey: String, 
        /**
         * The initialization method to use
         */
        method: InitUserCryptoMethod) {
        self.kdfParams = kdfParams
        self.email = email
        self.privateKey = privateKey
        self.method = method
    }
}


extension InitUserCryptoRequest: Equatable, Hashable {
    public static func ==(lhs: InitUserCryptoRequest, rhs: InitUserCryptoRequest) -> Bool {
        if lhs.kdfParams != rhs.kdfParams {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.privateKey != rhs.privateKey {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kdfParams)
        hasher.combine(email)
        hasher.combine(privateKey)
        hasher.combine(method)
    }
}


public struct FfiConverterTypeInitUserCryptoRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitUserCryptoRequest {
        return
            try InitUserCryptoRequest(
                kdfParams: FfiConverterTypeKdf.read(from: &buf), 
                email: FfiConverterString.read(from: &buf), 
                privateKey: FfiConverterString.read(from: &buf), 
                method: FfiConverterTypeInitUserCryptoMethod.read(from: &buf)
        )
    }

    public static func write(_ value: InitUserCryptoRequest, into buf: inout [UInt8]) {
        FfiConverterTypeKdf.write(value.kdfParams, into: &buf)
        FfiConverterString.write(value.email, into: &buf)
        FfiConverterString.write(value.privateKey, into: &buf)
        FfiConverterTypeInitUserCryptoMethod.write(value.method, into: &buf)
    }
}


public func FfiConverterTypeInitUserCryptoRequest_lift(_ buf: RustBuffer) throws -> InitUserCryptoRequest {
    return try FfiConverterTypeInitUserCryptoRequest.lift(buf)
}

public func FfiConverterTypeInitUserCryptoRequest_lower(_ value: InitUserCryptoRequest) -> RustBuffer {
    return FfiConverterTypeInitUserCryptoRequest.lower(value)
}


public struct LocalData {
    public let lastUsedDate: UInt32?
    public let lastLaunched: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        lastUsedDate: UInt32?, 
        lastLaunched: UInt32?) {
        self.lastUsedDate = lastUsedDate
        self.lastLaunched = lastLaunched
    }
}


extension LocalData: Equatable, Hashable {
    public static func ==(lhs: LocalData, rhs: LocalData) -> Bool {
        if lhs.lastUsedDate != rhs.lastUsedDate {
            return false
        }
        if lhs.lastLaunched != rhs.lastLaunched {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastUsedDate)
        hasher.combine(lastLaunched)
    }
}


public struct FfiConverterTypeLocalData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalData {
        return
            try LocalData(
                lastUsedDate: FfiConverterOptionUInt32.read(from: &buf), 
                lastLaunched: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: LocalData, into buf: inout [UInt8]) {
        FfiConverterOptionUInt32.write(value.lastUsedDate, into: &buf)
        FfiConverterOptionUInt32.write(value.lastLaunched, into: &buf)
    }
}


public func FfiConverterTypeLocalData_lift(_ buf: RustBuffer) throws -> LocalData {
    return try FfiConverterTypeLocalData.lift(buf)
}

public func FfiConverterTypeLocalData_lower(_ value: LocalData) -> RustBuffer {
    return FfiConverterTypeLocalData.lower(value)
}


public struct LocalDataView {
    public let lastUsedDate: UInt32?
    public let lastLaunched: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        lastUsedDate: UInt32?, 
        lastLaunched: UInt32?) {
        self.lastUsedDate = lastUsedDate
        self.lastLaunched = lastLaunched
    }
}


extension LocalDataView: Equatable, Hashable {
    public static func ==(lhs: LocalDataView, rhs: LocalDataView) -> Bool {
        if lhs.lastUsedDate != rhs.lastUsedDate {
            return false
        }
        if lhs.lastLaunched != rhs.lastLaunched {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastUsedDate)
        hasher.combine(lastLaunched)
    }
}


public struct FfiConverterTypeLocalDataView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalDataView {
        return
            try LocalDataView(
                lastUsedDate: FfiConverterOptionUInt32.read(from: &buf), 
                lastLaunched: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: LocalDataView, into buf: inout [UInt8]) {
        FfiConverterOptionUInt32.write(value.lastUsedDate, into: &buf)
        FfiConverterOptionUInt32.write(value.lastLaunched, into: &buf)
    }
}


public func FfiConverterTypeLocalDataView_lift(_ buf: RustBuffer) throws -> LocalDataView {
    return try FfiConverterTypeLocalDataView.lift(buf)
}

public func FfiConverterTypeLocalDataView_lower(_ value: LocalDataView) -> RustBuffer {
    return FfiConverterTypeLocalDataView.lower(value)
}


public struct Login {
    public let username: EncString?
    public let password: EncString?
    public let passwordRevisionDate: DateTime?
    public let uris: [LoginUri]?
    public let totp: EncString?
    public let autofillOnPageLoad: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        username: EncString?, 
        password: EncString?, 
        passwordRevisionDate: DateTime?, 
        uris: [LoginUri]?, 
        totp: EncString?, 
        autofillOnPageLoad: Bool?) {
        self.username = username
        self.password = password
        self.passwordRevisionDate = passwordRevisionDate
        self.uris = uris
        self.totp = totp
        self.autofillOnPageLoad = autofillOnPageLoad
    }
}


extension Login: Equatable, Hashable {
    public static func ==(lhs: Login, rhs: Login) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.passwordRevisionDate != rhs.passwordRevisionDate {
            return false
        }
        if lhs.uris != rhs.uris {
            return false
        }
        if lhs.totp != rhs.totp {
            return false
        }
        if lhs.autofillOnPageLoad != rhs.autofillOnPageLoad {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(password)
        hasher.combine(passwordRevisionDate)
        hasher.combine(uris)
        hasher.combine(totp)
        hasher.combine(autofillOnPageLoad)
    }
}


public struct FfiConverterTypeLogin: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Login {
        return
            try Login(
                username: FfiConverterOptionTypeEncString.read(from: &buf), 
                password: FfiConverterOptionTypeEncString.read(from: &buf), 
                passwordRevisionDate: FfiConverterOptionTypeDateTime.read(from: &buf), 
                uris: FfiConverterOptionSequenceTypeLoginUri.read(from: &buf), 
                totp: FfiConverterOptionTypeEncString.read(from: &buf), 
                autofillOnPageLoad: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: Login, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.username, into: &buf)
        FfiConverterOptionTypeEncString.write(value.password, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.passwordRevisionDate, into: &buf)
        FfiConverterOptionSequenceTypeLoginUri.write(value.uris, into: &buf)
        FfiConverterOptionTypeEncString.write(value.totp, into: &buf)
        FfiConverterOptionBool.write(value.autofillOnPageLoad, into: &buf)
    }
}


public func FfiConverterTypeLogin_lift(_ buf: RustBuffer) throws -> Login {
    return try FfiConverterTypeLogin.lift(buf)
}

public func FfiConverterTypeLogin_lower(_ value: Login) -> RustBuffer {
    return FfiConverterTypeLogin.lower(value)
}


public struct LoginUri {
    public let uri: EncString?
    public let match: UriMatchType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        uri: EncString?, 
        match: UriMatchType?) {
        self.uri = uri
        self.match = match
    }
}


extension LoginUri: Equatable, Hashable {
    public static func ==(lhs: LoginUri, rhs: LoginUri) -> Bool {
        if lhs.uri != rhs.uri {
            return false
        }
        if lhs.match != rhs.match {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uri)
        hasher.combine(match)
    }
}


public struct FfiConverterTypeLoginUri: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoginUri {
        return
            try LoginUri(
                uri: FfiConverterOptionTypeEncString.read(from: &buf), 
                match: FfiConverterOptionTypeUriMatchType.read(from: &buf)
        )
    }

    public static func write(_ value: LoginUri, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.uri, into: &buf)
        FfiConverterOptionTypeUriMatchType.write(value.match, into: &buf)
    }
}


public func FfiConverterTypeLoginUri_lift(_ buf: RustBuffer) throws -> LoginUri {
    return try FfiConverterTypeLoginUri.lift(buf)
}

public func FfiConverterTypeLoginUri_lower(_ value: LoginUri) -> RustBuffer {
    return FfiConverterTypeLoginUri.lower(value)
}


public struct LoginUriView {
    public let uri: String?
    public let match: UriMatchType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        uri: String?, 
        match: UriMatchType?) {
        self.uri = uri
        self.match = match
    }
}


extension LoginUriView: Equatable, Hashable {
    public static func ==(lhs: LoginUriView, rhs: LoginUriView) -> Bool {
        if lhs.uri != rhs.uri {
            return false
        }
        if lhs.match != rhs.match {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uri)
        hasher.combine(match)
    }
}


public struct FfiConverterTypeLoginUriView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoginUriView {
        return
            try LoginUriView(
                uri: FfiConverterOptionString.read(from: &buf), 
                match: FfiConverterOptionTypeUriMatchType.read(from: &buf)
        )
    }

    public static func write(_ value: LoginUriView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.uri, into: &buf)
        FfiConverterOptionTypeUriMatchType.write(value.match, into: &buf)
    }
}


public func FfiConverterTypeLoginUriView_lift(_ buf: RustBuffer) throws -> LoginUriView {
    return try FfiConverterTypeLoginUriView.lift(buf)
}

public func FfiConverterTypeLoginUriView_lower(_ value: LoginUriView) -> RustBuffer {
    return FfiConverterTypeLoginUriView.lower(value)
}


public struct LoginView {
    public let username: String?
    public let password: String?
    public let passwordRevisionDate: DateTime?
    public let uris: [LoginUriView]?
    public let totp: String?
    public let autofillOnPageLoad: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        username: String?, 
        password: String?, 
        passwordRevisionDate: DateTime?, 
        uris: [LoginUriView]?, 
        totp: String?, 
        autofillOnPageLoad: Bool?) {
        self.username = username
        self.password = password
        self.passwordRevisionDate = passwordRevisionDate
        self.uris = uris
        self.totp = totp
        self.autofillOnPageLoad = autofillOnPageLoad
    }
}


extension LoginView: Equatable, Hashable {
    public static func ==(lhs: LoginView, rhs: LoginView) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.passwordRevisionDate != rhs.passwordRevisionDate {
            return false
        }
        if lhs.uris != rhs.uris {
            return false
        }
        if lhs.totp != rhs.totp {
            return false
        }
        if lhs.autofillOnPageLoad != rhs.autofillOnPageLoad {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(password)
        hasher.combine(passwordRevisionDate)
        hasher.combine(uris)
        hasher.combine(totp)
        hasher.combine(autofillOnPageLoad)
    }
}


public struct FfiConverterTypeLoginView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoginView {
        return
            try LoginView(
                username: FfiConverterOptionString.read(from: &buf), 
                password: FfiConverterOptionString.read(from: &buf), 
                passwordRevisionDate: FfiConverterOptionTypeDateTime.read(from: &buf), 
                uris: FfiConverterOptionSequenceTypeLoginUriView.read(from: &buf), 
                totp: FfiConverterOptionString.read(from: &buf), 
                autofillOnPageLoad: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: LoginView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.username, into: &buf)
        FfiConverterOptionString.write(value.password, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.passwordRevisionDate, into: &buf)
        FfiConverterOptionSequenceTypeLoginUriView.write(value.uris, into: &buf)
        FfiConverterOptionString.write(value.totp, into: &buf)
        FfiConverterOptionBool.write(value.autofillOnPageLoad, into: &buf)
    }
}


public func FfiConverterTypeLoginView_lift(_ buf: RustBuffer) throws -> LoginView {
    return try FfiConverterTypeLoginView.lift(buf)
}

public func FfiConverterTypeLoginView_lower(_ value: LoginView) -> RustBuffer {
    return FfiConverterTypeLoginView.lower(value)
}


public struct MasterPasswordPolicyOptions {
    public let minComplexity: UInt8
    public let minLength: UInt8
    public let requireUpper: Bool
    public let requireLower: Bool
    public let requireNumbers: Bool
    public let requireSpecial: Bool
    /**
     * Flag to indicate if the policy should be enforced on login.
     * If true, and the user's password does not meet the policy requirements,
     * the user will be forced to update their password.
     */
    public let enforceOnLogin: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        minComplexity: UInt8, 
        minLength: UInt8, 
        requireUpper: Bool, 
        requireLower: Bool, 
        requireNumbers: Bool, 
        requireSpecial: Bool, 
        /**
         * Flag to indicate if the policy should be enforced on login.
         * If true, and the user's password does not meet the policy requirements,
         * the user will be forced to update their password.
         */
        enforceOnLogin: Bool) {
        self.minComplexity = minComplexity
        self.minLength = minLength
        self.requireUpper = requireUpper
        self.requireLower = requireLower
        self.requireNumbers = requireNumbers
        self.requireSpecial = requireSpecial
        self.enforceOnLogin = enforceOnLogin
    }
}


extension MasterPasswordPolicyOptions: Equatable, Hashable {
    public static func ==(lhs: MasterPasswordPolicyOptions, rhs: MasterPasswordPolicyOptions) -> Bool {
        if lhs.minComplexity != rhs.minComplexity {
            return false
        }
        if lhs.minLength != rhs.minLength {
            return false
        }
        if lhs.requireUpper != rhs.requireUpper {
            return false
        }
        if lhs.requireLower != rhs.requireLower {
            return false
        }
        if lhs.requireNumbers != rhs.requireNumbers {
            return false
        }
        if lhs.requireSpecial != rhs.requireSpecial {
            return false
        }
        if lhs.enforceOnLogin != rhs.enforceOnLogin {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(minComplexity)
        hasher.combine(minLength)
        hasher.combine(requireUpper)
        hasher.combine(requireLower)
        hasher.combine(requireNumbers)
        hasher.combine(requireSpecial)
        hasher.combine(enforceOnLogin)
    }
}


public struct FfiConverterTypeMasterPasswordPolicyOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MasterPasswordPolicyOptions {
        return
            try MasterPasswordPolicyOptions(
                minComplexity: FfiConverterUInt8.read(from: &buf), 
                minLength: FfiConverterUInt8.read(from: &buf), 
                requireUpper: FfiConverterBool.read(from: &buf), 
                requireLower: FfiConverterBool.read(from: &buf), 
                requireNumbers: FfiConverterBool.read(from: &buf), 
                requireSpecial: FfiConverterBool.read(from: &buf), 
                enforceOnLogin: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MasterPasswordPolicyOptions, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.minComplexity, into: &buf)
        FfiConverterUInt8.write(value.minLength, into: &buf)
        FfiConverterBool.write(value.requireUpper, into: &buf)
        FfiConverterBool.write(value.requireLower, into: &buf)
        FfiConverterBool.write(value.requireNumbers, into: &buf)
        FfiConverterBool.write(value.requireSpecial, into: &buf)
        FfiConverterBool.write(value.enforceOnLogin, into: &buf)
    }
}


public func FfiConverterTypeMasterPasswordPolicyOptions_lift(_ buf: RustBuffer) throws -> MasterPasswordPolicyOptions {
    return try FfiConverterTypeMasterPasswordPolicyOptions.lift(buf)
}

public func FfiConverterTypeMasterPasswordPolicyOptions_lower(_ value: MasterPasswordPolicyOptions) -> RustBuffer {
    return FfiConverterTypeMasterPasswordPolicyOptions.lower(value)
}


/**
 * Passphrase generator request options.
 */
public struct PassphraseGeneratorRequest {
    /**
     * Number of words in the generated passphrase.
     * This value must be between 3 and 20.
     */
    public let numWords: UInt8
    /**
     * Character separator between words in the generated passphrase. The value cannot be empty.
     */
    public let wordSeparator: String
    /**
     * When set to true, capitalize the first letter of each word in the generated passphrase.
     */
    public let capitalize: Bool
    /**
     * When set to true, include a number at the end of one of the words in the generated passphrase.
     */
    public let includeNumber: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Number of words in the generated passphrase.
         * This value must be between 3 and 20.
         */
        numWords: UInt8, 
        /**
         * Character separator between words in the generated passphrase. The value cannot be empty.
         */
        wordSeparator: String, 
        /**
         * When set to true, capitalize the first letter of each word in the generated passphrase.
         */
        capitalize: Bool, 
        /**
         * When set to true, include a number at the end of one of the words in the generated passphrase.
         */
        includeNumber: Bool) {
        self.numWords = numWords
        self.wordSeparator = wordSeparator
        self.capitalize = capitalize
        self.includeNumber = includeNumber
    }
}


extension PassphraseGeneratorRequest: Equatable, Hashable {
    public static func ==(lhs: PassphraseGeneratorRequest, rhs: PassphraseGeneratorRequest) -> Bool {
        if lhs.numWords != rhs.numWords {
            return false
        }
        if lhs.wordSeparator != rhs.wordSeparator {
            return false
        }
        if lhs.capitalize != rhs.capitalize {
            return false
        }
        if lhs.includeNumber != rhs.includeNumber {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numWords)
        hasher.combine(wordSeparator)
        hasher.combine(capitalize)
        hasher.combine(includeNumber)
    }
}


public struct FfiConverterTypePassphraseGeneratorRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PassphraseGeneratorRequest {
        return
            try PassphraseGeneratorRequest(
                numWords: FfiConverterUInt8.read(from: &buf), 
                wordSeparator: FfiConverterString.read(from: &buf), 
                capitalize: FfiConverterBool.read(from: &buf), 
                includeNumber: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: PassphraseGeneratorRequest, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.numWords, into: &buf)
        FfiConverterString.write(value.wordSeparator, into: &buf)
        FfiConverterBool.write(value.capitalize, into: &buf)
        FfiConverterBool.write(value.includeNumber, into: &buf)
    }
}


public func FfiConverterTypePassphraseGeneratorRequest_lift(_ buf: RustBuffer) throws -> PassphraseGeneratorRequest {
    return try FfiConverterTypePassphraseGeneratorRequest.lift(buf)
}

public func FfiConverterTypePassphraseGeneratorRequest_lower(_ value: PassphraseGeneratorRequest) -> RustBuffer {
    return FfiConverterTypePassphraseGeneratorRequest.lower(value)
}


/**
 * Password generator request options.
 */
public struct PasswordGeneratorRequest {
    /**
     * Include lowercase characters (a-z).
     */
    public let lowercase: Bool
    /**
     * Include uppercase characters (A-Z).
     */
    public let uppercase: Bool
    /**
     * Include numbers (0-9).
     */
    public let numbers: Bool
    /**
     * Include special characters: ! @ # $ % ^ & *
     */
    public let special: Bool
    /**
     * The length of the generated password.
     * Note that the password length must be greater than the sum of all the minimums.
     */
    public let length: UInt8
    /**
     * When set to true, the generated password will not contain ambiguous characters.
     * The ambiguous characters are: I, O, l, 0, 1
     */
    public let avoidAmbiguous: Bool
    /**
     * The minimum number of lowercase characters in the generated password.
     * When set, the value must be between 1 and 9. This value is ignored is lowercase is false
     */
    public let minLowercase: UInt8?
    /**
     * The minimum number of uppercase characters in the generated password.
     * When set, the value must be between 1 and 9. This value is ignored is uppercase is false  
     */
    public let minUppercase: UInt8?
    /**
     * The minimum number of numbers in the generated password.
     * When set, the value must be between 1 and 9. This value is ignored is numbers is false
     */
    public let minNumber: UInt8?
    /**
     * The minimum number of special characters in the generated password.
     * When set, the value must be between 1 and 9. This value is ignored is special is false
     */
    public let minSpecial: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Include lowercase characters (a-z).
         */
        lowercase: Bool, 
        /**
         * Include uppercase characters (A-Z).
         */
        uppercase: Bool, 
        /**
         * Include numbers (0-9).
         */
        numbers: Bool, 
        /**
         * Include special characters: ! @ # $ % ^ & *
         */
        special: Bool, 
        /**
         * The length of the generated password.
         * Note that the password length must be greater than the sum of all the minimums.
         */
        length: UInt8, 
        /**
         * When set to true, the generated password will not contain ambiguous characters.
         * The ambiguous characters are: I, O, l, 0, 1
         */
        avoidAmbiguous: Bool, 
        /**
         * The minimum number of lowercase characters in the generated password.
         * When set, the value must be between 1 and 9. This value is ignored is lowercase is false
         */
        minLowercase: UInt8?, 
        /**
         * The minimum number of uppercase characters in the generated password.
         * When set, the value must be between 1 and 9. This value is ignored is uppercase is false  
         */
        minUppercase: UInt8?, 
        /**
         * The minimum number of numbers in the generated password.
         * When set, the value must be between 1 and 9. This value is ignored is numbers is false
         */
        minNumber: UInt8?, 
        /**
         * The minimum number of special characters in the generated password.
         * When set, the value must be between 1 and 9. This value is ignored is special is false
         */
        minSpecial: UInt8?) {
        self.lowercase = lowercase
        self.uppercase = uppercase
        self.numbers = numbers
        self.special = special
        self.length = length
        self.avoidAmbiguous = avoidAmbiguous
        self.minLowercase = minLowercase
        self.minUppercase = minUppercase
        self.minNumber = minNumber
        self.minSpecial = minSpecial
    }
}


extension PasswordGeneratorRequest: Equatable, Hashable {
    public static func ==(lhs: PasswordGeneratorRequest, rhs: PasswordGeneratorRequest) -> Bool {
        if lhs.lowercase != rhs.lowercase {
            return false
        }
        if lhs.uppercase != rhs.uppercase {
            return false
        }
        if lhs.numbers != rhs.numbers {
            return false
        }
        if lhs.special != rhs.special {
            return false
        }
        if lhs.length != rhs.length {
            return false
        }
        if lhs.avoidAmbiguous != rhs.avoidAmbiguous {
            return false
        }
        if lhs.minLowercase != rhs.minLowercase {
            return false
        }
        if lhs.minUppercase != rhs.minUppercase {
            return false
        }
        if lhs.minNumber != rhs.minNumber {
            return false
        }
        if lhs.minSpecial != rhs.minSpecial {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lowercase)
        hasher.combine(uppercase)
        hasher.combine(numbers)
        hasher.combine(special)
        hasher.combine(length)
        hasher.combine(avoidAmbiguous)
        hasher.combine(minLowercase)
        hasher.combine(minUppercase)
        hasher.combine(minNumber)
        hasher.combine(minSpecial)
    }
}


public struct FfiConverterTypePasswordGeneratorRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PasswordGeneratorRequest {
        return
            try PasswordGeneratorRequest(
                lowercase: FfiConverterBool.read(from: &buf), 
                uppercase: FfiConverterBool.read(from: &buf), 
                numbers: FfiConverterBool.read(from: &buf), 
                special: FfiConverterBool.read(from: &buf), 
                length: FfiConverterUInt8.read(from: &buf), 
                avoidAmbiguous: FfiConverterBool.read(from: &buf), 
                minLowercase: FfiConverterOptionUInt8.read(from: &buf), 
                minUppercase: FfiConverterOptionUInt8.read(from: &buf), 
                minNumber: FfiConverterOptionUInt8.read(from: &buf), 
                minSpecial: FfiConverterOptionUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: PasswordGeneratorRequest, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.lowercase, into: &buf)
        FfiConverterBool.write(value.uppercase, into: &buf)
        FfiConverterBool.write(value.numbers, into: &buf)
        FfiConverterBool.write(value.special, into: &buf)
        FfiConverterUInt8.write(value.length, into: &buf)
        FfiConverterBool.write(value.avoidAmbiguous, into: &buf)
        FfiConverterOptionUInt8.write(value.minLowercase, into: &buf)
        FfiConverterOptionUInt8.write(value.minUppercase, into: &buf)
        FfiConverterOptionUInt8.write(value.minNumber, into: &buf)
        FfiConverterOptionUInt8.write(value.minSpecial, into: &buf)
    }
}


public func FfiConverterTypePasswordGeneratorRequest_lift(_ buf: RustBuffer) throws -> PasswordGeneratorRequest {
    return try FfiConverterTypePasswordGeneratorRequest.lift(buf)
}

public func FfiConverterTypePasswordGeneratorRequest_lower(_ value: PasswordGeneratorRequest) -> RustBuffer {
    return FfiConverterTypePasswordGeneratorRequest.lower(value)
}


public struct PasswordHistory {
    public let password: EncString
    public let lastUsedDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        password: EncString, 
        lastUsedDate: DateTime) {
        self.password = password
        self.lastUsedDate = lastUsedDate
    }
}


extension PasswordHistory: Equatable, Hashable {
    public static func ==(lhs: PasswordHistory, rhs: PasswordHistory) -> Bool {
        if lhs.password != rhs.password {
            return false
        }
        if lhs.lastUsedDate != rhs.lastUsedDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(password)
        hasher.combine(lastUsedDate)
    }
}


public struct FfiConverterTypePasswordHistory: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PasswordHistory {
        return
            try PasswordHistory(
                password: FfiConverterTypeEncString.read(from: &buf), 
                lastUsedDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: PasswordHistory, into buf: inout [UInt8]) {
        FfiConverterTypeEncString.write(value.password, into: &buf)
        FfiConverterTypeDateTime.write(value.lastUsedDate, into: &buf)
    }
}


public func FfiConverterTypePasswordHistory_lift(_ buf: RustBuffer) throws -> PasswordHistory {
    return try FfiConverterTypePasswordHistory.lift(buf)
}

public func FfiConverterTypePasswordHistory_lower(_ value: PasswordHistory) -> RustBuffer {
    return FfiConverterTypePasswordHistory.lower(value)
}


public struct PasswordHistoryView {
    public let password: String
    public let lastUsedDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        password: String, 
        lastUsedDate: DateTime) {
        self.password = password
        self.lastUsedDate = lastUsedDate
    }
}


extension PasswordHistoryView: Equatable, Hashable {
    public static func ==(lhs: PasswordHistoryView, rhs: PasswordHistoryView) -> Bool {
        if lhs.password != rhs.password {
            return false
        }
        if lhs.lastUsedDate != rhs.lastUsedDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(password)
        hasher.combine(lastUsedDate)
    }
}


public struct FfiConverterTypePasswordHistoryView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PasswordHistoryView {
        return
            try PasswordHistoryView(
                password: FfiConverterString.read(from: &buf), 
                lastUsedDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: PasswordHistoryView, into buf: inout [UInt8]) {
        FfiConverterString.write(value.password, into: &buf)
        FfiConverterTypeDateTime.write(value.lastUsedDate, into: &buf)
    }
}


public func FfiConverterTypePasswordHistoryView_lift(_ buf: RustBuffer) throws -> PasswordHistoryView {
    return try FfiConverterTypePasswordHistoryView.lift(buf)
}

public func FfiConverterTypePasswordHistoryView_lower(_ value: PasswordHistoryView) -> RustBuffer {
    return FfiConverterTypePasswordHistoryView.lower(value)
}


public struct RegisterKeyResponse {
    public let masterPasswordHash: String
    public let encryptedUserKey: String
    public let keys: RsaKeyPair

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        masterPasswordHash: String, 
        encryptedUserKey: String, 
        keys: RsaKeyPair) {
        self.masterPasswordHash = masterPasswordHash
        self.encryptedUserKey = encryptedUserKey
        self.keys = keys
    }
}


extension RegisterKeyResponse: Equatable, Hashable {
    public static func ==(lhs: RegisterKeyResponse, rhs: RegisterKeyResponse) -> Bool {
        if lhs.masterPasswordHash != rhs.masterPasswordHash {
            return false
        }
        if lhs.encryptedUserKey != rhs.encryptedUserKey {
            return false
        }
        if lhs.keys != rhs.keys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(masterPasswordHash)
        hasher.combine(encryptedUserKey)
        hasher.combine(keys)
    }
}


public struct FfiConverterTypeRegisterKeyResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RegisterKeyResponse {
        return
            try RegisterKeyResponse(
                masterPasswordHash: FfiConverterString.read(from: &buf), 
                encryptedUserKey: FfiConverterString.read(from: &buf), 
                keys: FfiConverterTypeRsaKeyPair.read(from: &buf)
        )
    }

    public static func write(_ value: RegisterKeyResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.masterPasswordHash, into: &buf)
        FfiConverterString.write(value.encryptedUserKey, into: &buf)
        FfiConverterTypeRsaKeyPair.write(value.keys, into: &buf)
    }
}


public func FfiConverterTypeRegisterKeyResponse_lift(_ buf: RustBuffer) throws -> RegisterKeyResponse {
    return try FfiConverterTypeRegisterKeyResponse.lift(buf)
}

public func FfiConverterTypeRegisterKeyResponse_lower(_ value: RegisterKeyResponse) -> RustBuffer {
    return FfiConverterTypeRegisterKeyResponse.lower(value)
}


public struct SecureNote {
    public let type: SecureNoteType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        type: SecureNoteType) {
        self.type = type
    }
}


extension SecureNote: Equatable, Hashable {
    public static func ==(lhs: SecureNote, rhs: SecureNote) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
    }
}


public struct FfiConverterTypeSecureNote: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureNote {
        return
            try SecureNote(
                type: FfiConverterTypeSecureNoteType.read(from: &buf)
        )
    }

    public static func write(_ value: SecureNote, into buf: inout [UInt8]) {
        FfiConverterTypeSecureNoteType.write(value.type, into: &buf)
    }
}


public func FfiConverterTypeSecureNote_lift(_ buf: RustBuffer) throws -> SecureNote {
    return try FfiConverterTypeSecureNote.lift(buf)
}

public func FfiConverterTypeSecureNote_lower(_ value: SecureNote) -> RustBuffer {
    return FfiConverterTypeSecureNote.lower(value)
}


public struct SecureNoteView {
    public let type: SecureNoteType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        type: SecureNoteType) {
        self.type = type
    }
}


extension SecureNoteView: Equatable, Hashable {
    public static func ==(lhs: SecureNoteView, rhs: SecureNoteView) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
    }
}


public struct FfiConverterTypeSecureNoteView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureNoteView {
        return
            try SecureNoteView(
                type: FfiConverterTypeSecureNoteType.read(from: &buf)
        )
    }

    public static func write(_ value: SecureNoteView, into buf: inout [UInt8]) {
        FfiConverterTypeSecureNoteType.write(value.type, into: &buf)
    }
}


public func FfiConverterTypeSecureNoteView_lift(_ buf: RustBuffer) throws -> SecureNoteView {
    return try FfiConverterTypeSecureNoteView.lift(buf)
}

public func FfiConverterTypeSecureNoteView_lower(_ value: SecureNoteView) -> RustBuffer {
    return FfiConverterTypeSecureNoteView.lower(value)
}


public struct Send {
    public let id: Uuid?
    public let accessId: String?
    public let name: EncString
    public let notes: EncString?
    public let key: EncString
    public let password: String?
    public let type: SendType
    public let file: SendFile?
    public let text: SendText?
    public let maxAccessCount: UInt32?
    public let accessCount: UInt32
    public let disabled: Bool
    public let hideEmail: Bool
    public let revisionDate: DateTime
    public let deletionDate: DateTime
    public let expirationDate: DateTime?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: Uuid?, 
        accessId: String?, 
        name: EncString, 
        notes: EncString?, 
        key: EncString, 
        password: String?, 
        type: SendType, 
        file: SendFile?, 
        text: SendText?, 
        maxAccessCount: UInt32?, 
        accessCount: UInt32, 
        disabled: Bool, 
        hideEmail: Bool, 
        revisionDate: DateTime, 
        deletionDate: DateTime, 
        expirationDate: DateTime?) {
        self.id = id
        self.accessId = accessId
        self.name = name
        self.notes = notes
        self.key = key
        self.password = password
        self.type = type
        self.file = file
        self.text = text
        self.maxAccessCount = maxAccessCount
        self.accessCount = accessCount
        self.disabled = disabled
        self.hideEmail = hideEmail
        self.revisionDate = revisionDate
        self.deletionDate = deletionDate
        self.expirationDate = expirationDate
    }
}


extension Send: Equatable, Hashable {
    public static func ==(lhs: Send, rhs: Send) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.accessId != rhs.accessId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.notes != rhs.notes {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.file != rhs.file {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        if lhs.maxAccessCount != rhs.maxAccessCount {
            return false
        }
        if lhs.accessCount != rhs.accessCount {
            return false
        }
        if lhs.disabled != rhs.disabled {
            return false
        }
        if lhs.hideEmail != rhs.hideEmail {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        if lhs.deletionDate != rhs.deletionDate {
            return false
        }
        if lhs.expirationDate != rhs.expirationDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(accessId)
        hasher.combine(name)
        hasher.combine(notes)
        hasher.combine(key)
        hasher.combine(password)
        hasher.combine(type)
        hasher.combine(file)
        hasher.combine(text)
        hasher.combine(maxAccessCount)
        hasher.combine(accessCount)
        hasher.combine(disabled)
        hasher.combine(hideEmail)
        hasher.combine(revisionDate)
        hasher.combine(deletionDate)
        hasher.combine(expirationDate)
    }
}


public struct FfiConverterTypeSend: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Send {
        return
            try Send(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                accessId: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterTypeEncString.read(from: &buf), 
                notes: FfiConverterOptionTypeEncString.read(from: &buf), 
                key: FfiConverterTypeEncString.read(from: &buf), 
                password: FfiConverterOptionString.read(from: &buf), 
                type: FfiConverterTypeSendType.read(from: &buf), 
                file: FfiConverterOptionTypeSendFile.read(from: &buf), 
                text: FfiConverterOptionTypeSendText.read(from: &buf), 
                maxAccessCount: FfiConverterOptionUInt32.read(from: &buf), 
                accessCount: FfiConverterUInt32.read(from: &buf), 
                disabled: FfiConverterBool.read(from: &buf), 
                hideEmail: FfiConverterBool.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf), 
                deletionDate: FfiConverterTypeDateTime.read(from: &buf), 
                expirationDate: FfiConverterOptionTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: Send, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.accessId, into: &buf)
        FfiConverterTypeEncString.write(value.name, into: &buf)
        FfiConverterOptionTypeEncString.write(value.notes, into: &buf)
        FfiConverterTypeEncString.write(value.key, into: &buf)
        FfiConverterOptionString.write(value.password, into: &buf)
        FfiConverterTypeSendType.write(value.type, into: &buf)
        FfiConverterOptionTypeSendFile.write(value.file, into: &buf)
        FfiConverterOptionTypeSendText.write(value.text, into: &buf)
        FfiConverterOptionUInt32.write(value.maxAccessCount, into: &buf)
        FfiConverterUInt32.write(value.accessCount, into: &buf)
        FfiConverterBool.write(value.disabled, into: &buf)
        FfiConverterBool.write(value.hideEmail, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
        FfiConverterTypeDateTime.write(value.deletionDate, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.expirationDate, into: &buf)
    }
}


public func FfiConverterTypeSend_lift(_ buf: RustBuffer) throws -> Send {
    return try FfiConverterTypeSend.lift(buf)
}

public func FfiConverterTypeSend_lower(_ value: Send) -> RustBuffer {
    return FfiConverterTypeSend.lower(value)
}


public struct SendFile {
    public let id: String?
    public let fileName: EncString
    public let size: String?
    /**
     * Readable size, ex: "4.2 KB" or "1.43 GB"
     */
    public let sizeName: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: String?, 
        fileName: EncString, 
        size: String?, 
        /**
         * Readable size, ex: "4.2 KB" or "1.43 GB"
         */
        sizeName: String?) {
        self.id = id
        self.fileName = fileName
        self.size = size
        self.sizeName = sizeName
    }
}


extension SendFile: Equatable, Hashable {
    public static func ==(lhs: SendFile, rhs: SendFile) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.sizeName != rhs.sizeName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(fileName)
        hasher.combine(size)
        hasher.combine(sizeName)
    }
}


public struct FfiConverterTypeSendFile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFile {
        return
            try SendFile(
                id: FfiConverterOptionString.read(from: &buf), 
                fileName: FfiConverterTypeEncString.read(from: &buf), 
                size: FfiConverterOptionString.read(from: &buf), 
                sizeName: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SendFile, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.id, into: &buf)
        FfiConverterTypeEncString.write(value.fileName, into: &buf)
        FfiConverterOptionString.write(value.size, into: &buf)
        FfiConverterOptionString.write(value.sizeName, into: &buf)
    }
}


public func FfiConverterTypeSendFile_lift(_ buf: RustBuffer) throws -> SendFile {
    return try FfiConverterTypeSendFile.lift(buf)
}

public func FfiConverterTypeSendFile_lower(_ value: SendFile) -> RustBuffer {
    return FfiConverterTypeSendFile.lower(value)
}


public struct SendFileView {
    public let id: String?
    public let fileName: String
    public let size: String?
    /**
     * Readable size, ex: "4.2 KB" or "1.43 GB"
     */
    public let sizeName: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: String?, 
        fileName: String, 
        size: String?, 
        /**
         * Readable size, ex: "4.2 KB" or "1.43 GB"
         */
        sizeName: String?) {
        self.id = id
        self.fileName = fileName
        self.size = size
        self.sizeName = sizeName
    }
}


extension SendFileView: Equatable, Hashable {
    public static func ==(lhs: SendFileView, rhs: SendFileView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.sizeName != rhs.sizeName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(fileName)
        hasher.combine(size)
        hasher.combine(sizeName)
    }
}


public struct FfiConverterTypeSendFileView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFileView {
        return
            try SendFileView(
                id: FfiConverterOptionString.read(from: &buf), 
                fileName: FfiConverterString.read(from: &buf), 
                size: FfiConverterOptionString.read(from: &buf), 
                sizeName: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SendFileView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.id, into: &buf)
        FfiConverterString.write(value.fileName, into: &buf)
        FfiConverterOptionString.write(value.size, into: &buf)
        FfiConverterOptionString.write(value.sizeName, into: &buf)
    }
}


public func FfiConverterTypeSendFileView_lift(_ buf: RustBuffer) throws -> SendFileView {
    return try FfiConverterTypeSendFileView.lift(buf)
}

public func FfiConverterTypeSendFileView_lower(_ value: SendFileView) -> RustBuffer {
    return FfiConverterTypeSendFileView.lower(value)
}


public struct SendListView {
    public let id: Uuid?
    public let accessId: String?
    public let name: String
    public let type: SendType
    public let disabled: Bool
    public let revisionDate: DateTime
    public let deletionDate: DateTime
    public let expirationDate: DateTime?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: Uuid?, 
        accessId: String?, 
        name: String, 
        type: SendType, 
        disabled: Bool, 
        revisionDate: DateTime, 
        deletionDate: DateTime, 
        expirationDate: DateTime?) {
        self.id = id
        self.accessId = accessId
        self.name = name
        self.type = type
        self.disabled = disabled
        self.revisionDate = revisionDate
        self.deletionDate = deletionDate
        self.expirationDate = expirationDate
    }
}


extension SendListView: Equatable, Hashable {
    public static func ==(lhs: SendListView, rhs: SendListView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.accessId != rhs.accessId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.disabled != rhs.disabled {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        if lhs.deletionDate != rhs.deletionDate {
            return false
        }
        if lhs.expirationDate != rhs.expirationDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(accessId)
        hasher.combine(name)
        hasher.combine(type)
        hasher.combine(disabled)
        hasher.combine(revisionDate)
        hasher.combine(deletionDate)
        hasher.combine(expirationDate)
    }
}


public struct FfiConverterTypeSendListView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendListView {
        return
            try SendListView(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                accessId: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                type: FfiConverterTypeSendType.read(from: &buf), 
                disabled: FfiConverterBool.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf), 
                deletionDate: FfiConverterTypeDateTime.read(from: &buf), 
                expirationDate: FfiConverterOptionTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: SendListView, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.accessId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeSendType.write(value.type, into: &buf)
        FfiConverterBool.write(value.disabled, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
        FfiConverterTypeDateTime.write(value.deletionDate, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.expirationDate, into: &buf)
    }
}


public func FfiConverterTypeSendListView_lift(_ buf: RustBuffer) throws -> SendListView {
    return try FfiConverterTypeSendListView.lift(buf)
}

public func FfiConverterTypeSendListView_lower(_ value: SendListView) -> RustBuffer {
    return FfiConverterTypeSendListView.lower(value)
}


public struct SendText {
    public let text: EncString?
    public let hidden: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        text: EncString?, 
        hidden: Bool) {
        self.text = text
        self.hidden = hidden
    }
}


extension SendText: Equatable, Hashable {
    public static func ==(lhs: SendText, rhs: SendText) -> Bool {
        if lhs.text != rhs.text {
            return false
        }
        if lhs.hidden != rhs.hidden {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(text)
        hasher.combine(hidden)
    }
}


public struct FfiConverterTypeSendText: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendText {
        return
            try SendText(
                text: FfiConverterOptionTypeEncString.read(from: &buf), 
                hidden: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SendText, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.text, into: &buf)
        FfiConverterBool.write(value.hidden, into: &buf)
    }
}


public func FfiConverterTypeSendText_lift(_ buf: RustBuffer) throws -> SendText {
    return try FfiConverterTypeSendText.lift(buf)
}

public func FfiConverterTypeSendText_lower(_ value: SendText) -> RustBuffer {
    return FfiConverterTypeSendText.lower(value)
}


public struct SendTextView {
    public let text: String?
    public let hidden: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        text: String?, 
        hidden: Bool) {
        self.text = text
        self.hidden = hidden
    }
}


extension SendTextView: Equatable, Hashable {
    public static func ==(lhs: SendTextView, rhs: SendTextView) -> Bool {
        if lhs.text != rhs.text {
            return false
        }
        if lhs.hidden != rhs.hidden {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(text)
        hasher.combine(hidden)
    }
}


public struct FfiConverterTypeSendTextView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendTextView {
        return
            try SendTextView(
                text: FfiConverterOptionString.read(from: &buf), 
                hidden: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SendTextView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.text, into: &buf)
        FfiConverterBool.write(value.hidden, into: &buf)
    }
}


public func FfiConverterTypeSendTextView_lift(_ buf: RustBuffer) throws -> SendTextView {
    return try FfiConverterTypeSendTextView.lift(buf)
}

public func FfiConverterTypeSendTextView_lower(_ value: SendTextView) -> RustBuffer {
    return FfiConverterTypeSendTextView.lower(value)
}


public struct SendView {
    public let id: Uuid?
    public let accessId: String?
    public let name: String
    public let notes: String?
    /**
     * Base64 encoded key
     */
    public let key: String?
    /**
     * Replace or add a password to an existing send. The SDK will always return None when
     * decrypting a [Send]
     * TODO: We should revisit this, one variant is to have `[Create, Update]SendView` DTOs.
     */
    public let newPassword: String?
    /**
     * Denote if an existing send has a password. The SDK will ignore this value when creating or
     * updating sends.
     */
    public let hasPassword: Bool
    public let type: SendType
    public let file: SendFileView?
    public let text: SendTextView?
    public let maxAccessCount: UInt32?
    public let accessCount: UInt32
    public let disabled: Bool
    public let hideEmail: Bool
    public let revisionDate: DateTime
    public let deletionDate: DateTime
    public let expirationDate: DateTime?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: Uuid?, 
        accessId: String?, 
        name: String, 
        notes: String?, 
        /**
         * Base64 encoded key
         */
        key: String?, 
        /**
         * Replace or add a password to an existing send. The SDK will always return None when
         * decrypting a [Send]
         * TODO: We should revisit this, one variant is to have `[Create, Update]SendView` DTOs.
         */
        newPassword: String?, 
        /**
         * Denote if an existing send has a password. The SDK will ignore this value when creating or
         * updating sends.
         */
        hasPassword: Bool, 
        type: SendType, 
        file: SendFileView?, 
        text: SendTextView?, 
        maxAccessCount: UInt32?, 
        accessCount: UInt32, 
        disabled: Bool, 
        hideEmail: Bool, 
        revisionDate: DateTime, 
        deletionDate: DateTime, 
        expirationDate: DateTime?) {
        self.id = id
        self.accessId = accessId
        self.name = name
        self.notes = notes
        self.key = key
        self.newPassword = newPassword
        self.hasPassword = hasPassword
        self.type = type
        self.file = file
        self.text = text
        self.maxAccessCount = maxAccessCount
        self.accessCount = accessCount
        self.disabled = disabled
        self.hideEmail = hideEmail
        self.revisionDate = revisionDate
        self.deletionDate = deletionDate
        self.expirationDate = expirationDate
    }
}


extension SendView: Equatable, Hashable {
    public static func ==(lhs: SendView, rhs: SendView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.accessId != rhs.accessId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.notes != rhs.notes {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        if lhs.newPassword != rhs.newPassword {
            return false
        }
        if lhs.hasPassword != rhs.hasPassword {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.file != rhs.file {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        if lhs.maxAccessCount != rhs.maxAccessCount {
            return false
        }
        if lhs.accessCount != rhs.accessCount {
            return false
        }
        if lhs.disabled != rhs.disabled {
            return false
        }
        if lhs.hideEmail != rhs.hideEmail {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        if lhs.deletionDate != rhs.deletionDate {
            return false
        }
        if lhs.expirationDate != rhs.expirationDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(accessId)
        hasher.combine(name)
        hasher.combine(notes)
        hasher.combine(key)
        hasher.combine(newPassword)
        hasher.combine(hasPassword)
        hasher.combine(type)
        hasher.combine(file)
        hasher.combine(text)
        hasher.combine(maxAccessCount)
        hasher.combine(accessCount)
        hasher.combine(disabled)
        hasher.combine(hideEmail)
        hasher.combine(revisionDate)
        hasher.combine(deletionDate)
        hasher.combine(expirationDate)
    }
}


public struct FfiConverterTypeSendView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendView {
        return
            try SendView(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                accessId: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                notes: FfiConverterOptionString.read(from: &buf), 
                key: FfiConverterOptionString.read(from: &buf), 
                newPassword: FfiConverterOptionString.read(from: &buf), 
                hasPassword: FfiConverterBool.read(from: &buf), 
                type: FfiConverterTypeSendType.read(from: &buf), 
                file: FfiConverterOptionTypeSendFileView.read(from: &buf), 
                text: FfiConverterOptionTypeSendTextView.read(from: &buf), 
                maxAccessCount: FfiConverterOptionUInt32.read(from: &buf), 
                accessCount: FfiConverterUInt32.read(from: &buf), 
                disabled: FfiConverterBool.read(from: &buf), 
                hideEmail: FfiConverterBool.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf), 
                deletionDate: FfiConverterTypeDateTime.read(from: &buf), 
                expirationDate: FfiConverterOptionTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: SendView, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.accessId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.notes, into: &buf)
        FfiConverterOptionString.write(value.key, into: &buf)
        FfiConverterOptionString.write(value.newPassword, into: &buf)
        FfiConverterBool.write(value.hasPassword, into: &buf)
        FfiConverterTypeSendType.write(value.type, into: &buf)
        FfiConverterOptionTypeSendFileView.write(value.file, into: &buf)
        FfiConverterOptionTypeSendTextView.write(value.text, into: &buf)
        FfiConverterOptionUInt32.write(value.maxAccessCount, into: &buf)
        FfiConverterUInt32.write(value.accessCount, into: &buf)
        FfiConverterBool.write(value.disabled, into: &buf)
        FfiConverterBool.write(value.hideEmail, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
        FfiConverterTypeDateTime.write(value.deletionDate, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.expirationDate, into: &buf)
    }
}


public func FfiConverterTypeSendView_lift(_ buf: RustBuffer) throws -> SendView {
    return try FfiConverterTypeSendView.lift(buf)
}

public func FfiConverterTypeSendView_lower(_ value: SendView) -> RustBuffer {
    return FfiConverterTypeSendView.lower(value)
}


public struct TotpResponse {
    /**
     * Generated TOTP code
     */
    public let code: String
    /**
     * Time period
     */
    public let period: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Generated TOTP code
         */
        code: String, 
        /**
         * Time period
         */
        period: UInt32) {
        self.code = code
        self.period = period
    }
}


extension TotpResponse: Equatable, Hashable {
    public static func ==(lhs: TotpResponse, rhs: TotpResponse) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.period != rhs.period {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(period)
    }
}


public struct FfiConverterTypeTotpResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TotpResponse {
        return
            try TotpResponse(
                code: FfiConverterString.read(from: &buf), 
                period: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: TotpResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.code, into: &buf)
        FfiConverterUInt32.write(value.period, into: &buf)
    }
}


public func FfiConverterTypeTotpResponse_lift(_ buf: RustBuffer) throws -> TotpResponse {
    return try FfiConverterTypeTotpResponse.lift(buf)
}

public func FfiConverterTypeTotpResponse_lower(_ value: TotpResponse) -> RustBuffer {
    return FfiConverterTypeTotpResponse.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AppendType {
    
    /**
     * Generates a random string of 8 lowercase characters as part of your username
     */
    case random
    /**
     * Uses the websitename as part of your username
     */
    case websiteName(
        website: String
    )
}

public struct FfiConverterTypeAppendType: FfiConverterRustBuffer {
    typealias SwiftType = AppendType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppendType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .random
        
        case 2: return .websiteName(
            website: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AppendType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .random:
            writeInt(&buf, Int32(1))
        
        
        case let .websiteName(website):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(website, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAppendType_lift(_ buf: RustBuffer) throws -> AppendType {
    return try FfiConverterTypeAppendType.lift(buf)
}

public func FfiConverterTypeAppendType_lower(_ value: AppendType) -> RustBuffer {
    return FfiConverterTypeAppendType.lower(value)
}


extension AppendType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum CipherRepromptType {
    
    case none
    case password
}

public struct FfiConverterTypeCipherRepromptType: FfiConverterRustBuffer {
    typealias SwiftType = CipherRepromptType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherRepromptType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .password
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CipherRepromptType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case .password:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeCipherRepromptType_lift(_ buf: RustBuffer) throws -> CipherRepromptType {
    return try FfiConverterTypeCipherRepromptType.lift(buf)
}

public func FfiConverterTypeCipherRepromptType_lower(_ value: CipherRepromptType) -> RustBuffer {
    return FfiConverterTypeCipherRepromptType.lower(value)
}


extension CipherRepromptType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum CipherType {
    
    case login
    case secureNote
    case card
    case identity
}

public struct FfiConverterTypeCipherType: FfiConverterRustBuffer {
    typealias SwiftType = CipherType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .login
        
        case 2: return .secureNote
        
        case 3: return .card
        
        case 4: return .identity
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CipherType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .login:
            writeInt(&buf, Int32(1))
        
        
        case .secureNote:
            writeInt(&buf, Int32(2))
        
        
        case .card:
            writeInt(&buf, Int32(3))
        
        
        case .identity:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeCipherType_lift(_ buf: RustBuffer) throws -> CipherType {
    return try FfiConverterTypeCipherType.lift(buf)
}

public func FfiConverterTypeCipherType_lower(_ value: CipherType) -> RustBuffer {
    return FfiConverterTypeCipherType.lower(value)
}


extension CipherType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DeviceType {
    
    case android
    case iOs
    case chromeExtension
    case firefoxExtension
    case operaExtension
    case edgeExtension
    case windowsDesktop
    case macOsDesktop
    case linuxDesktop
    case chromeBrowser
    case firefoxBrowser
    case operaBrowser
    case edgeBrowser
    case ieBrowser
    case unknownBrowser
    case androidAmazon
    case uwp
    case safariBrowser
    case vivaldiBrowser
    case vivaldiExtension
    case safariExtension
    case sdk
}

public struct FfiConverterTypeDeviceType: FfiConverterRustBuffer {
    typealias SwiftType = DeviceType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .android
        
        case 2: return .iOs
        
        case 3: return .chromeExtension
        
        case 4: return .firefoxExtension
        
        case 5: return .operaExtension
        
        case 6: return .edgeExtension
        
        case 7: return .windowsDesktop
        
        case 8: return .macOsDesktop
        
        case 9: return .linuxDesktop
        
        case 10: return .chromeBrowser
        
        case 11: return .firefoxBrowser
        
        case 12: return .operaBrowser
        
        case 13: return .edgeBrowser
        
        case 14: return .ieBrowser
        
        case 15: return .unknownBrowser
        
        case 16: return .androidAmazon
        
        case 17: return .uwp
        
        case 18: return .safariBrowser
        
        case 19: return .vivaldiBrowser
        
        case 20: return .vivaldiExtension
        
        case 21: return .safariExtension
        
        case 22: return .sdk
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DeviceType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .android:
            writeInt(&buf, Int32(1))
        
        
        case .iOs:
            writeInt(&buf, Int32(2))
        
        
        case .chromeExtension:
            writeInt(&buf, Int32(3))
        
        
        case .firefoxExtension:
            writeInt(&buf, Int32(4))
        
        
        case .operaExtension:
            writeInt(&buf, Int32(5))
        
        
        case .edgeExtension:
            writeInt(&buf, Int32(6))
        
        
        case .windowsDesktop:
            writeInt(&buf, Int32(7))
        
        
        case .macOsDesktop:
            writeInt(&buf, Int32(8))
        
        
        case .linuxDesktop:
            writeInt(&buf, Int32(9))
        
        
        case .chromeBrowser:
            writeInt(&buf, Int32(10))
        
        
        case .firefoxBrowser:
            writeInt(&buf, Int32(11))
        
        
        case .operaBrowser:
            writeInt(&buf, Int32(12))
        
        
        case .edgeBrowser:
            writeInt(&buf, Int32(13))
        
        
        case .ieBrowser:
            writeInt(&buf, Int32(14))
        
        
        case .unknownBrowser:
            writeInt(&buf, Int32(15))
        
        
        case .androidAmazon:
            writeInt(&buf, Int32(16))
        
        
        case .uwp:
            writeInt(&buf, Int32(17))
        
        
        case .safariBrowser:
            writeInt(&buf, Int32(18))
        
        
        case .vivaldiBrowser:
            writeInt(&buf, Int32(19))
        
        
        case .vivaldiExtension:
            writeInt(&buf, Int32(20))
        
        
        case .safariExtension:
            writeInt(&buf, Int32(21))
        
        
        case .sdk:
            writeInt(&buf, Int32(22))
        
        }
    }
}


public func FfiConverterTypeDeviceType_lift(_ buf: RustBuffer) throws -> DeviceType {
    return try FfiConverterTypeDeviceType.lift(buf)
}

public func FfiConverterTypeDeviceType_lower(_ value: DeviceType) -> RustBuffer {
    return FfiConverterTypeDeviceType.lower(value)
}


extension DeviceType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ExportFormat {
    
    case csv
    case json
    case accountEncryptedJson
    case encryptedJson(
        password: String
    )
}

public struct FfiConverterTypeExportFormat: FfiConverterRustBuffer {
    typealias SwiftType = ExportFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExportFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .csv
        
        case 2: return .json
        
        case 3: return .accountEncryptedJson
        
        case 4: return .encryptedJson(
            password: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExportFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .csv:
            writeInt(&buf, Int32(1))
        
        
        case .json:
            writeInt(&buf, Int32(2))
        
        
        case .accountEncryptedJson:
            writeInt(&buf, Int32(3))
        
        
        case let .encryptedJson(password):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(password, into: &buf)
            
        }
    }
}


public func FfiConverterTypeExportFormat_lift(_ buf: RustBuffer) throws -> ExportFormat {
    return try FfiConverterTypeExportFormat.lift(buf)
}

public func FfiConverterTypeExportFormat_lower(_ value: ExportFormat) -> RustBuffer {
    return FfiConverterTypeExportFormat.lower(value)
}


extension ExportFormat: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FieldType {
    
    case text
    case hidden
    case boolean
    case linked
}

public struct FfiConverterTypeFieldType: FfiConverterRustBuffer {
    typealias SwiftType = FieldType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FieldType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text
        
        case 2: return .hidden
        
        case 3: return .boolean
        
        case 4: return .linked
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FieldType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .text:
            writeInt(&buf, Int32(1))
        
        
        case .hidden:
            writeInt(&buf, Int32(2))
        
        
        case .boolean:
            writeInt(&buf, Int32(3))
        
        
        case .linked:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeFieldType_lift(_ buf: RustBuffer) throws -> FieldType {
    return try FfiConverterTypeFieldType.lift(buf)
}

public func FfiConverterTypeFieldType_lower(_ value: FieldType) -> RustBuffer {
    return FfiConverterTypeFieldType.lower(value)
}


extension FieldType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Configures the email forwarding service to use.
 * For instructions on how to configure each service, see the documentation:
 * <https://bitwarden.com/help/generator/#username-types>
 */
public enum ForwarderServiceType {
    
    /**
     * Previously known as "AnonAddy"
     */
    case addyIo(
        apiToken: String, 
        domain: String, 
        baseUrl: String
    )
    case duckDuckGo(
        token: String
    )
    case firefox(
        apiToken: String
    )
    case fastmail(
        apiToken: String
    )
    case forwardEmail(
        apiToken: String, 
        domain: String
    )
    case simpleLogin(
        apiKey: String
    )
}

public struct FfiConverterTypeForwarderServiceType: FfiConverterRustBuffer {
    typealias SwiftType = ForwarderServiceType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ForwarderServiceType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .addyIo(
            apiToken: try FfiConverterString.read(from: &buf), 
            domain: try FfiConverterString.read(from: &buf), 
            baseUrl: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .duckDuckGo(
            token: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .firefox(
            apiToken: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .fastmail(
            apiToken: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .forwardEmail(
            apiToken: try FfiConverterString.read(from: &buf), 
            domain: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .simpleLogin(
            apiKey: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ForwarderServiceType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .addyIo(apiToken,domain,baseUrl):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(apiToken, into: &buf)
            FfiConverterString.write(domain, into: &buf)
            FfiConverterString.write(baseUrl, into: &buf)
            
        
        case let .duckDuckGo(token):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(token, into: &buf)
            
        
        case let .firefox(apiToken):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(apiToken, into: &buf)
            
        
        case let .fastmail(apiToken):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(apiToken, into: &buf)
            
        
        case let .forwardEmail(apiToken,domain):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(apiToken, into: &buf)
            FfiConverterString.write(domain, into: &buf)
            
        
        case let .simpleLogin(apiKey):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(apiKey, into: &buf)
            
        }
    }
}


public func FfiConverterTypeForwarderServiceType_lift(_ buf: RustBuffer) throws -> ForwarderServiceType {
    return try FfiConverterTypeForwarderServiceType.lift(buf)
}

public func FfiConverterTypeForwarderServiceType_lower(_ value: ForwarderServiceType) -> RustBuffer {
    return FfiConverterTypeForwarderServiceType.lower(value)
}


extension ForwarderServiceType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum InitUserCryptoMethod {
    
    case password(
        /**
         * The user's master password
         */
        password: String, 
        /**
         * The user's encrypted symmetric crypto key
         */
        userKey: String
    )
    case decryptedKey(
        /**
         * The user's decrypted encryption key, obtained using `get_user_encryption_key`
         */
        decryptedUserKey: String
    )
    case pin(
        /**
         * The user's PIN
         */
        pin: String, 
        /**
         * The user's symmetric crypto key, encrypted with the PIN. Use `derive_pin_key` to obtain this.
         */
        pinProtectedUserKey: EncString
    )
}

public struct FfiConverterTypeInitUserCryptoMethod: FfiConverterRustBuffer {
    typealias SwiftType = InitUserCryptoMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitUserCryptoMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .password(
            password: try FfiConverterString.read(from: &buf), 
            userKey: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .decryptedKey(
            decryptedUserKey: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .pin(
            pin: try FfiConverterString.read(from: &buf), 
            pinProtectedUserKey: try FfiConverterTypeEncString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InitUserCryptoMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .password(password,userKey):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(password, into: &buf)
            FfiConverterString.write(userKey, into: &buf)
            
        
        case let .decryptedKey(decryptedUserKey):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(decryptedUserKey, into: &buf)
            
        
        case let .pin(pin,pinProtectedUserKey):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(pin, into: &buf)
            FfiConverterTypeEncString.write(pinProtectedUserKey, into: &buf)
            
        }
    }
}


public func FfiConverterTypeInitUserCryptoMethod_lift(_ buf: RustBuffer) throws -> InitUserCryptoMethod {
    return try FfiConverterTypeInitUserCryptoMethod.lift(buf)
}

public func FfiConverterTypeInitUserCryptoMethod_lower(_ value: InitUserCryptoMethod) -> RustBuffer {
    return FfiConverterTypeInitUserCryptoMethod.lower(value)
}


extension InitUserCryptoMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SecureNoteType {
    
    case generic
}

public struct FfiConverterTypeSecureNoteType: FfiConverterRustBuffer {
    typealias SwiftType = SecureNoteType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureNoteType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .generic
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecureNoteType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .generic:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeSecureNoteType_lift(_ buf: RustBuffer) throws -> SecureNoteType {
    return try FfiConverterTypeSecureNoteType.lift(buf)
}

public func FfiConverterTypeSecureNoteType_lower(_ value: SecureNoteType) -> RustBuffer {
    return FfiConverterTypeSecureNoteType.lower(value)
}


extension SecureNoteType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SendType {
    
    case text
    case file
}

public struct FfiConverterTypeSendType: FfiConverterRustBuffer {
    typealias SwiftType = SendType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text
        
        case 2: return .file
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .text:
            writeInt(&buf, Int32(1))
        
        
        case .file:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeSendType_lift(_ buf: RustBuffer) throws -> SendType {
    return try FfiConverterTypeSendType.lift(buf)
}

public func FfiConverterTypeSendType_lower(_ value: SendType) -> RustBuffer {
    return FfiConverterTypeSendType.lower(value)
}


extension SendType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum UriMatchType {
    
    case domain
    case host
    case startsWith
    case exact
    case regularExpression
    case never
}

public struct FfiConverterTypeUriMatchType: FfiConverterRustBuffer {
    typealias SwiftType = UriMatchType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UriMatchType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .domain
        
        case 2: return .host
        
        case 3: return .startsWith
        
        case 4: return .exact
        
        case 5: return .regularExpression
        
        case 6: return .never
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UriMatchType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .domain:
            writeInt(&buf, Int32(1))
        
        
        case .host:
            writeInt(&buf, Int32(2))
        
        
        case .startsWith:
            writeInt(&buf, Int32(3))
        
        
        case .exact:
            writeInt(&buf, Int32(4))
        
        
        case .regularExpression:
            writeInt(&buf, Int32(5))
        
        
        case .never:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeUriMatchType_lift(_ buf: RustBuffer) throws -> UriMatchType {
    return try FfiConverterTypeUriMatchType.lift(buf)
}

public func FfiConverterTypeUriMatchType_lower(_ value: UriMatchType) -> RustBuffer {
    return FfiConverterTypeUriMatchType.lower(value)
}


extension UriMatchType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum UsernameGeneratorRequest {
    
    /**
     * Generates a single word username
     */
    case word(
        /**
         * Capitalize the first letter of the word
         */
        capitalize: Bool, 
        /**
         * Include a 4 digit number at the end of the word
         */
        includeNumber: Bool
    )
    /**
     * Generates an email using your provider's subaddressing capabilities.
     * Note that not all providers support this functionality.
     * This will generate an address of the format `youremail+generated@domain.tld`
     */
    case subaddress(
        /**
         * The type of subaddress to add to the base email
         */
        type: AppendType, 
        /**
         * The full email address to use as the base for the subaddress
         */
        email: String
    )
    case catchall(
        /**
         * The type of username to use with the catchall email domain
         */
        type: AppendType, 
        /**
         * The domain to use for the catchall email address
         */
        domain: String
    )
    case forwarded(
        /**
         * The email forwarding service to use, see [ForwarderServiceType]
         * for instructions on how to configure each
         */
        service: ForwarderServiceType, 
        /**
         * The website for which the email address is being generated
         * This is not used in all services, and is only used for display purposes
         */
        website: String?
    )
}

public struct FfiConverterTypeUsernameGeneratorRequest: FfiConverterRustBuffer {
    typealias SwiftType = UsernameGeneratorRequest

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UsernameGeneratorRequest {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .word(
            capitalize: try FfiConverterBool.read(from: &buf), 
            includeNumber: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .subaddress(
            type: try FfiConverterTypeAppendType.read(from: &buf), 
            email: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .catchall(
            type: try FfiConverterTypeAppendType.read(from: &buf), 
            domain: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .forwarded(
            service: try FfiConverterTypeForwarderServiceType.read(from: &buf), 
            website: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UsernameGeneratorRequest, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .word(capitalize,includeNumber):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(capitalize, into: &buf)
            FfiConverterBool.write(includeNumber, into: &buf)
            
        
        case let .subaddress(type,email):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAppendType.write(type, into: &buf)
            FfiConverterString.write(email, into: &buf)
            
        
        case let .catchall(type,domain):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAppendType.write(type, into: &buf)
            FfiConverterString.write(domain, into: &buf)
            
        
        case let .forwarded(service,website):
            writeInt(&buf, Int32(4))
            FfiConverterTypeForwarderServiceType.write(service, into: &buf)
            FfiConverterOptionString.write(website, into: &buf)
            
        }
    }
}


public func FfiConverterTypeUsernameGeneratorRequest_lift(_ buf: RustBuffer) throws -> UsernameGeneratorRequest {
    return try FfiConverterTypeUsernameGeneratorRequest.lift(buf)
}

public func FfiConverterTypeUsernameGeneratorRequest_lower(_ value: UsernameGeneratorRequest) -> RustBuffer {
    return FfiConverterTypeUsernameGeneratorRequest.lower(value)
}


extension UsernameGeneratorRequest: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCard: FfiConverterRustBuffer {
    typealias SwiftType = Card?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCard.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCard.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCardView: FfiConverterRustBuffer {
    typealias SwiftType = CardView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCardView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCardView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIdentity: FfiConverterRustBuffer {
    typealias SwiftType = Identity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIdentity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIdentity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIdentityView: FfiConverterRustBuffer {
    typealias SwiftType = IdentityView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIdentityView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIdentityView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLocalData: FfiConverterRustBuffer {
    typealias SwiftType = LocalData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLocalData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLocalData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLocalDataView: FfiConverterRustBuffer {
    typealias SwiftType = LocalDataView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLocalDataView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLocalDataView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLogin: FfiConverterRustBuffer {
    typealias SwiftType = Login?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLogin.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLogin.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLoginView: FfiConverterRustBuffer {
    typealias SwiftType = LoginView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLoginView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLoginView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSecureNote: FfiConverterRustBuffer {
    typealias SwiftType = SecureNote?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSecureNote.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSecureNote.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSecureNoteView: FfiConverterRustBuffer {
    typealias SwiftType = SecureNoteView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSecureNoteView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSecureNoteView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSendFile: FfiConverterRustBuffer {
    typealias SwiftType = SendFile?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendFile.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendFile.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSendFileView: FfiConverterRustBuffer {
    typealias SwiftType = SendFileView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendFileView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendFileView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSendText: FfiConverterRustBuffer {
    typealias SwiftType = SendText?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendText.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendText.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSendTextView: FfiConverterRustBuffer {
    typealias SwiftType = SendTextView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendTextView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendTextView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUriMatchType: FfiConverterRustBuffer {
    typealias SwiftType = UriMatchType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUriMatchType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUriMatchType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeAttachment: FfiConverterRustBuffer {
    typealias SwiftType = [Attachment]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAttachment.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAttachment.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeAttachmentView: FfiConverterRustBuffer {
    typealias SwiftType = [AttachmentView]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAttachmentView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAttachmentView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeField: FfiConverterRustBuffer {
    typealias SwiftType = [Field]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeField.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeField.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeFieldView: FfiConverterRustBuffer {
    typealias SwiftType = [FieldView]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFieldView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFieldView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeLoginUri: FfiConverterRustBuffer {
    typealias SwiftType = [LoginUri]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeLoginUri.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeLoginUri.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeLoginUriView: FfiConverterRustBuffer {
    typealias SwiftType = [LoginUriView]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeLoginUriView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeLoginUriView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypePasswordHistory: FfiConverterRustBuffer {
    typealias SwiftType = [PasswordHistory]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePasswordHistory.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePasswordHistory.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypePasswordHistoryView: FfiConverterRustBuffer {
    typealias SwiftType = [PasswordHistoryView]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePasswordHistoryView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePasswordHistoryView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEncString: FfiConverterRustBuffer {
    typealias SwiftType = EncString?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEncString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEncString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDateTime: FfiConverterRustBuffer {
    typealias SwiftType = DateTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDateTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDateTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLinkedIdType: FfiConverterRustBuffer {
    typealias SwiftType = LinkedIdType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLinkedIdType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLinkedIdType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUuid: FfiConverterRustBuffer {
    typealias SwiftType = Uuid?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUuid.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceTypeAttachment: FfiConverterRustBuffer {
    typealias SwiftType = [Attachment]

    public static func write(_ value: [Attachment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAttachment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Attachment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Attachment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAttachment.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAttachmentView: FfiConverterRustBuffer {
    typealias SwiftType = [AttachmentView]

    public static func write(_ value: [AttachmentView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAttachmentView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AttachmentView] {
        let len: Int32 = try readInt(&buf)
        var seq = [AttachmentView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAttachmentView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeField: FfiConverterRustBuffer {
    typealias SwiftType = [Field]

    public static func write(_ value: [Field], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Field] {
        let len: Int32 = try readInt(&buf)
        var seq = [Field]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeField.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFieldView: FfiConverterRustBuffer {
    typealias SwiftType = [FieldView]

    public static func write(_ value: [FieldView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFieldView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FieldView] {
        let len: Int32 = try readInt(&buf)
        var seq = [FieldView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFieldView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLoginUri: FfiConverterRustBuffer {
    typealias SwiftType = [LoginUri]

    public static func write(_ value: [LoginUri], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLoginUri.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LoginUri] {
        let len: Int32 = try readInt(&buf)
        var seq = [LoginUri]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLoginUri.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLoginUriView: FfiConverterRustBuffer {
    typealias SwiftType = [LoginUriView]

    public static func write(_ value: [LoginUriView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLoginUriView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LoginUriView] {
        let len: Int32 = try readInt(&buf)
        var seq = [LoginUriView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLoginUriView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePasswordHistory: FfiConverterRustBuffer {
    typealias SwiftType = [PasswordHistory]

    public static func write(_ value: [PasswordHistory], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePasswordHistory.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PasswordHistory] {
        let len: Int32 = try readInt(&buf)
        var seq = [PasswordHistory]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePasswordHistory.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePasswordHistoryView: FfiConverterRustBuffer {
    typealias SwiftType = [PasswordHistoryView]

    public static func write(_ value: [PasswordHistoryView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePasswordHistoryView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PasswordHistoryView] {
        let len: Int32 = try readInt(&buf)
        var seq = [PasswordHistoryView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePasswordHistoryView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUuid: FfiConverterRustBuffer {
    typealias SwiftType = [Uuid]

    public static func write(_ value: [Uuid], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUuid.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Uuid] {
        let len: Int32 = try readInt(&buf)
        var seq = [Uuid]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUuid.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryTypeUuidTypeAsymmetricEncString: FfiConverterRustBuffer {
    public static func write(_ value: [Uuid: AsymmetricEncString], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeUuid.write(key, into: &buf)
            FfiConverterTypeAsymmetricEncString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Uuid: AsymmetricEncString] {
        let len: Int32 = try readInt(&buf)
        var dict = [Uuid: AsymmetricEncString]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeUuid.read(from: &buf)
            let value = try FfiConverterTypeAsymmetricEncString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}








/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias AsymmetricEncString = String
public struct FfiConverterTypeAsymmetricEncString: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AsymmetricEncString {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: AsymmetricEncString, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> AsymmetricEncString {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: AsymmetricEncString) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeAsymmetricEncString_lift(_ value: RustBuffer) throws -> AsymmetricEncString {
    return try FfiConverterTypeAsymmetricEncString.lift(value)
}

public func FfiConverterTypeAsymmetricEncString_lower(_ value: AsymmetricEncString) -> RustBuffer {
    return FfiConverterTypeAsymmetricEncString.lower(value)
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DateTime = Date
public struct FfiConverterTypeDateTime: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DateTime {
        return try FfiConverterTimestamp.read(from: &buf)
    }

    public static func write(_ value: DateTime, into buf: inout [UInt8]) {
        return FfiConverterTimestamp.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DateTime {
        return try FfiConverterTimestamp.lift(value)
    }

    public static func lower(_ value: DateTime) -> RustBuffer {
        return FfiConverterTimestamp.lower(value)
    }
}


public func FfiConverterTypeDateTime_lift(_ value: RustBuffer) throws -> DateTime {
    return try FfiConverterTypeDateTime.lift(value)
}

public func FfiConverterTypeDateTime_lower(_ value: DateTime) -> RustBuffer {
    return FfiConverterTypeDateTime.lower(value)
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias LinkedIdType = UInt32
public struct FfiConverterTypeLinkedIdType: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LinkedIdType {
        return try FfiConverterUInt32.read(from: &buf)
    }

    public static func write(_ value: LinkedIdType, into buf: inout [UInt8]) {
        return FfiConverterUInt32.write(value, into: &buf)
    }

    public static func lift(_ value: UInt32) throws -> LinkedIdType {
        return try FfiConverterUInt32.lift(value)
    }

    public static func lower(_ value: LinkedIdType) -> UInt32 {
        return FfiConverterUInt32.lower(value)
    }
}


public func FfiConverterTypeLinkedIdType_lift(_ value: UInt32) throws -> LinkedIdType {
    return try FfiConverterTypeLinkedIdType.lift(value)
}

public func FfiConverterTypeLinkedIdType_lower(_ value: LinkedIdType) -> UInt32 {
    return FfiConverterTypeLinkedIdType.lower(value)
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Uuid = String
public struct FfiConverterTypeUuid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Uuid, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Uuid {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Uuid) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeUuid_lift(_ value: RustBuffer) throws -> Uuid {
    return try FfiConverterTypeUuid.lift(value)
}

public func FfiConverterTypeUuid_lower(_ value: Uuid) -> RustBuffer {
    return FfiConverterTypeUuid.lower(value)
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_bitwarden_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}