// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(BitwardenCoreFFI)
import BitwardenCoreFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_bitwarden_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_bitwarden_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Date {
        let seconds: Int64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        if seconds >= 0 {
            let delta = Double(seconds) + (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        } else {
            let delta = Double(seconds) - (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        }
    }

    public static func write(_ value: Date, into buf: inout [UInt8]) {
        var delta = value.timeIntervalSince1970
        var sign: Int64 = 1
        if delta < 0 {
            // The nanoseconds portion of the epoch offset must always be
            // positive, to simplify the calculation we will use the absolute
            // value of the offset.
            sign = -1
            delta = -delta
        }
        if delta.rounded(.down) > Double(Int64.max) {
            fatalError("Timestamp overflow, exceeds max bounds supported by Uniffi")
        }
        let seconds = Int64(delta)
        let nanoseconds = UInt32((delta - Double(seconds)) * 1.0e9)
        writeInt(&buf, sign * seconds)
        writeInt(&buf, nanoseconds)
    }
}


public struct Attachment {
    public var `id`: String?
    public var `url`: String?
    public var `size`: String?
    public var `sizeName`: String?
    public var `fileName`: EncString?
    public var `key`: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String?, `url`: String?, `size`: String?, `sizeName`: String?, `fileName`: EncString?, `key`: EncString?) {
        self.`id` = `id`
        self.`url` = `url`
        self.`size` = `size`
        self.`sizeName` = `sizeName`
        self.`fileName` = `fileName`
        self.`key` = `key`
    }
}


extension Attachment: Equatable, Hashable {
    public static func ==(lhs: Attachment, rhs: Attachment) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`url` != rhs.`url` {
            return false
        }
        if lhs.`size` != rhs.`size` {
            return false
        }
        if lhs.`sizeName` != rhs.`sizeName` {
            return false
        }
        if lhs.`fileName` != rhs.`fileName` {
            return false
        }
        if lhs.`key` != rhs.`key` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`url`)
        hasher.combine(`size`)
        hasher.combine(`sizeName`)
        hasher.combine(`fileName`)
        hasher.combine(`key`)
    }
}


public struct FfiConverterTypeAttachment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Attachment {
        return try Attachment(
            `id`: FfiConverterOptionString.read(from: &buf), 
            `url`: FfiConverterOptionString.read(from: &buf), 
            `size`: FfiConverterOptionString.read(from: &buf), 
            `sizeName`: FfiConverterOptionString.read(from: &buf), 
            `fileName`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `key`: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: Attachment, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`id`, into: &buf)
        FfiConverterOptionString.write(value.`url`, into: &buf)
        FfiConverterOptionString.write(value.`size`, into: &buf)
        FfiConverterOptionString.write(value.`sizeName`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`fileName`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`key`, into: &buf)
    }
}


public func FfiConverterTypeAttachment_lift(_ buf: RustBuffer) throws -> Attachment {
    return try FfiConverterTypeAttachment.lift(buf)
}

public func FfiConverterTypeAttachment_lower(_ value: Attachment) -> RustBuffer {
    return FfiConverterTypeAttachment.lower(value)
}


public struct AttachmentView {
    public var `id`: String?
    public var `url`: String?
    public var `size`: String?
    public var `sizeName`: String?
    public var `fileName`: String?
    public var `key`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String?, `url`: String?, `size`: String?, `sizeName`: String?, `fileName`: String?, `key`: String?) {
        self.`id` = `id`
        self.`url` = `url`
        self.`size` = `size`
        self.`sizeName` = `sizeName`
        self.`fileName` = `fileName`
        self.`key` = `key`
    }
}


extension AttachmentView: Equatable, Hashable {
    public static func ==(lhs: AttachmentView, rhs: AttachmentView) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`url` != rhs.`url` {
            return false
        }
        if lhs.`size` != rhs.`size` {
            return false
        }
        if lhs.`sizeName` != rhs.`sizeName` {
            return false
        }
        if lhs.`fileName` != rhs.`fileName` {
            return false
        }
        if lhs.`key` != rhs.`key` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`url`)
        hasher.combine(`size`)
        hasher.combine(`sizeName`)
        hasher.combine(`fileName`)
        hasher.combine(`key`)
    }
}


public struct FfiConverterTypeAttachmentView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentView {
        return try AttachmentView(
            `id`: FfiConverterOptionString.read(from: &buf), 
            `url`: FfiConverterOptionString.read(from: &buf), 
            `size`: FfiConverterOptionString.read(from: &buf), 
            `sizeName`: FfiConverterOptionString.read(from: &buf), 
            `fileName`: FfiConverterOptionString.read(from: &buf), 
            `key`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: AttachmentView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`id`, into: &buf)
        FfiConverterOptionString.write(value.`url`, into: &buf)
        FfiConverterOptionString.write(value.`size`, into: &buf)
        FfiConverterOptionString.write(value.`sizeName`, into: &buf)
        FfiConverterOptionString.write(value.`fileName`, into: &buf)
        FfiConverterOptionString.write(value.`key`, into: &buf)
    }
}


public func FfiConverterTypeAttachmentView_lift(_ buf: RustBuffer) throws -> AttachmentView {
    return try FfiConverterTypeAttachmentView.lift(buf)
}

public func FfiConverterTypeAttachmentView_lower(_ value: AttachmentView) -> RustBuffer {
    return FfiConverterTypeAttachmentView.lower(value)
}


public struct Card {
    public var `cardholderName`: EncString?
    public var `expMonth`: EncString?
    public var `expYear`: EncString?
    public var `code`: EncString?
    public var `brand`: EncString?
    public var `number`: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`cardholderName`: EncString?, `expMonth`: EncString?, `expYear`: EncString?, `code`: EncString?, `brand`: EncString?, `number`: EncString?) {
        self.`cardholderName` = `cardholderName`
        self.`expMonth` = `expMonth`
        self.`expYear` = `expYear`
        self.`code` = `code`
        self.`brand` = `brand`
        self.`number` = `number`
    }
}


extension Card: Equatable, Hashable {
    public static func ==(lhs: Card, rhs: Card) -> Bool {
        if lhs.`cardholderName` != rhs.`cardholderName` {
            return false
        }
        if lhs.`expMonth` != rhs.`expMonth` {
            return false
        }
        if lhs.`expYear` != rhs.`expYear` {
            return false
        }
        if lhs.`code` != rhs.`code` {
            return false
        }
        if lhs.`brand` != rhs.`brand` {
            return false
        }
        if lhs.`number` != rhs.`number` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`cardholderName`)
        hasher.combine(`expMonth`)
        hasher.combine(`expYear`)
        hasher.combine(`code`)
        hasher.combine(`brand`)
        hasher.combine(`number`)
    }
}


public struct FfiConverterTypeCard: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Card {
        return try Card(
            `cardholderName`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `expMonth`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `expYear`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `code`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `brand`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `number`: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: Card, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.`cardholderName`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`expMonth`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`expYear`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`code`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`brand`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`number`, into: &buf)
    }
}


public func FfiConverterTypeCard_lift(_ buf: RustBuffer) throws -> Card {
    return try FfiConverterTypeCard.lift(buf)
}

public func FfiConverterTypeCard_lower(_ value: Card) -> RustBuffer {
    return FfiConverterTypeCard.lower(value)
}


public struct CardView {
    public var `cardholderName`: String?
    public var `expMonth`: String?
    public var `expYear`: String?
    public var `code`: String?
    public var `brand`: String?
    public var `number`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`cardholderName`: String?, `expMonth`: String?, `expYear`: String?, `code`: String?, `brand`: String?, `number`: String?) {
        self.`cardholderName` = `cardholderName`
        self.`expMonth` = `expMonth`
        self.`expYear` = `expYear`
        self.`code` = `code`
        self.`brand` = `brand`
        self.`number` = `number`
    }
}


extension CardView: Equatable, Hashable {
    public static func ==(lhs: CardView, rhs: CardView) -> Bool {
        if lhs.`cardholderName` != rhs.`cardholderName` {
            return false
        }
        if lhs.`expMonth` != rhs.`expMonth` {
            return false
        }
        if lhs.`expYear` != rhs.`expYear` {
            return false
        }
        if lhs.`code` != rhs.`code` {
            return false
        }
        if lhs.`brand` != rhs.`brand` {
            return false
        }
        if lhs.`number` != rhs.`number` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`cardholderName`)
        hasher.combine(`expMonth`)
        hasher.combine(`expYear`)
        hasher.combine(`code`)
        hasher.combine(`brand`)
        hasher.combine(`number`)
    }
}


public struct FfiConverterTypeCardView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CardView {
        return try CardView(
            `cardholderName`: FfiConverterOptionString.read(from: &buf), 
            `expMonth`: FfiConverterOptionString.read(from: &buf), 
            `expYear`: FfiConverterOptionString.read(from: &buf), 
            `code`: FfiConverterOptionString.read(from: &buf), 
            `brand`: FfiConverterOptionString.read(from: &buf), 
            `number`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: CardView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`cardholderName`, into: &buf)
        FfiConverterOptionString.write(value.`expMonth`, into: &buf)
        FfiConverterOptionString.write(value.`expYear`, into: &buf)
        FfiConverterOptionString.write(value.`code`, into: &buf)
        FfiConverterOptionString.write(value.`brand`, into: &buf)
        FfiConverterOptionString.write(value.`number`, into: &buf)
    }
}


public func FfiConverterTypeCardView_lift(_ buf: RustBuffer) throws -> CardView {
    return try FfiConverterTypeCardView.lift(buf)
}

public func FfiConverterTypeCardView_lower(_ value: CardView) -> RustBuffer {
    return FfiConverterTypeCardView.lower(value)
}


public struct Cipher {
    public var `id`: Uuid?
    public var `organizationId`: Uuid?
    public var `folderId`: Uuid?
    public var `collectionIds`: [Uuid]
    public var `name`: EncString
    public var `notes`: EncString
    public var `type`: CipherType
    public var `login`: Login?
    public var `identity`: Identity?
    public var `card`: Card?
    public var `secureNote`: SecureNote?
    public var `favorite`: Bool
    public var `reprompt`: CipherRepromptType
    public var `organizationUseTotp`: Bool
    public var `edit`: Bool
    public var `viewPassword`: Bool
    public var `localData`: LocalData?
    public var `attachments`: [Attachment]
    public var `fields`: [Field]
    public var `passwordHistory`: [PasswordHistory]
    public var `creationDate`: DateTime
    public var `deletedDate`: DateTime?
    public var `revisionDate`: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: Uuid?, `organizationId`: Uuid?, `folderId`: Uuid?, `collectionIds`: [Uuid], `name`: EncString, `notes`: EncString, `type`: CipherType, `login`: Login?, `identity`: Identity?, `card`: Card?, `secureNote`: SecureNote?, `favorite`: Bool, `reprompt`: CipherRepromptType, `organizationUseTotp`: Bool, `edit`: Bool, `viewPassword`: Bool, `localData`: LocalData?, `attachments`: [Attachment], `fields`: [Field], `passwordHistory`: [PasswordHistory], `creationDate`: DateTime, `deletedDate`: DateTime?, `revisionDate`: DateTime) {
        self.`id` = `id`
        self.`organizationId` = `organizationId`
        self.`folderId` = `folderId`
        self.`collectionIds` = `collectionIds`
        self.`name` = `name`
        self.`notes` = `notes`
        self.`type` = `type`
        self.`login` = `login`
        self.`identity` = `identity`
        self.`card` = `card`
        self.`secureNote` = `secureNote`
        self.`favorite` = `favorite`
        self.`reprompt` = `reprompt`
        self.`organizationUseTotp` = `organizationUseTotp`
        self.`edit` = `edit`
        self.`viewPassword` = `viewPassword`
        self.`localData` = `localData`
        self.`attachments` = `attachments`
        self.`fields` = `fields`
        self.`passwordHistory` = `passwordHistory`
        self.`creationDate` = `creationDate`
        self.`deletedDate` = `deletedDate`
        self.`revisionDate` = `revisionDate`
    }
}


extension Cipher: Equatable, Hashable {
    public static func ==(lhs: Cipher, rhs: Cipher) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`organizationId` != rhs.`organizationId` {
            return false
        }
        if lhs.`folderId` != rhs.`folderId` {
            return false
        }
        if lhs.`collectionIds` != rhs.`collectionIds` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`notes` != rhs.`notes` {
            return false
        }
        if lhs.`type` != rhs.`type` {
            return false
        }
        if lhs.`login` != rhs.`login` {
            return false
        }
        if lhs.`identity` != rhs.`identity` {
            return false
        }
        if lhs.`card` != rhs.`card` {
            return false
        }
        if lhs.`secureNote` != rhs.`secureNote` {
            return false
        }
        if lhs.`favorite` != rhs.`favorite` {
            return false
        }
        if lhs.`reprompt` != rhs.`reprompt` {
            return false
        }
        if lhs.`organizationUseTotp` != rhs.`organizationUseTotp` {
            return false
        }
        if lhs.`edit` != rhs.`edit` {
            return false
        }
        if lhs.`viewPassword` != rhs.`viewPassword` {
            return false
        }
        if lhs.`localData` != rhs.`localData` {
            return false
        }
        if lhs.`attachments` != rhs.`attachments` {
            return false
        }
        if lhs.`fields` != rhs.`fields` {
            return false
        }
        if lhs.`passwordHistory` != rhs.`passwordHistory` {
            return false
        }
        if lhs.`creationDate` != rhs.`creationDate` {
            return false
        }
        if lhs.`deletedDate` != rhs.`deletedDate` {
            return false
        }
        if lhs.`revisionDate` != rhs.`revisionDate` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`organizationId`)
        hasher.combine(`folderId`)
        hasher.combine(`collectionIds`)
        hasher.combine(`name`)
        hasher.combine(`notes`)
        hasher.combine(`type`)
        hasher.combine(`login`)
        hasher.combine(`identity`)
        hasher.combine(`card`)
        hasher.combine(`secureNote`)
        hasher.combine(`favorite`)
        hasher.combine(`reprompt`)
        hasher.combine(`organizationUseTotp`)
        hasher.combine(`edit`)
        hasher.combine(`viewPassword`)
        hasher.combine(`localData`)
        hasher.combine(`attachments`)
        hasher.combine(`fields`)
        hasher.combine(`passwordHistory`)
        hasher.combine(`creationDate`)
        hasher.combine(`deletedDate`)
        hasher.combine(`revisionDate`)
    }
}


public struct FfiConverterTypeCipher: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cipher {
        return try Cipher(
            `id`: FfiConverterOptionTypeUuid.read(from: &buf), 
            `organizationId`: FfiConverterOptionTypeUuid.read(from: &buf), 
            `folderId`: FfiConverterOptionTypeUuid.read(from: &buf), 
            `collectionIds`: FfiConverterSequenceTypeUuid.read(from: &buf), 
            `name`: FfiConverterTypeEncString.read(from: &buf), 
            `notes`: FfiConverterTypeEncString.read(from: &buf), 
            `type`: FfiConverterTypeCipherType.read(from: &buf), 
            `login`: FfiConverterOptionTypeLogin.read(from: &buf), 
            `identity`: FfiConverterOptionTypeIdentity.read(from: &buf), 
            `card`: FfiConverterOptionTypeCard.read(from: &buf), 
            `secureNote`: FfiConverterOptionTypeSecureNote.read(from: &buf), 
            `favorite`: FfiConverterBool.read(from: &buf), 
            `reprompt`: FfiConverterTypeCipherRepromptType.read(from: &buf), 
            `organizationUseTotp`: FfiConverterBool.read(from: &buf), 
            `edit`: FfiConverterBool.read(from: &buf), 
            `viewPassword`: FfiConverterBool.read(from: &buf), 
            `localData`: FfiConverterOptionTypeLocalData.read(from: &buf), 
            `attachments`: FfiConverterSequenceTypeAttachment.read(from: &buf), 
            `fields`: FfiConverterSequenceTypeField.read(from: &buf), 
            `passwordHistory`: FfiConverterSequenceTypePasswordHistory.read(from: &buf), 
            `creationDate`: FfiConverterTypeDateTime.read(from: &buf), 
            `deletedDate`: FfiConverterOptionTypeDateTime.read(from: &buf), 
            `revisionDate`: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: Cipher, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.`id`, into: &buf)
        FfiConverterOptionTypeUuid.write(value.`organizationId`, into: &buf)
        FfiConverterOptionTypeUuid.write(value.`folderId`, into: &buf)
        FfiConverterSequenceTypeUuid.write(value.`collectionIds`, into: &buf)
        FfiConverterTypeEncString.write(value.`name`, into: &buf)
        FfiConverterTypeEncString.write(value.`notes`, into: &buf)
        FfiConverterTypeCipherType.write(value.`type`, into: &buf)
        FfiConverterOptionTypeLogin.write(value.`login`, into: &buf)
        FfiConverterOptionTypeIdentity.write(value.`identity`, into: &buf)
        FfiConverterOptionTypeCard.write(value.`card`, into: &buf)
        FfiConverterOptionTypeSecureNote.write(value.`secureNote`, into: &buf)
        FfiConverterBool.write(value.`favorite`, into: &buf)
        FfiConverterTypeCipherRepromptType.write(value.`reprompt`, into: &buf)
        FfiConverterBool.write(value.`organizationUseTotp`, into: &buf)
        FfiConverterBool.write(value.`edit`, into: &buf)
        FfiConverterBool.write(value.`viewPassword`, into: &buf)
        FfiConverterOptionTypeLocalData.write(value.`localData`, into: &buf)
        FfiConverterSequenceTypeAttachment.write(value.`attachments`, into: &buf)
        FfiConverterSequenceTypeField.write(value.`fields`, into: &buf)
        FfiConverterSequenceTypePasswordHistory.write(value.`passwordHistory`, into: &buf)
        FfiConverterTypeDateTime.write(value.`creationDate`, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.`deletedDate`, into: &buf)
        FfiConverterTypeDateTime.write(value.`revisionDate`, into: &buf)
    }
}


public func FfiConverterTypeCipher_lift(_ buf: RustBuffer) throws -> Cipher {
    return try FfiConverterTypeCipher.lift(buf)
}

public func FfiConverterTypeCipher_lower(_ value: Cipher) -> RustBuffer {
    return FfiConverterTypeCipher.lower(value)
}


public struct CipherListView {
    public var `id`: Uuid?
    public var `organizationId`: Uuid?
    public var `folderId`: Uuid?
    public var `collectionIds`: [Uuid]
    public var `name`: String
    public var `subTitle`: String
    public var `type`: CipherType
    public var `favorite`: Bool
    public var `reprompt`: CipherRepromptType
    public var `edit`: Bool
    public var `viewPassword`: Bool
    public var `attachments`: UInt32
    public var `creationDate`: DateTime
    public var `deletedDate`: DateTime?
    public var `revisionDate`: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: Uuid?, `organizationId`: Uuid?, `folderId`: Uuid?, `collectionIds`: [Uuid], `name`: String, `subTitle`: String, `type`: CipherType, `favorite`: Bool, `reprompt`: CipherRepromptType, `edit`: Bool, `viewPassword`: Bool, `attachments`: UInt32, `creationDate`: DateTime, `deletedDate`: DateTime?, `revisionDate`: DateTime) {
        self.`id` = `id`
        self.`organizationId` = `organizationId`
        self.`folderId` = `folderId`
        self.`collectionIds` = `collectionIds`
        self.`name` = `name`
        self.`subTitle` = `subTitle`
        self.`type` = `type`
        self.`favorite` = `favorite`
        self.`reprompt` = `reprompt`
        self.`edit` = `edit`
        self.`viewPassword` = `viewPassword`
        self.`attachments` = `attachments`
        self.`creationDate` = `creationDate`
        self.`deletedDate` = `deletedDate`
        self.`revisionDate` = `revisionDate`
    }
}


extension CipherListView: Equatable, Hashable {
    public static func ==(lhs: CipherListView, rhs: CipherListView) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`organizationId` != rhs.`organizationId` {
            return false
        }
        if lhs.`folderId` != rhs.`folderId` {
            return false
        }
        if lhs.`collectionIds` != rhs.`collectionIds` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`subTitle` != rhs.`subTitle` {
            return false
        }
        if lhs.`type` != rhs.`type` {
            return false
        }
        if lhs.`favorite` != rhs.`favorite` {
            return false
        }
        if lhs.`reprompt` != rhs.`reprompt` {
            return false
        }
        if lhs.`edit` != rhs.`edit` {
            return false
        }
        if lhs.`viewPassword` != rhs.`viewPassword` {
            return false
        }
        if lhs.`attachments` != rhs.`attachments` {
            return false
        }
        if lhs.`creationDate` != rhs.`creationDate` {
            return false
        }
        if lhs.`deletedDate` != rhs.`deletedDate` {
            return false
        }
        if lhs.`revisionDate` != rhs.`revisionDate` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`organizationId`)
        hasher.combine(`folderId`)
        hasher.combine(`collectionIds`)
        hasher.combine(`name`)
        hasher.combine(`subTitle`)
        hasher.combine(`type`)
        hasher.combine(`favorite`)
        hasher.combine(`reprompt`)
        hasher.combine(`edit`)
        hasher.combine(`viewPassword`)
        hasher.combine(`attachments`)
        hasher.combine(`creationDate`)
        hasher.combine(`deletedDate`)
        hasher.combine(`revisionDate`)
    }
}


public struct FfiConverterTypeCipherListView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherListView {
        return try CipherListView(
            `id`: FfiConverterOptionTypeUuid.read(from: &buf), 
            `organizationId`: FfiConverterOptionTypeUuid.read(from: &buf), 
            `folderId`: FfiConverterOptionTypeUuid.read(from: &buf), 
            `collectionIds`: FfiConverterSequenceTypeUuid.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `subTitle`: FfiConverterString.read(from: &buf), 
            `type`: FfiConverterTypeCipherType.read(from: &buf), 
            `favorite`: FfiConverterBool.read(from: &buf), 
            `reprompt`: FfiConverterTypeCipherRepromptType.read(from: &buf), 
            `edit`: FfiConverterBool.read(from: &buf), 
            `viewPassword`: FfiConverterBool.read(from: &buf), 
            `attachments`: FfiConverterUInt32.read(from: &buf), 
            `creationDate`: FfiConverterTypeDateTime.read(from: &buf), 
            `deletedDate`: FfiConverterOptionTypeDateTime.read(from: &buf), 
            `revisionDate`: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: CipherListView, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.`id`, into: &buf)
        FfiConverterOptionTypeUuid.write(value.`organizationId`, into: &buf)
        FfiConverterOptionTypeUuid.write(value.`folderId`, into: &buf)
        FfiConverterSequenceTypeUuid.write(value.`collectionIds`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`subTitle`, into: &buf)
        FfiConverterTypeCipherType.write(value.`type`, into: &buf)
        FfiConverterBool.write(value.`favorite`, into: &buf)
        FfiConverterTypeCipherRepromptType.write(value.`reprompt`, into: &buf)
        FfiConverterBool.write(value.`edit`, into: &buf)
        FfiConverterBool.write(value.`viewPassword`, into: &buf)
        FfiConverterUInt32.write(value.`attachments`, into: &buf)
        FfiConverterTypeDateTime.write(value.`creationDate`, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.`deletedDate`, into: &buf)
        FfiConverterTypeDateTime.write(value.`revisionDate`, into: &buf)
    }
}


public func FfiConverterTypeCipherListView_lift(_ buf: RustBuffer) throws -> CipherListView {
    return try FfiConverterTypeCipherListView.lift(buf)
}

public func FfiConverterTypeCipherListView_lower(_ value: CipherListView) -> RustBuffer {
    return FfiConverterTypeCipherListView.lower(value)
}


public struct CipherView {
    public var `id`: Uuid?
    public var `organizationId`: Uuid?
    public var `folderId`: Uuid?
    public var `collectionIds`: [Uuid]
    public var `name`: String
    public var `notes`: String
    public var `type`: CipherType
    public var `login`: LoginView?
    public var `identity`: IdentityView?
    public var `card`: CardView?
    public var `secureNote`: SecureNoteView?
    public var `favorite`: Bool
    public var `reprompt`: CipherRepromptType
    public var `organizationUseTotp`: Bool
    public var `edit`: Bool
    public var `viewPassword`: Bool
    public var `localData`: LocalDataView?
    public var `attachments`: [AttachmentView]
    public var `fields`: [FieldView]
    public var `passwordHistory`: [PasswordHistoryView]
    public var `creationDate`: DateTime
    public var `deletedDate`: DateTime?
    public var `revisionDate`: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: Uuid?, `organizationId`: Uuid?, `folderId`: Uuid?, `collectionIds`: [Uuid], `name`: String, `notes`: String, `type`: CipherType, `login`: LoginView?, `identity`: IdentityView?, `card`: CardView?, `secureNote`: SecureNoteView?, `favorite`: Bool, `reprompt`: CipherRepromptType, `organizationUseTotp`: Bool, `edit`: Bool, `viewPassword`: Bool, `localData`: LocalDataView?, `attachments`: [AttachmentView], `fields`: [FieldView], `passwordHistory`: [PasswordHistoryView], `creationDate`: DateTime, `deletedDate`: DateTime?, `revisionDate`: DateTime) {
        self.`id` = `id`
        self.`organizationId` = `organizationId`
        self.`folderId` = `folderId`
        self.`collectionIds` = `collectionIds`
        self.`name` = `name`
        self.`notes` = `notes`
        self.`type` = `type`
        self.`login` = `login`
        self.`identity` = `identity`
        self.`card` = `card`
        self.`secureNote` = `secureNote`
        self.`favorite` = `favorite`
        self.`reprompt` = `reprompt`
        self.`organizationUseTotp` = `organizationUseTotp`
        self.`edit` = `edit`
        self.`viewPassword` = `viewPassword`
        self.`localData` = `localData`
        self.`attachments` = `attachments`
        self.`fields` = `fields`
        self.`passwordHistory` = `passwordHistory`
        self.`creationDate` = `creationDate`
        self.`deletedDate` = `deletedDate`
        self.`revisionDate` = `revisionDate`
    }
}


extension CipherView: Equatable, Hashable {
    public static func ==(lhs: CipherView, rhs: CipherView) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`organizationId` != rhs.`organizationId` {
            return false
        }
        if lhs.`folderId` != rhs.`folderId` {
            return false
        }
        if lhs.`collectionIds` != rhs.`collectionIds` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`notes` != rhs.`notes` {
            return false
        }
        if lhs.`type` != rhs.`type` {
            return false
        }
        if lhs.`login` != rhs.`login` {
            return false
        }
        if lhs.`identity` != rhs.`identity` {
            return false
        }
        if lhs.`card` != rhs.`card` {
            return false
        }
        if lhs.`secureNote` != rhs.`secureNote` {
            return false
        }
        if lhs.`favorite` != rhs.`favorite` {
            return false
        }
        if lhs.`reprompt` != rhs.`reprompt` {
            return false
        }
        if lhs.`organizationUseTotp` != rhs.`organizationUseTotp` {
            return false
        }
        if lhs.`edit` != rhs.`edit` {
            return false
        }
        if lhs.`viewPassword` != rhs.`viewPassword` {
            return false
        }
        if lhs.`localData` != rhs.`localData` {
            return false
        }
        if lhs.`attachments` != rhs.`attachments` {
            return false
        }
        if lhs.`fields` != rhs.`fields` {
            return false
        }
        if lhs.`passwordHistory` != rhs.`passwordHistory` {
            return false
        }
        if lhs.`creationDate` != rhs.`creationDate` {
            return false
        }
        if lhs.`deletedDate` != rhs.`deletedDate` {
            return false
        }
        if lhs.`revisionDate` != rhs.`revisionDate` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`organizationId`)
        hasher.combine(`folderId`)
        hasher.combine(`collectionIds`)
        hasher.combine(`name`)
        hasher.combine(`notes`)
        hasher.combine(`type`)
        hasher.combine(`login`)
        hasher.combine(`identity`)
        hasher.combine(`card`)
        hasher.combine(`secureNote`)
        hasher.combine(`favorite`)
        hasher.combine(`reprompt`)
        hasher.combine(`organizationUseTotp`)
        hasher.combine(`edit`)
        hasher.combine(`viewPassword`)
        hasher.combine(`localData`)
        hasher.combine(`attachments`)
        hasher.combine(`fields`)
        hasher.combine(`passwordHistory`)
        hasher.combine(`creationDate`)
        hasher.combine(`deletedDate`)
        hasher.combine(`revisionDate`)
    }
}


public struct FfiConverterTypeCipherView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherView {
        return try CipherView(
            `id`: FfiConverterOptionTypeUuid.read(from: &buf), 
            `organizationId`: FfiConverterOptionTypeUuid.read(from: &buf), 
            `folderId`: FfiConverterOptionTypeUuid.read(from: &buf), 
            `collectionIds`: FfiConverterSequenceTypeUuid.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `notes`: FfiConverterString.read(from: &buf), 
            `type`: FfiConverterTypeCipherType.read(from: &buf), 
            `login`: FfiConverterOptionTypeLoginView.read(from: &buf), 
            `identity`: FfiConverterOptionTypeIdentityView.read(from: &buf), 
            `card`: FfiConverterOptionTypeCardView.read(from: &buf), 
            `secureNote`: FfiConverterOptionTypeSecureNoteView.read(from: &buf), 
            `favorite`: FfiConverterBool.read(from: &buf), 
            `reprompt`: FfiConverterTypeCipherRepromptType.read(from: &buf), 
            `organizationUseTotp`: FfiConverterBool.read(from: &buf), 
            `edit`: FfiConverterBool.read(from: &buf), 
            `viewPassword`: FfiConverterBool.read(from: &buf), 
            `localData`: FfiConverterOptionTypeLocalDataView.read(from: &buf), 
            `attachments`: FfiConverterSequenceTypeAttachmentView.read(from: &buf), 
            `fields`: FfiConverterSequenceTypeFieldView.read(from: &buf), 
            `passwordHistory`: FfiConverterSequenceTypePasswordHistoryView.read(from: &buf), 
            `creationDate`: FfiConverterTypeDateTime.read(from: &buf), 
            `deletedDate`: FfiConverterOptionTypeDateTime.read(from: &buf), 
            `revisionDate`: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: CipherView, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.`id`, into: &buf)
        FfiConverterOptionTypeUuid.write(value.`organizationId`, into: &buf)
        FfiConverterOptionTypeUuid.write(value.`folderId`, into: &buf)
        FfiConverterSequenceTypeUuid.write(value.`collectionIds`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`notes`, into: &buf)
        FfiConverterTypeCipherType.write(value.`type`, into: &buf)
        FfiConverterOptionTypeLoginView.write(value.`login`, into: &buf)
        FfiConverterOptionTypeIdentityView.write(value.`identity`, into: &buf)
        FfiConverterOptionTypeCardView.write(value.`card`, into: &buf)
        FfiConverterOptionTypeSecureNoteView.write(value.`secureNote`, into: &buf)
        FfiConverterBool.write(value.`favorite`, into: &buf)
        FfiConverterTypeCipherRepromptType.write(value.`reprompt`, into: &buf)
        FfiConverterBool.write(value.`organizationUseTotp`, into: &buf)
        FfiConverterBool.write(value.`edit`, into: &buf)
        FfiConverterBool.write(value.`viewPassword`, into: &buf)
        FfiConverterOptionTypeLocalDataView.write(value.`localData`, into: &buf)
        FfiConverterSequenceTypeAttachmentView.write(value.`attachments`, into: &buf)
        FfiConverterSequenceTypeFieldView.write(value.`fields`, into: &buf)
        FfiConverterSequenceTypePasswordHistoryView.write(value.`passwordHistory`, into: &buf)
        FfiConverterTypeDateTime.write(value.`creationDate`, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.`deletedDate`, into: &buf)
        FfiConverterTypeDateTime.write(value.`revisionDate`, into: &buf)
    }
}


public func FfiConverterTypeCipherView_lift(_ buf: RustBuffer) throws -> CipherView {
    return try FfiConverterTypeCipherView.lift(buf)
}

public func FfiConverterTypeCipherView_lower(_ value: CipherView) -> RustBuffer {
    return FfiConverterTypeCipherView.lower(value)
}


public struct ClientSettings {
    public var `identityUrl`: String
    public var `apiUrl`: String
    public var `userAgent`: String
    public var `deviceType`: DeviceType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`identityUrl`: String, `apiUrl`: String, `userAgent`: String, `deviceType`: DeviceType) {
        self.`identityUrl` = `identityUrl`
        self.`apiUrl` = `apiUrl`
        self.`userAgent` = `userAgent`
        self.`deviceType` = `deviceType`
    }
}


extension ClientSettings: Equatable, Hashable {
    public static func ==(lhs: ClientSettings, rhs: ClientSettings) -> Bool {
        if lhs.`identityUrl` != rhs.`identityUrl` {
            return false
        }
        if lhs.`apiUrl` != rhs.`apiUrl` {
            return false
        }
        if lhs.`userAgent` != rhs.`userAgent` {
            return false
        }
        if lhs.`deviceType` != rhs.`deviceType` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`identityUrl`)
        hasher.combine(`apiUrl`)
        hasher.combine(`userAgent`)
        hasher.combine(`deviceType`)
    }
}


public struct FfiConverterTypeClientSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientSettings {
        return try ClientSettings(
            `identityUrl`: FfiConverterString.read(from: &buf), 
            `apiUrl`: FfiConverterString.read(from: &buf), 
            `userAgent`: FfiConverterString.read(from: &buf), 
            `deviceType`: FfiConverterTypeDeviceType.read(from: &buf)
        )
    }

    public static func write(_ value: ClientSettings, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`identityUrl`, into: &buf)
        FfiConverterString.write(value.`apiUrl`, into: &buf)
        FfiConverterString.write(value.`userAgent`, into: &buf)
        FfiConverterTypeDeviceType.write(value.`deviceType`, into: &buf)
    }
}


public func FfiConverterTypeClientSettings_lift(_ buf: RustBuffer) throws -> ClientSettings {
    return try FfiConverterTypeClientSettings.lift(buf)
}

public func FfiConverterTypeClientSettings_lower(_ value: ClientSettings) -> RustBuffer {
    return FfiConverterTypeClientSettings.lower(value)
}


public struct Collection {
    public var `id`: Uuid
    public var `organizationId`: Uuid
    public var `name`: EncString
    public var `externalId`: String?
    public var `hidePasswords`: Bool
    public var `readOnly`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: Uuid, `organizationId`: Uuid, `name`: EncString, `externalId`: String?, `hidePasswords`: Bool, `readOnly`: Bool) {
        self.`id` = `id`
        self.`organizationId` = `organizationId`
        self.`name` = `name`
        self.`externalId` = `externalId`
        self.`hidePasswords` = `hidePasswords`
        self.`readOnly` = `readOnly`
    }
}


extension Collection: Equatable, Hashable {
    public static func ==(lhs: Collection, rhs: Collection) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`organizationId` != rhs.`organizationId` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`externalId` != rhs.`externalId` {
            return false
        }
        if lhs.`hidePasswords` != rhs.`hidePasswords` {
            return false
        }
        if lhs.`readOnly` != rhs.`readOnly` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`organizationId`)
        hasher.combine(`name`)
        hasher.combine(`externalId`)
        hasher.combine(`hidePasswords`)
        hasher.combine(`readOnly`)
    }
}


public struct FfiConverterTypeCollection: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Collection {
        return try Collection(
            `id`: FfiConverterTypeUuid.read(from: &buf), 
            `organizationId`: FfiConverterTypeUuid.read(from: &buf), 
            `name`: FfiConverterTypeEncString.read(from: &buf), 
            `externalId`: FfiConverterOptionString.read(from: &buf), 
            `hidePasswords`: FfiConverterBool.read(from: &buf), 
            `readOnly`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Collection, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.`id`, into: &buf)
        FfiConverterTypeUuid.write(value.`organizationId`, into: &buf)
        FfiConverterTypeEncString.write(value.`name`, into: &buf)
        FfiConverterOptionString.write(value.`externalId`, into: &buf)
        FfiConverterBool.write(value.`hidePasswords`, into: &buf)
        FfiConverterBool.write(value.`readOnly`, into: &buf)
    }
}


public func FfiConverterTypeCollection_lift(_ buf: RustBuffer) throws -> Collection {
    return try FfiConverterTypeCollection.lift(buf)
}

public func FfiConverterTypeCollection_lower(_ value: Collection) -> RustBuffer {
    return FfiConverterTypeCollection.lower(value)
}


public struct CollectionView {
    public var `id`: Uuid
    public var `organizationId`: Uuid
    public var `name`: String
    public var `externalId`: String?
    public var `hidePasswords`: Bool
    public var `readOnly`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: Uuid, `organizationId`: Uuid, `name`: String, `externalId`: String?, `hidePasswords`: Bool, `readOnly`: Bool) {
        self.`id` = `id`
        self.`organizationId` = `organizationId`
        self.`name` = `name`
        self.`externalId` = `externalId`
        self.`hidePasswords` = `hidePasswords`
        self.`readOnly` = `readOnly`
    }
}


extension CollectionView: Equatable, Hashable {
    public static func ==(lhs: CollectionView, rhs: CollectionView) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`organizationId` != rhs.`organizationId` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`externalId` != rhs.`externalId` {
            return false
        }
        if lhs.`hidePasswords` != rhs.`hidePasswords` {
            return false
        }
        if lhs.`readOnly` != rhs.`readOnly` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`organizationId`)
        hasher.combine(`name`)
        hasher.combine(`externalId`)
        hasher.combine(`hidePasswords`)
        hasher.combine(`readOnly`)
    }
}


public struct FfiConverterTypeCollectionView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionView {
        return try CollectionView(
            `id`: FfiConverterTypeUuid.read(from: &buf), 
            `organizationId`: FfiConverterTypeUuid.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `externalId`: FfiConverterOptionString.read(from: &buf), 
            `hidePasswords`: FfiConverterBool.read(from: &buf), 
            `readOnly`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CollectionView, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.`id`, into: &buf)
        FfiConverterTypeUuid.write(value.`organizationId`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterOptionString.write(value.`externalId`, into: &buf)
        FfiConverterBool.write(value.`hidePasswords`, into: &buf)
        FfiConverterBool.write(value.`readOnly`, into: &buf)
    }
}


public func FfiConverterTypeCollectionView_lift(_ buf: RustBuffer) throws -> CollectionView {
    return try FfiConverterTypeCollectionView.lift(buf)
}

public func FfiConverterTypeCollectionView_lower(_ value: CollectionView) -> RustBuffer {
    return FfiConverterTypeCollectionView.lower(value)
}


public struct Field {
    public var `name`: EncString
    public var `value`: EncString
    public var `type`: FieldType
    public var `linkedId`: LinkedIdType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: EncString, `value`: EncString, `type`: FieldType, `linkedId`: LinkedIdType?) {
        self.`name` = `name`
        self.`value` = `value`
        self.`type` = `type`
        self.`linkedId` = `linkedId`
    }
}


extension Field: Equatable, Hashable {
    public static func ==(lhs: Field, rhs: Field) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`value` != rhs.`value` {
            return false
        }
        if lhs.`type` != rhs.`type` {
            return false
        }
        if lhs.`linkedId` != rhs.`linkedId` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`value`)
        hasher.combine(`type`)
        hasher.combine(`linkedId`)
    }
}


public struct FfiConverterTypeField: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Field {
        return try Field(
            `name`: FfiConverterTypeEncString.read(from: &buf), 
            `value`: FfiConverterTypeEncString.read(from: &buf), 
            `type`: FfiConverterTypeFieldType.read(from: &buf), 
            `linkedId`: FfiConverterOptionTypeLinkedIdType.read(from: &buf)
        )
    }

    public static func write(_ value: Field, into buf: inout [UInt8]) {
        FfiConverterTypeEncString.write(value.`name`, into: &buf)
        FfiConverterTypeEncString.write(value.`value`, into: &buf)
        FfiConverterTypeFieldType.write(value.`type`, into: &buf)
        FfiConverterOptionTypeLinkedIdType.write(value.`linkedId`, into: &buf)
    }
}


public func FfiConverterTypeField_lift(_ buf: RustBuffer) throws -> Field {
    return try FfiConverterTypeField.lift(buf)
}

public func FfiConverterTypeField_lower(_ value: Field) -> RustBuffer {
    return FfiConverterTypeField.lower(value)
}


public struct FieldView {
    public var `name`: String
    public var `value`: String
    public var `type`: FieldType
    public var `linkedId`: LinkedIdType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String, `value`: String, `type`: FieldType, `linkedId`: LinkedIdType?) {
        self.`name` = `name`
        self.`value` = `value`
        self.`type` = `type`
        self.`linkedId` = `linkedId`
    }
}


extension FieldView: Equatable, Hashable {
    public static func ==(lhs: FieldView, rhs: FieldView) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`value` != rhs.`value` {
            return false
        }
        if lhs.`type` != rhs.`type` {
            return false
        }
        if lhs.`linkedId` != rhs.`linkedId` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`value`)
        hasher.combine(`type`)
        hasher.combine(`linkedId`)
    }
}


public struct FfiConverterTypeFieldView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FieldView {
        return try FieldView(
            `name`: FfiConverterString.read(from: &buf), 
            `value`: FfiConverterString.read(from: &buf), 
            `type`: FfiConverterTypeFieldType.read(from: &buf), 
            `linkedId`: FfiConverterOptionTypeLinkedIdType.read(from: &buf)
        )
    }

    public static func write(_ value: FieldView, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`value`, into: &buf)
        FfiConverterTypeFieldType.write(value.`type`, into: &buf)
        FfiConverterOptionTypeLinkedIdType.write(value.`linkedId`, into: &buf)
    }
}


public func FfiConverterTypeFieldView_lift(_ buf: RustBuffer) throws -> FieldView {
    return try FfiConverterTypeFieldView.lift(buf)
}

public func FfiConverterTypeFieldView_lower(_ value: FieldView) -> RustBuffer {
    return FfiConverterTypeFieldView.lower(value)
}


public struct Folder {
    public var `id`: Uuid
    public var `name`: EncString
    public var `revisionDate`: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: Uuid, `name`: EncString, `revisionDate`: DateTime) {
        self.`id` = `id`
        self.`name` = `name`
        self.`revisionDate` = `revisionDate`
    }
}


extension Folder: Equatable, Hashable {
    public static func ==(lhs: Folder, rhs: Folder) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`revisionDate` != rhs.`revisionDate` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`name`)
        hasher.combine(`revisionDate`)
    }
}


public struct FfiConverterTypeFolder: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Folder {
        return try Folder(
            `id`: FfiConverterTypeUuid.read(from: &buf), 
            `name`: FfiConverterTypeEncString.read(from: &buf), 
            `revisionDate`: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: Folder, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.`id`, into: &buf)
        FfiConverterTypeEncString.write(value.`name`, into: &buf)
        FfiConverterTypeDateTime.write(value.`revisionDate`, into: &buf)
    }
}


public func FfiConverterTypeFolder_lift(_ buf: RustBuffer) throws -> Folder {
    return try FfiConverterTypeFolder.lift(buf)
}

public func FfiConverterTypeFolder_lower(_ value: Folder) -> RustBuffer {
    return FfiConverterTypeFolder.lower(value)
}


public struct FolderView {
    public var `id`: Uuid
    public var `name`: String
    public var `revisionDate`: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: Uuid, `name`: String, `revisionDate`: DateTime) {
        self.`id` = `id`
        self.`name` = `name`
        self.`revisionDate` = `revisionDate`
    }
}


extension FolderView: Equatable, Hashable {
    public static func ==(lhs: FolderView, rhs: FolderView) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`revisionDate` != rhs.`revisionDate` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`name`)
        hasher.combine(`revisionDate`)
    }
}


public struct FfiConverterTypeFolderView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FolderView {
        return try FolderView(
            `id`: FfiConverterTypeUuid.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `revisionDate`: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: FolderView, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterTypeDateTime.write(value.`revisionDate`, into: &buf)
    }
}


public func FfiConverterTypeFolderView_lift(_ buf: RustBuffer) throws -> FolderView {
    return try FfiConverterTypeFolderView.lift(buf)
}

public func FfiConverterTypeFolderView_lower(_ value: FolderView) -> RustBuffer {
    return FfiConverterTypeFolderView.lower(value)
}


public struct Identity {
    public var `title`: EncString?
    public var `firstName`: EncString?
    public var `middleName`: EncString?
    public var `lastName`: EncString?
    public var `address1`: EncString?
    public var `address2`: EncString?
    public var `address3`: EncString?
    public var `city`: EncString?
    public var `state`: EncString?
    public var `postalCode`: EncString?
    public var `country`: EncString?
    public var `company`: EncString?
    public var `email`: EncString?
    public var `phone`: EncString?
    public var `ssn`: EncString?
    public var `username`: EncString?
    public var `passportNumber`: EncString?
    public var `licenseNumber`: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`title`: EncString?, `firstName`: EncString?, `middleName`: EncString?, `lastName`: EncString?, `address1`: EncString?, `address2`: EncString?, `address3`: EncString?, `city`: EncString?, `state`: EncString?, `postalCode`: EncString?, `country`: EncString?, `company`: EncString?, `email`: EncString?, `phone`: EncString?, `ssn`: EncString?, `username`: EncString?, `passportNumber`: EncString?, `licenseNumber`: EncString?) {
        self.`title` = `title`
        self.`firstName` = `firstName`
        self.`middleName` = `middleName`
        self.`lastName` = `lastName`
        self.`address1` = `address1`
        self.`address2` = `address2`
        self.`address3` = `address3`
        self.`city` = `city`
        self.`state` = `state`
        self.`postalCode` = `postalCode`
        self.`country` = `country`
        self.`company` = `company`
        self.`email` = `email`
        self.`phone` = `phone`
        self.`ssn` = `ssn`
        self.`username` = `username`
        self.`passportNumber` = `passportNumber`
        self.`licenseNumber` = `licenseNumber`
    }
}


extension Identity: Equatable, Hashable {
    public static func ==(lhs: Identity, rhs: Identity) -> Bool {
        if lhs.`title` != rhs.`title` {
            return false
        }
        if lhs.`firstName` != rhs.`firstName` {
            return false
        }
        if lhs.`middleName` != rhs.`middleName` {
            return false
        }
        if lhs.`lastName` != rhs.`lastName` {
            return false
        }
        if lhs.`address1` != rhs.`address1` {
            return false
        }
        if lhs.`address2` != rhs.`address2` {
            return false
        }
        if lhs.`address3` != rhs.`address3` {
            return false
        }
        if lhs.`city` != rhs.`city` {
            return false
        }
        if lhs.`state` != rhs.`state` {
            return false
        }
        if lhs.`postalCode` != rhs.`postalCode` {
            return false
        }
        if lhs.`country` != rhs.`country` {
            return false
        }
        if lhs.`company` != rhs.`company` {
            return false
        }
        if lhs.`email` != rhs.`email` {
            return false
        }
        if lhs.`phone` != rhs.`phone` {
            return false
        }
        if lhs.`ssn` != rhs.`ssn` {
            return false
        }
        if lhs.`username` != rhs.`username` {
            return false
        }
        if lhs.`passportNumber` != rhs.`passportNumber` {
            return false
        }
        if lhs.`licenseNumber` != rhs.`licenseNumber` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`title`)
        hasher.combine(`firstName`)
        hasher.combine(`middleName`)
        hasher.combine(`lastName`)
        hasher.combine(`address1`)
        hasher.combine(`address2`)
        hasher.combine(`address3`)
        hasher.combine(`city`)
        hasher.combine(`state`)
        hasher.combine(`postalCode`)
        hasher.combine(`country`)
        hasher.combine(`company`)
        hasher.combine(`email`)
        hasher.combine(`phone`)
        hasher.combine(`ssn`)
        hasher.combine(`username`)
        hasher.combine(`passportNumber`)
        hasher.combine(`licenseNumber`)
    }
}


public struct FfiConverterTypeIdentity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Identity {
        return try Identity(
            `title`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `firstName`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `middleName`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `lastName`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `address1`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `address2`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `address3`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `city`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `state`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `postalCode`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `country`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `company`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `email`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `phone`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `ssn`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `username`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `passportNumber`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `licenseNumber`: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: Identity, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.`title`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`firstName`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`middleName`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`lastName`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`address1`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`address2`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`address3`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`city`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`state`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`postalCode`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`country`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`company`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`email`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`phone`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`ssn`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`username`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`passportNumber`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`licenseNumber`, into: &buf)
    }
}


public func FfiConverterTypeIdentity_lift(_ buf: RustBuffer) throws -> Identity {
    return try FfiConverterTypeIdentity.lift(buf)
}

public func FfiConverterTypeIdentity_lower(_ value: Identity) -> RustBuffer {
    return FfiConverterTypeIdentity.lower(value)
}


public struct IdentityView {
    public var `title`: String?
    public var `firstName`: String?
    public var `middleName`: String?
    public var `lastName`: String?
    public var `address1`: String?
    public var `address2`: String?
    public var `address3`: String?
    public var `city`: String?
    public var `state`: String?
    public var `postalCode`: String?
    public var `country`: String?
    public var `company`: String?
    public var `email`: String?
    public var `phone`: String?
    public var `ssn`: String?
    public var `username`: String?
    public var `passportNumber`: String?
    public var `licenseNumber`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`title`: String?, `firstName`: String?, `middleName`: String?, `lastName`: String?, `address1`: String?, `address2`: String?, `address3`: String?, `city`: String?, `state`: String?, `postalCode`: String?, `country`: String?, `company`: String?, `email`: String?, `phone`: String?, `ssn`: String?, `username`: String?, `passportNumber`: String?, `licenseNumber`: String?) {
        self.`title` = `title`
        self.`firstName` = `firstName`
        self.`middleName` = `middleName`
        self.`lastName` = `lastName`
        self.`address1` = `address1`
        self.`address2` = `address2`
        self.`address3` = `address3`
        self.`city` = `city`
        self.`state` = `state`
        self.`postalCode` = `postalCode`
        self.`country` = `country`
        self.`company` = `company`
        self.`email` = `email`
        self.`phone` = `phone`
        self.`ssn` = `ssn`
        self.`username` = `username`
        self.`passportNumber` = `passportNumber`
        self.`licenseNumber` = `licenseNumber`
    }
}


extension IdentityView: Equatable, Hashable {
    public static func ==(lhs: IdentityView, rhs: IdentityView) -> Bool {
        if lhs.`title` != rhs.`title` {
            return false
        }
        if lhs.`firstName` != rhs.`firstName` {
            return false
        }
        if lhs.`middleName` != rhs.`middleName` {
            return false
        }
        if lhs.`lastName` != rhs.`lastName` {
            return false
        }
        if lhs.`address1` != rhs.`address1` {
            return false
        }
        if lhs.`address2` != rhs.`address2` {
            return false
        }
        if lhs.`address3` != rhs.`address3` {
            return false
        }
        if lhs.`city` != rhs.`city` {
            return false
        }
        if lhs.`state` != rhs.`state` {
            return false
        }
        if lhs.`postalCode` != rhs.`postalCode` {
            return false
        }
        if lhs.`country` != rhs.`country` {
            return false
        }
        if lhs.`company` != rhs.`company` {
            return false
        }
        if lhs.`email` != rhs.`email` {
            return false
        }
        if lhs.`phone` != rhs.`phone` {
            return false
        }
        if lhs.`ssn` != rhs.`ssn` {
            return false
        }
        if lhs.`username` != rhs.`username` {
            return false
        }
        if lhs.`passportNumber` != rhs.`passportNumber` {
            return false
        }
        if lhs.`licenseNumber` != rhs.`licenseNumber` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`title`)
        hasher.combine(`firstName`)
        hasher.combine(`middleName`)
        hasher.combine(`lastName`)
        hasher.combine(`address1`)
        hasher.combine(`address2`)
        hasher.combine(`address3`)
        hasher.combine(`city`)
        hasher.combine(`state`)
        hasher.combine(`postalCode`)
        hasher.combine(`country`)
        hasher.combine(`company`)
        hasher.combine(`email`)
        hasher.combine(`phone`)
        hasher.combine(`ssn`)
        hasher.combine(`username`)
        hasher.combine(`passportNumber`)
        hasher.combine(`licenseNumber`)
    }
}


public struct FfiConverterTypeIdentityView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityView {
        return try IdentityView(
            `title`: FfiConverterOptionString.read(from: &buf), 
            `firstName`: FfiConverterOptionString.read(from: &buf), 
            `middleName`: FfiConverterOptionString.read(from: &buf), 
            `lastName`: FfiConverterOptionString.read(from: &buf), 
            `address1`: FfiConverterOptionString.read(from: &buf), 
            `address2`: FfiConverterOptionString.read(from: &buf), 
            `address3`: FfiConverterOptionString.read(from: &buf), 
            `city`: FfiConverterOptionString.read(from: &buf), 
            `state`: FfiConverterOptionString.read(from: &buf), 
            `postalCode`: FfiConverterOptionString.read(from: &buf), 
            `country`: FfiConverterOptionString.read(from: &buf), 
            `company`: FfiConverterOptionString.read(from: &buf), 
            `email`: FfiConverterOptionString.read(from: &buf), 
            `phone`: FfiConverterOptionString.read(from: &buf), 
            `ssn`: FfiConverterOptionString.read(from: &buf), 
            `username`: FfiConverterOptionString.read(from: &buf), 
            `passportNumber`: FfiConverterOptionString.read(from: &buf), 
            `licenseNumber`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`title`, into: &buf)
        FfiConverterOptionString.write(value.`firstName`, into: &buf)
        FfiConverterOptionString.write(value.`middleName`, into: &buf)
        FfiConverterOptionString.write(value.`lastName`, into: &buf)
        FfiConverterOptionString.write(value.`address1`, into: &buf)
        FfiConverterOptionString.write(value.`address2`, into: &buf)
        FfiConverterOptionString.write(value.`address3`, into: &buf)
        FfiConverterOptionString.write(value.`city`, into: &buf)
        FfiConverterOptionString.write(value.`state`, into: &buf)
        FfiConverterOptionString.write(value.`postalCode`, into: &buf)
        FfiConverterOptionString.write(value.`country`, into: &buf)
        FfiConverterOptionString.write(value.`company`, into: &buf)
        FfiConverterOptionString.write(value.`email`, into: &buf)
        FfiConverterOptionString.write(value.`phone`, into: &buf)
        FfiConverterOptionString.write(value.`ssn`, into: &buf)
        FfiConverterOptionString.write(value.`username`, into: &buf)
        FfiConverterOptionString.write(value.`passportNumber`, into: &buf)
        FfiConverterOptionString.write(value.`licenseNumber`, into: &buf)
    }
}


public func FfiConverterTypeIdentityView_lift(_ buf: RustBuffer) throws -> IdentityView {
    return try FfiConverterTypeIdentityView.lift(buf)
}

public func FfiConverterTypeIdentityView_lower(_ value: IdentityView) -> RustBuffer {
    return FfiConverterTypeIdentityView.lower(value)
}


public struct InitCryptoRequest {
    public var `kdfParams`: Kdf
    public var `email`: String
    public var `password`: String
    public var `userKey`: String
    public var `privateKey`: String
    public var `organizationKeys`: [Uuid: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`kdfParams`: Kdf, `email`: String, `password`: String, `userKey`: String, `privateKey`: String, `organizationKeys`: [Uuid: String]) {
        self.`kdfParams` = `kdfParams`
        self.`email` = `email`
        self.`password` = `password`
        self.`userKey` = `userKey`
        self.`privateKey` = `privateKey`
        self.`organizationKeys` = `organizationKeys`
    }
}


extension InitCryptoRequest: Equatable, Hashable {
    public static func ==(lhs: InitCryptoRequest, rhs: InitCryptoRequest) -> Bool {
        if lhs.`kdfParams` != rhs.`kdfParams` {
            return false
        }
        if lhs.`email` != rhs.`email` {
            return false
        }
        if lhs.`password` != rhs.`password` {
            return false
        }
        if lhs.`userKey` != rhs.`userKey` {
            return false
        }
        if lhs.`privateKey` != rhs.`privateKey` {
            return false
        }
        if lhs.`organizationKeys` != rhs.`organizationKeys` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`kdfParams`)
        hasher.combine(`email`)
        hasher.combine(`password`)
        hasher.combine(`userKey`)
        hasher.combine(`privateKey`)
        hasher.combine(`organizationKeys`)
    }
}


public struct FfiConverterTypeInitCryptoRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitCryptoRequest {
        return try InitCryptoRequest(
            `kdfParams`: FfiConverterTypeKdf.read(from: &buf), 
            `email`: FfiConverterString.read(from: &buf), 
            `password`: FfiConverterString.read(from: &buf), 
            `userKey`: FfiConverterString.read(from: &buf), 
            `privateKey`: FfiConverterString.read(from: &buf), 
            `organizationKeys`: FfiConverterDictionaryTypeUuidString.read(from: &buf)
        )
    }

    public static func write(_ value: InitCryptoRequest, into buf: inout [UInt8]) {
        FfiConverterTypeKdf.write(value.`kdfParams`, into: &buf)
        FfiConverterString.write(value.`email`, into: &buf)
        FfiConverterString.write(value.`password`, into: &buf)
        FfiConverterString.write(value.`userKey`, into: &buf)
        FfiConverterString.write(value.`privateKey`, into: &buf)
        FfiConverterDictionaryTypeUuidString.write(value.`organizationKeys`, into: &buf)
    }
}


public func FfiConverterTypeInitCryptoRequest_lift(_ buf: RustBuffer) throws -> InitCryptoRequest {
    return try FfiConverterTypeInitCryptoRequest.lift(buf)
}

public func FfiConverterTypeInitCryptoRequest_lower(_ value: InitCryptoRequest) -> RustBuffer {
    return FfiConverterTypeInitCryptoRequest.lower(value)
}


public struct LocalData {
    public var `lastUsedDate`: UInt32?
    public var `lastLaunched`: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`lastUsedDate`: UInt32?, `lastLaunched`: UInt32?) {
        self.`lastUsedDate` = `lastUsedDate`
        self.`lastLaunched` = `lastLaunched`
    }
}


extension LocalData: Equatable, Hashable {
    public static func ==(lhs: LocalData, rhs: LocalData) -> Bool {
        if lhs.`lastUsedDate` != rhs.`lastUsedDate` {
            return false
        }
        if lhs.`lastLaunched` != rhs.`lastLaunched` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`lastUsedDate`)
        hasher.combine(`lastLaunched`)
    }
}


public struct FfiConverterTypeLocalData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalData {
        return try LocalData(
            `lastUsedDate`: FfiConverterOptionUInt32.read(from: &buf), 
            `lastLaunched`: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: LocalData, into buf: inout [UInt8]) {
        FfiConverterOptionUInt32.write(value.`lastUsedDate`, into: &buf)
        FfiConverterOptionUInt32.write(value.`lastLaunched`, into: &buf)
    }
}


public func FfiConverterTypeLocalData_lift(_ buf: RustBuffer) throws -> LocalData {
    return try FfiConverterTypeLocalData.lift(buf)
}

public func FfiConverterTypeLocalData_lower(_ value: LocalData) -> RustBuffer {
    return FfiConverterTypeLocalData.lower(value)
}


public struct LocalDataView {
    public var `lastUsedDate`: UInt32?
    public var `lastLaunched`: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`lastUsedDate`: UInt32?, `lastLaunched`: UInt32?) {
        self.`lastUsedDate` = `lastUsedDate`
        self.`lastLaunched` = `lastLaunched`
    }
}


extension LocalDataView: Equatable, Hashable {
    public static func ==(lhs: LocalDataView, rhs: LocalDataView) -> Bool {
        if lhs.`lastUsedDate` != rhs.`lastUsedDate` {
            return false
        }
        if lhs.`lastLaunched` != rhs.`lastLaunched` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`lastUsedDate`)
        hasher.combine(`lastLaunched`)
    }
}


public struct FfiConverterTypeLocalDataView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalDataView {
        return try LocalDataView(
            `lastUsedDate`: FfiConverterOptionUInt32.read(from: &buf), 
            `lastLaunched`: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: LocalDataView, into buf: inout [UInt8]) {
        FfiConverterOptionUInt32.write(value.`lastUsedDate`, into: &buf)
        FfiConverterOptionUInt32.write(value.`lastLaunched`, into: &buf)
    }
}


public func FfiConverterTypeLocalDataView_lift(_ buf: RustBuffer) throws -> LocalDataView {
    return try FfiConverterTypeLocalDataView.lift(buf)
}

public func FfiConverterTypeLocalDataView_lower(_ value: LocalDataView) -> RustBuffer {
    return FfiConverterTypeLocalDataView.lower(value)
}


public struct Login {
    public var `username`: EncString
    public var `password`: EncString
    public var `passwordRevisionDate`: DateTime?
    public var `uris`: [LoginUri]
    public var `totp`: EncString?
    public var `autofillOnPageLoad`: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`username`: EncString, `password`: EncString, `passwordRevisionDate`: DateTime?, `uris`: [LoginUri], `totp`: EncString?, `autofillOnPageLoad`: Bool?) {
        self.`username` = `username`
        self.`password` = `password`
        self.`passwordRevisionDate` = `passwordRevisionDate`
        self.`uris` = `uris`
        self.`totp` = `totp`
        self.`autofillOnPageLoad` = `autofillOnPageLoad`
    }
}


extension Login: Equatable, Hashable {
    public static func ==(lhs: Login, rhs: Login) -> Bool {
        if lhs.`username` != rhs.`username` {
            return false
        }
        if lhs.`password` != rhs.`password` {
            return false
        }
        if lhs.`passwordRevisionDate` != rhs.`passwordRevisionDate` {
            return false
        }
        if lhs.`uris` != rhs.`uris` {
            return false
        }
        if lhs.`totp` != rhs.`totp` {
            return false
        }
        if lhs.`autofillOnPageLoad` != rhs.`autofillOnPageLoad` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`username`)
        hasher.combine(`password`)
        hasher.combine(`passwordRevisionDate`)
        hasher.combine(`uris`)
        hasher.combine(`totp`)
        hasher.combine(`autofillOnPageLoad`)
    }
}


public struct FfiConverterTypeLogin: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Login {
        return try Login(
            `username`: FfiConverterTypeEncString.read(from: &buf), 
            `password`: FfiConverterTypeEncString.read(from: &buf), 
            `passwordRevisionDate`: FfiConverterOptionTypeDateTime.read(from: &buf), 
            `uris`: FfiConverterSequenceTypeLoginUri.read(from: &buf), 
            `totp`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `autofillOnPageLoad`: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: Login, into buf: inout [UInt8]) {
        FfiConverterTypeEncString.write(value.`username`, into: &buf)
        FfiConverterTypeEncString.write(value.`password`, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.`passwordRevisionDate`, into: &buf)
        FfiConverterSequenceTypeLoginUri.write(value.`uris`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`totp`, into: &buf)
        FfiConverterOptionBool.write(value.`autofillOnPageLoad`, into: &buf)
    }
}


public func FfiConverterTypeLogin_lift(_ buf: RustBuffer) throws -> Login {
    return try FfiConverterTypeLogin.lift(buf)
}

public func FfiConverterTypeLogin_lower(_ value: Login) -> RustBuffer {
    return FfiConverterTypeLogin.lower(value)
}


public struct LoginUri {
    public var `uri`: EncString
    public var `match`: UriMatchType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`uri`: EncString, `match`: UriMatchType?) {
        self.`uri` = `uri`
        self.`match` = `match`
    }
}


extension LoginUri: Equatable, Hashable {
    public static func ==(lhs: LoginUri, rhs: LoginUri) -> Bool {
        if lhs.`uri` != rhs.`uri` {
            return false
        }
        if lhs.`match` != rhs.`match` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`uri`)
        hasher.combine(`match`)
    }
}


public struct FfiConverterTypeLoginUri: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoginUri {
        return try LoginUri(
            `uri`: FfiConverterTypeEncString.read(from: &buf), 
            `match`: FfiConverterOptionTypeUriMatchType.read(from: &buf)
        )
    }

    public static func write(_ value: LoginUri, into buf: inout [UInt8]) {
        FfiConverterTypeEncString.write(value.`uri`, into: &buf)
        FfiConverterOptionTypeUriMatchType.write(value.`match`, into: &buf)
    }
}


public func FfiConverterTypeLoginUri_lift(_ buf: RustBuffer) throws -> LoginUri {
    return try FfiConverterTypeLoginUri.lift(buf)
}

public func FfiConverterTypeLoginUri_lower(_ value: LoginUri) -> RustBuffer {
    return FfiConverterTypeLoginUri.lower(value)
}


public struct LoginUriView {
    public var `uri`: String
    public var `match`: UriMatchType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`uri`: String, `match`: UriMatchType?) {
        self.`uri` = `uri`
        self.`match` = `match`
    }
}


extension LoginUriView: Equatable, Hashable {
    public static func ==(lhs: LoginUriView, rhs: LoginUriView) -> Bool {
        if lhs.`uri` != rhs.`uri` {
            return false
        }
        if lhs.`match` != rhs.`match` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`uri`)
        hasher.combine(`match`)
    }
}


public struct FfiConverterTypeLoginUriView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoginUriView {
        return try LoginUriView(
            `uri`: FfiConverterString.read(from: &buf), 
            `match`: FfiConverterOptionTypeUriMatchType.read(from: &buf)
        )
    }

    public static func write(_ value: LoginUriView, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`uri`, into: &buf)
        FfiConverterOptionTypeUriMatchType.write(value.`match`, into: &buf)
    }
}


public func FfiConverterTypeLoginUriView_lift(_ buf: RustBuffer) throws -> LoginUriView {
    return try FfiConverterTypeLoginUriView.lift(buf)
}

public func FfiConverterTypeLoginUriView_lower(_ value: LoginUriView) -> RustBuffer {
    return FfiConverterTypeLoginUriView.lower(value)
}


public struct LoginView {
    public var `username`: String
    public var `password`: String
    public var `passwordRevisionDate`: DateTime?
    public var `uris`: [LoginUriView]
    public var `totp`: String?
    public var `autofillOnPageLoad`: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`username`: String, `password`: String, `passwordRevisionDate`: DateTime?, `uris`: [LoginUriView], `totp`: String?, `autofillOnPageLoad`: Bool?) {
        self.`username` = `username`
        self.`password` = `password`
        self.`passwordRevisionDate` = `passwordRevisionDate`
        self.`uris` = `uris`
        self.`totp` = `totp`
        self.`autofillOnPageLoad` = `autofillOnPageLoad`
    }
}


extension LoginView: Equatable, Hashable {
    public static func ==(lhs: LoginView, rhs: LoginView) -> Bool {
        if lhs.`username` != rhs.`username` {
            return false
        }
        if lhs.`password` != rhs.`password` {
            return false
        }
        if lhs.`passwordRevisionDate` != rhs.`passwordRevisionDate` {
            return false
        }
        if lhs.`uris` != rhs.`uris` {
            return false
        }
        if lhs.`totp` != rhs.`totp` {
            return false
        }
        if lhs.`autofillOnPageLoad` != rhs.`autofillOnPageLoad` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`username`)
        hasher.combine(`password`)
        hasher.combine(`passwordRevisionDate`)
        hasher.combine(`uris`)
        hasher.combine(`totp`)
        hasher.combine(`autofillOnPageLoad`)
    }
}


public struct FfiConverterTypeLoginView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoginView {
        return try LoginView(
            `username`: FfiConverterString.read(from: &buf), 
            `password`: FfiConverterString.read(from: &buf), 
            `passwordRevisionDate`: FfiConverterOptionTypeDateTime.read(from: &buf), 
            `uris`: FfiConverterSequenceTypeLoginUriView.read(from: &buf), 
            `totp`: FfiConverterOptionString.read(from: &buf), 
            `autofillOnPageLoad`: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: LoginView, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`username`, into: &buf)
        FfiConverterString.write(value.`password`, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.`passwordRevisionDate`, into: &buf)
        FfiConverterSequenceTypeLoginUriView.write(value.`uris`, into: &buf)
        FfiConverterOptionString.write(value.`totp`, into: &buf)
        FfiConverterOptionBool.write(value.`autofillOnPageLoad`, into: &buf)
    }
}


public func FfiConverterTypeLoginView_lift(_ buf: RustBuffer) throws -> LoginView {
    return try FfiConverterTypeLoginView.lift(buf)
}

public func FfiConverterTypeLoginView_lower(_ value: LoginView) -> RustBuffer {
    return FfiConverterTypeLoginView.lower(value)
}


public struct MasterPasswordPolicyOptions {
    public var `minComplexity`: UInt8
    public var `minLength`: UInt8
    public var `requireUpper`: Bool
    public var `requireLower`: Bool
    public var `requireNumbers`: Bool
    public var `requireSpecial`: Bool
    public var `enforceOnLogin`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`minComplexity`: UInt8, `minLength`: UInt8, `requireUpper`: Bool, `requireLower`: Bool, `requireNumbers`: Bool, `requireSpecial`: Bool, `enforceOnLogin`: Bool) {
        self.`minComplexity` = `minComplexity`
        self.`minLength` = `minLength`
        self.`requireUpper` = `requireUpper`
        self.`requireLower` = `requireLower`
        self.`requireNumbers` = `requireNumbers`
        self.`requireSpecial` = `requireSpecial`
        self.`enforceOnLogin` = `enforceOnLogin`
    }
}


extension MasterPasswordPolicyOptions: Equatable, Hashable {
    public static func ==(lhs: MasterPasswordPolicyOptions, rhs: MasterPasswordPolicyOptions) -> Bool {
        if lhs.`minComplexity` != rhs.`minComplexity` {
            return false
        }
        if lhs.`minLength` != rhs.`minLength` {
            return false
        }
        if lhs.`requireUpper` != rhs.`requireUpper` {
            return false
        }
        if lhs.`requireLower` != rhs.`requireLower` {
            return false
        }
        if lhs.`requireNumbers` != rhs.`requireNumbers` {
            return false
        }
        if lhs.`requireSpecial` != rhs.`requireSpecial` {
            return false
        }
        if lhs.`enforceOnLogin` != rhs.`enforceOnLogin` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`minComplexity`)
        hasher.combine(`minLength`)
        hasher.combine(`requireUpper`)
        hasher.combine(`requireLower`)
        hasher.combine(`requireNumbers`)
        hasher.combine(`requireSpecial`)
        hasher.combine(`enforceOnLogin`)
    }
}


public struct FfiConverterTypeMasterPasswordPolicyOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MasterPasswordPolicyOptions {
        return try MasterPasswordPolicyOptions(
            `minComplexity`: FfiConverterUInt8.read(from: &buf), 
            `minLength`: FfiConverterUInt8.read(from: &buf), 
            `requireUpper`: FfiConverterBool.read(from: &buf), 
            `requireLower`: FfiConverterBool.read(from: &buf), 
            `requireNumbers`: FfiConverterBool.read(from: &buf), 
            `requireSpecial`: FfiConverterBool.read(from: &buf), 
            `enforceOnLogin`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MasterPasswordPolicyOptions, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.`minComplexity`, into: &buf)
        FfiConverterUInt8.write(value.`minLength`, into: &buf)
        FfiConverterBool.write(value.`requireUpper`, into: &buf)
        FfiConverterBool.write(value.`requireLower`, into: &buf)
        FfiConverterBool.write(value.`requireNumbers`, into: &buf)
        FfiConverterBool.write(value.`requireSpecial`, into: &buf)
        FfiConverterBool.write(value.`enforceOnLogin`, into: &buf)
    }
}


public func FfiConverterTypeMasterPasswordPolicyOptions_lift(_ buf: RustBuffer) throws -> MasterPasswordPolicyOptions {
    return try FfiConverterTypeMasterPasswordPolicyOptions.lift(buf)
}

public func FfiConverterTypeMasterPasswordPolicyOptions_lower(_ value: MasterPasswordPolicyOptions) -> RustBuffer {
    return FfiConverterTypeMasterPasswordPolicyOptions.lower(value)
}


public struct PassphraseGeneratorRequest {
    public var `numWords`: UInt8?
    public var `wordSeparator`: String?
    public var `capitalize`: Bool?
    public var `includeNumber`: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`numWords`: UInt8?, `wordSeparator`: String?, `capitalize`: Bool?, `includeNumber`: Bool?) {
        self.`numWords` = `numWords`
        self.`wordSeparator` = `wordSeparator`
        self.`capitalize` = `capitalize`
        self.`includeNumber` = `includeNumber`
    }
}


extension PassphraseGeneratorRequest: Equatable, Hashable {
    public static func ==(lhs: PassphraseGeneratorRequest, rhs: PassphraseGeneratorRequest) -> Bool {
        if lhs.`numWords` != rhs.`numWords` {
            return false
        }
        if lhs.`wordSeparator` != rhs.`wordSeparator` {
            return false
        }
        if lhs.`capitalize` != rhs.`capitalize` {
            return false
        }
        if lhs.`includeNumber` != rhs.`includeNumber` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`numWords`)
        hasher.combine(`wordSeparator`)
        hasher.combine(`capitalize`)
        hasher.combine(`includeNumber`)
    }
}


public struct FfiConverterTypePassphraseGeneratorRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PassphraseGeneratorRequest {
        return try PassphraseGeneratorRequest(
            `numWords`: FfiConverterOptionUInt8.read(from: &buf), 
            `wordSeparator`: FfiConverterOptionString.read(from: &buf), 
            `capitalize`: FfiConverterOptionBool.read(from: &buf), 
            `includeNumber`: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: PassphraseGeneratorRequest, into buf: inout [UInt8]) {
        FfiConverterOptionUInt8.write(value.`numWords`, into: &buf)
        FfiConverterOptionString.write(value.`wordSeparator`, into: &buf)
        FfiConverterOptionBool.write(value.`capitalize`, into: &buf)
        FfiConverterOptionBool.write(value.`includeNumber`, into: &buf)
    }
}


public func FfiConverterTypePassphraseGeneratorRequest_lift(_ buf: RustBuffer) throws -> PassphraseGeneratorRequest {
    return try FfiConverterTypePassphraseGeneratorRequest.lift(buf)
}

public func FfiConverterTypePassphraseGeneratorRequest_lower(_ value: PassphraseGeneratorRequest) -> RustBuffer {
    return FfiConverterTypePassphraseGeneratorRequest.lower(value)
}


public struct PasswordGeneratorRequest {
    public var `lowercase`: Bool
    public var `uppercase`: Bool
    public var `numbers`: Bool
    public var `special`: Bool
    public var `length`: UInt8?
    public var `avoidAmbiguous`: Bool?
    public var `minLowercase`: Bool?
    public var `minUppercase`: Bool?
    public var `minNumber`: Bool?
    public var `minSpecial`: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`lowercase`: Bool, `uppercase`: Bool, `numbers`: Bool, `special`: Bool, `length`: UInt8?, `avoidAmbiguous`: Bool?, `minLowercase`: Bool?, `minUppercase`: Bool?, `minNumber`: Bool?, `minSpecial`: Bool?) {
        self.`lowercase` = `lowercase`
        self.`uppercase` = `uppercase`
        self.`numbers` = `numbers`
        self.`special` = `special`
        self.`length` = `length`
        self.`avoidAmbiguous` = `avoidAmbiguous`
        self.`minLowercase` = `minLowercase`
        self.`minUppercase` = `minUppercase`
        self.`minNumber` = `minNumber`
        self.`minSpecial` = `minSpecial`
    }
}


extension PasswordGeneratorRequest: Equatable, Hashable {
    public static func ==(lhs: PasswordGeneratorRequest, rhs: PasswordGeneratorRequest) -> Bool {
        if lhs.`lowercase` != rhs.`lowercase` {
            return false
        }
        if lhs.`uppercase` != rhs.`uppercase` {
            return false
        }
        if lhs.`numbers` != rhs.`numbers` {
            return false
        }
        if lhs.`special` != rhs.`special` {
            return false
        }
        if lhs.`length` != rhs.`length` {
            return false
        }
        if lhs.`avoidAmbiguous` != rhs.`avoidAmbiguous` {
            return false
        }
        if lhs.`minLowercase` != rhs.`minLowercase` {
            return false
        }
        if lhs.`minUppercase` != rhs.`minUppercase` {
            return false
        }
        if lhs.`minNumber` != rhs.`minNumber` {
            return false
        }
        if lhs.`minSpecial` != rhs.`minSpecial` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`lowercase`)
        hasher.combine(`uppercase`)
        hasher.combine(`numbers`)
        hasher.combine(`special`)
        hasher.combine(`length`)
        hasher.combine(`avoidAmbiguous`)
        hasher.combine(`minLowercase`)
        hasher.combine(`minUppercase`)
        hasher.combine(`minNumber`)
        hasher.combine(`minSpecial`)
    }
}


public struct FfiConverterTypePasswordGeneratorRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PasswordGeneratorRequest {
        return try PasswordGeneratorRequest(
            `lowercase`: FfiConverterBool.read(from: &buf), 
            `uppercase`: FfiConverterBool.read(from: &buf), 
            `numbers`: FfiConverterBool.read(from: &buf), 
            `special`: FfiConverterBool.read(from: &buf), 
            `length`: FfiConverterOptionUInt8.read(from: &buf), 
            `avoidAmbiguous`: FfiConverterOptionBool.read(from: &buf), 
            `minLowercase`: FfiConverterOptionBool.read(from: &buf), 
            `minUppercase`: FfiConverterOptionBool.read(from: &buf), 
            `minNumber`: FfiConverterOptionBool.read(from: &buf), 
            `minSpecial`: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: PasswordGeneratorRequest, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`lowercase`, into: &buf)
        FfiConverterBool.write(value.`uppercase`, into: &buf)
        FfiConverterBool.write(value.`numbers`, into: &buf)
        FfiConverterBool.write(value.`special`, into: &buf)
        FfiConverterOptionUInt8.write(value.`length`, into: &buf)
        FfiConverterOptionBool.write(value.`avoidAmbiguous`, into: &buf)
        FfiConverterOptionBool.write(value.`minLowercase`, into: &buf)
        FfiConverterOptionBool.write(value.`minUppercase`, into: &buf)
        FfiConverterOptionBool.write(value.`minNumber`, into: &buf)
        FfiConverterOptionBool.write(value.`minSpecial`, into: &buf)
    }
}


public func FfiConverterTypePasswordGeneratorRequest_lift(_ buf: RustBuffer) throws -> PasswordGeneratorRequest {
    return try FfiConverterTypePasswordGeneratorRequest.lift(buf)
}

public func FfiConverterTypePasswordGeneratorRequest_lower(_ value: PasswordGeneratorRequest) -> RustBuffer {
    return FfiConverterTypePasswordGeneratorRequest.lower(value)
}


public struct PasswordHistory {
    public var `password`: EncString
    public var `lastUsedDate`: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`password`: EncString, `lastUsedDate`: DateTime) {
        self.`password` = `password`
        self.`lastUsedDate` = `lastUsedDate`
    }
}


extension PasswordHistory: Equatable, Hashable {
    public static func ==(lhs: PasswordHistory, rhs: PasswordHistory) -> Bool {
        if lhs.`password` != rhs.`password` {
            return false
        }
        if lhs.`lastUsedDate` != rhs.`lastUsedDate` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`password`)
        hasher.combine(`lastUsedDate`)
    }
}


public struct FfiConverterTypePasswordHistory: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PasswordHistory {
        return try PasswordHistory(
            `password`: FfiConverterTypeEncString.read(from: &buf), 
            `lastUsedDate`: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: PasswordHistory, into buf: inout [UInt8]) {
        FfiConverterTypeEncString.write(value.`password`, into: &buf)
        FfiConverterTypeDateTime.write(value.`lastUsedDate`, into: &buf)
    }
}


public func FfiConverterTypePasswordHistory_lift(_ buf: RustBuffer) throws -> PasswordHistory {
    return try FfiConverterTypePasswordHistory.lift(buf)
}

public func FfiConverterTypePasswordHistory_lower(_ value: PasswordHistory) -> RustBuffer {
    return FfiConverterTypePasswordHistory.lower(value)
}


public struct PasswordHistoryView {
    public var `password`: String
    public var `lastUsedDate`: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`password`: String, `lastUsedDate`: DateTime) {
        self.`password` = `password`
        self.`lastUsedDate` = `lastUsedDate`
    }
}


extension PasswordHistoryView: Equatable, Hashable {
    public static func ==(lhs: PasswordHistoryView, rhs: PasswordHistoryView) -> Bool {
        if lhs.`password` != rhs.`password` {
            return false
        }
        if lhs.`lastUsedDate` != rhs.`lastUsedDate` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`password`)
        hasher.combine(`lastUsedDate`)
    }
}


public struct FfiConverterTypePasswordHistoryView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PasswordHistoryView {
        return try PasswordHistoryView(
            `password`: FfiConverterString.read(from: &buf), 
            `lastUsedDate`: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: PasswordHistoryView, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`password`, into: &buf)
        FfiConverterTypeDateTime.write(value.`lastUsedDate`, into: &buf)
    }
}


public func FfiConverterTypePasswordHistoryView_lift(_ buf: RustBuffer) throws -> PasswordHistoryView {
    return try FfiConverterTypePasswordHistoryView.lift(buf)
}

public func FfiConverterTypePasswordHistoryView_lower(_ value: PasswordHistoryView) -> RustBuffer {
    return FfiConverterTypePasswordHistoryView.lower(value)
}


public struct RegisterKeyResponse {
    public var `masterPasswordHash`: String
    public var `encryptedUserKey`: String
    public var `keys`: RsaKeyPair

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`masterPasswordHash`: String, `encryptedUserKey`: String, `keys`: RsaKeyPair) {
        self.`masterPasswordHash` = `masterPasswordHash`
        self.`encryptedUserKey` = `encryptedUserKey`
        self.`keys` = `keys`
    }
}


extension RegisterKeyResponse: Equatable, Hashable {
    public static func ==(lhs: RegisterKeyResponse, rhs: RegisterKeyResponse) -> Bool {
        if lhs.`masterPasswordHash` != rhs.`masterPasswordHash` {
            return false
        }
        if lhs.`encryptedUserKey` != rhs.`encryptedUserKey` {
            return false
        }
        if lhs.`keys` != rhs.`keys` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`masterPasswordHash`)
        hasher.combine(`encryptedUserKey`)
        hasher.combine(`keys`)
    }
}


public struct FfiConverterTypeRegisterKeyResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RegisterKeyResponse {
        return try RegisterKeyResponse(
            `masterPasswordHash`: FfiConverterString.read(from: &buf), 
            `encryptedUserKey`: FfiConverterString.read(from: &buf), 
            `keys`: FfiConverterTypeRsaKeyPair.read(from: &buf)
        )
    }

    public static func write(_ value: RegisterKeyResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`masterPasswordHash`, into: &buf)
        FfiConverterString.write(value.`encryptedUserKey`, into: &buf)
        FfiConverterTypeRsaKeyPair.write(value.`keys`, into: &buf)
    }
}


public func FfiConverterTypeRegisterKeyResponse_lift(_ buf: RustBuffer) throws -> RegisterKeyResponse {
    return try FfiConverterTypeRegisterKeyResponse.lift(buf)
}

public func FfiConverterTypeRegisterKeyResponse_lower(_ value: RegisterKeyResponse) -> RustBuffer {
    return FfiConverterTypeRegisterKeyResponse.lower(value)
}


public struct RsaKeyPair {
    public var `public`: String
    public var `private`: EncString

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`public`: String, `private`: EncString) {
        self.`public` = `public`
        self.`private` = `private`
    }
}


extension RsaKeyPair: Equatable, Hashable {
    public static func ==(lhs: RsaKeyPair, rhs: RsaKeyPair) -> Bool {
        if lhs.`public` != rhs.`public` {
            return false
        }
        if lhs.`private` != rhs.`private` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`public`)
        hasher.combine(`private`)
    }
}


public struct FfiConverterTypeRsaKeyPair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RsaKeyPair {
        return try RsaKeyPair(
            `public`: FfiConverterString.read(from: &buf), 
            `private`: FfiConverterTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: RsaKeyPair, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`public`, into: &buf)
        FfiConverterTypeEncString.write(value.`private`, into: &buf)
    }
}


public func FfiConverterTypeRsaKeyPair_lift(_ buf: RustBuffer) throws -> RsaKeyPair {
    return try FfiConverterTypeRsaKeyPair.lift(buf)
}

public func FfiConverterTypeRsaKeyPair_lower(_ value: RsaKeyPair) -> RustBuffer {
    return FfiConverterTypeRsaKeyPair.lower(value)
}


public struct SecureNote {
    public var `type`: SecureNoteType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`type`: SecureNoteType) {
        self.`type` = `type`
    }
}


extension SecureNote: Equatable, Hashable {
    public static func ==(lhs: SecureNote, rhs: SecureNote) -> Bool {
        if lhs.`type` != rhs.`type` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`type`)
    }
}


public struct FfiConverterTypeSecureNote: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureNote {
        return try SecureNote(
            `type`: FfiConverterTypeSecureNoteType.read(from: &buf)
        )
    }

    public static func write(_ value: SecureNote, into buf: inout [UInt8]) {
        FfiConverterTypeSecureNoteType.write(value.`type`, into: &buf)
    }
}


public func FfiConverterTypeSecureNote_lift(_ buf: RustBuffer) throws -> SecureNote {
    return try FfiConverterTypeSecureNote.lift(buf)
}

public func FfiConverterTypeSecureNote_lower(_ value: SecureNote) -> RustBuffer {
    return FfiConverterTypeSecureNote.lower(value)
}


public struct SecureNoteView {
    public var `type`: SecureNoteType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`type`: SecureNoteType) {
        self.`type` = `type`
    }
}


extension SecureNoteView: Equatable, Hashable {
    public static func ==(lhs: SecureNoteView, rhs: SecureNoteView) -> Bool {
        if lhs.`type` != rhs.`type` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`type`)
    }
}


public struct FfiConverterTypeSecureNoteView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureNoteView {
        return try SecureNoteView(
            `type`: FfiConverterTypeSecureNoteType.read(from: &buf)
        )
    }

    public static func write(_ value: SecureNoteView, into buf: inout [UInt8]) {
        FfiConverterTypeSecureNoteType.write(value.`type`, into: &buf)
    }
}


public func FfiConverterTypeSecureNoteView_lift(_ buf: RustBuffer) throws -> SecureNoteView {
    return try FfiConverterTypeSecureNoteView.lift(buf)
}

public func FfiConverterTypeSecureNoteView_lower(_ value: SecureNoteView) -> RustBuffer {
    return FfiConverterTypeSecureNoteView.lower(value)
}


public struct Send {
    public var `id`: Uuid
    public var `accessId`: String
    public var `name`: EncString
    public var `notes`: EncString?
    public var `key`: EncString
    public var `password`: String?
    public var `type`: SendType
    public var `file`: SendFile?
    public var `text`: SendText?
    public var `maxAccessCount`: UInt32?
    public var `accessCount`: UInt32
    public var `disabled`: Bool
    public var `hideEmail`: Bool
    public var `revisionDate`: DateTime
    public var `deletionDate`: DateTime
    public var `expirationDate`: DateTime?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: Uuid, `accessId`: String, `name`: EncString, `notes`: EncString?, `key`: EncString, `password`: String?, `type`: SendType, `file`: SendFile?, `text`: SendText?, `maxAccessCount`: UInt32?, `accessCount`: UInt32, `disabled`: Bool, `hideEmail`: Bool, `revisionDate`: DateTime, `deletionDate`: DateTime, `expirationDate`: DateTime?) {
        self.`id` = `id`
        self.`accessId` = `accessId`
        self.`name` = `name`
        self.`notes` = `notes`
        self.`key` = `key`
        self.`password` = `password`
        self.`type` = `type`
        self.`file` = `file`
        self.`text` = `text`
        self.`maxAccessCount` = `maxAccessCount`
        self.`accessCount` = `accessCount`
        self.`disabled` = `disabled`
        self.`hideEmail` = `hideEmail`
        self.`revisionDate` = `revisionDate`
        self.`deletionDate` = `deletionDate`
        self.`expirationDate` = `expirationDate`
    }
}


extension Send: Equatable, Hashable {
    public static func ==(lhs: Send, rhs: Send) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`accessId` != rhs.`accessId` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`notes` != rhs.`notes` {
            return false
        }
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`password` != rhs.`password` {
            return false
        }
        if lhs.`type` != rhs.`type` {
            return false
        }
        if lhs.`file` != rhs.`file` {
            return false
        }
        if lhs.`text` != rhs.`text` {
            return false
        }
        if lhs.`maxAccessCount` != rhs.`maxAccessCount` {
            return false
        }
        if lhs.`accessCount` != rhs.`accessCount` {
            return false
        }
        if lhs.`disabled` != rhs.`disabled` {
            return false
        }
        if lhs.`hideEmail` != rhs.`hideEmail` {
            return false
        }
        if lhs.`revisionDate` != rhs.`revisionDate` {
            return false
        }
        if lhs.`deletionDate` != rhs.`deletionDate` {
            return false
        }
        if lhs.`expirationDate` != rhs.`expirationDate` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`accessId`)
        hasher.combine(`name`)
        hasher.combine(`notes`)
        hasher.combine(`key`)
        hasher.combine(`password`)
        hasher.combine(`type`)
        hasher.combine(`file`)
        hasher.combine(`text`)
        hasher.combine(`maxAccessCount`)
        hasher.combine(`accessCount`)
        hasher.combine(`disabled`)
        hasher.combine(`hideEmail`)
        hasher.combine(`revisionDate`)
        hasher.combine(`deletionDate`)
        hasher.combine(`expirationDate`)
    }
}


public struct FfiConverterTypeSend: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Send {
        return try Send(
            `id`: FfiConverterTypeUuid.read(from: &buf), 
            `accessId`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterTypeEncString.read(from: &buf), 
            `notes`: FfiConverterOptionTypeEncString.read(from: &buf), 
            `key`: FfiConverterTypeEncString.read(from: &buf), 
            `password`: FfiConverterOptionString.read(from: &buf), 
            `type`: FfiConverterTypeSendType.read(from: &buf), 
            `file`: FfiConverterOptionTypeSendFile.read(from: &buf), 
            `text`: FfiConverterOptionTypeSendText.read(from: &buf), 
            `maxAccessCount`: FfiConverterOptionUInt32.read(from: &buf), 
            `accessCount`: FfiConverterUInt32.read(from: &buf), 
            `disabled`: FfiConverterBool.read(from: &buf), 
            `hideEmail`: FfiConverterBool.read(from: &buf), 
            `revisionDate`: FfiConverterTypeDateTime.read(from: &buf), 
            `deletionDate`: FfiConverterTypeDateTime.read(from: &buf), 
            `expirationDate`: FfiConverterOptionTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: Send, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`accessId`, into: &buf)
        FfiConverterTypeEncString.write(value.`name`, into: &buf)
        FfiConverterOptionTypeEncString.write(value.`notes`, into: &buf)
        FfiConverterTypeEncString.write(value.`key`, into: &buf)
        FfiConverterOptionString.write(value.`password`, into: &buf)
        FfiConverterTypeSendType.write(value.`type`, into: &buf)
        FfiConverterOptionTypeSendFile.write(value.`file`, into: &buf)
        FfiConverterOptionTypeSendText.write(value.`text`, into: &buf)
        FfiConverterOptionUInt32.write(value.`maxAccessCount`, into: &buf)
        FfiConverterUInt32.write(value.`accessCount`, into: &buf)
        FfiConverterBool.write(value.`disabled`, into: &buf)
        FfiConverterBool.write(value.`hideEmail`, into: &buf)
        FfiConverterTypeDateTime.write(value.`revisionDate`, into: &buf)
        FfiConverterTypeDateTime.write(value.`deletionDate`, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.`expirationDate`, into: &buf)
    }
}


public func FfiConverterTypeSend_lift(_ buf: RustBuffer) throws -> Send {
    return try FfiConverterTypeSend.lift(buf)
}

public func FfiConverterTypeSend_lower(_ value: Send) -> RustBuffer {
    return FfiConverterTypeSend.lower(value)
}


public struct SendFile {
    public var `id`: String
    public var `fileName`: EncString
    public var `size`: String
    public var `sizeName`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `fileName`: EncString, `size`: String, `sizeName`: String) {
        self.`id` = `id`
        self.`fileName` = `fileName`
        self.`size` = `size`
        self.`sizeName` = `sizeName`
    }
}


extension SendFile: Equatable, Hashable {
    public static func ==(lhs: SendFile, rhs: SendFile) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`fileName` != rhs.`fileName` {
            return false
        }
        if lhs.`size` != rhs.`size` {
            return false
        }
        if lhs.`sizeName` != rhs.`sizeName` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`fileName`)
        hasher.combine(`size`)
        hasher.combine(`sizeName`)
    }
}


public struct FfiConverterTypeSendFile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFile {
        return try SendFile(
            `id`: FfiConverterString.read(from: &buf), 
            `fileName`: FfiConverterTypeEncString.read(from: &buf), 
            `size`: FfiConverterString.read(from: &buf), 
            `sizeName`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SendFile, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterTypeEncString.write(value.`fileName`, into: &buf)
        FfiConverterString.write(value.`size`, into: &buf)
        FfiConverterString.write(value.`sizeName`, into: &buf)
    }
}


public func FfiConverterTypeSendFile_lift(_ buf: RustBuffer) throws -> SendFile {
    return try FfiConverterTypeSendFile.lift(buf)
}

public func FfiConverterTypeSendFile_lower(_ value: SendFile) -> RustBuffer {
    return FfiConverterTypeSendFile.lower(value)
}


public struct SendFileView {
    public var `id`: String
    public var `fileName`: String
    public var `size`: String
    public var `sizeName`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `fileName`: String, `size`: String, `sizeName`: String) {
        self.`id` = `id`
        self.`fileName` = `fileName`
        self.`size` = `size`
        self.`sizeName` = `sizeName`
    }
}


extension SendFileView: Equatable, Hashable {
    public static func ==(lhs: SendFileView, rhs: SendFileView) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`fileName` != rhs.`fileName` {
            return false
        }
        if lhs.`size` != rhs.`size` {
            return false
        }
        if lhs.`sizeName` != rhs.`sizeName` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`fileName`)
        hasher.combine(`size`)
        hasher.combine(`sizeName`)
    }
}


public struct FfiConverterTypeSendFileView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendFileView {
        return try SendFileView(
            `id`: FfiConverterString.read(from: &buf), 
            `fileName`: FfiConverterString.read(from: &buf), 
            `size`: FfiConverterString.read(from: &buf), 
            `sizeName`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SendFileView, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`fileName`, into: &buf)
        FfiConverterString.write(value.`size`, into: &buf)
        FfiConverterString.write(value.`sizeName`, into: &buf)
    }
}


public func FfiConverterTypeSendFileView_lift(_ buf: RustBuffer) throws -> SendFileView {
    return try FfiConverterTypeSendFileView.lift(buf)
}

public func FfiConverterTypeSendFileView_lower(_ value: SendFileView) -> RustBuffer {
    return FfiConverterTypeSendFileView.lower(value)
}


public struct SendListView {
    public var `id`: Uuid
    public var `accessId`: String
    public var `name`: String
    public var `type`: SendType
    public var `disabled`: Bool
    public var `revisionDate`: DateTime
    public var `deletionDate`: DateTime
    public var `expirationDate`: DateTime?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: Uuid, `accessId`: String, `name`: String, `type`: SendType, `disabled`: Bool, `revisionDate`: DateTime, `deletionDate`: DateTime, `expirationDate`: DateTime?) {
        self.`id` = `id`
        self.`accessId` = `accessId`
        self.`name` = `name`
        self.`type` = `type`
        self.`disabled` = `disabled`
        self.`revisionDate` = `revisionDate`
        self.`deletionDate` = `deletionDate`
        self.`expirationDate` = `expirationDate`
    }
}


extension SendListView: Equatable, Hashable {
    public static func ==(lhs: SendListView, rhs: SendListView) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`accessId` != rhs.`accessId` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`type` != rhs.`type` {
            return false
        }
        if lhs.`disabled` != rhs.`disabled` {
            return false
        }
        if lhs.`revisionDate` != rhs.`revisionDate` {
            return false
        }
        if lhs.`deletionDate` != rhs.`deletionDate` {
            return false
        }
        if lhs.`expirationDate` != rhs.`expirationDate` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`accessId`)
        hasher.combine(`name`)
        hasher.combine(`type`)
        hasher.combine(`disabled`)
        hasher.combine(`revisionDate`)
        hasher.combine(`deletionDate`)
        hasher.combine(`expirationDate`)
    }
}


public struct FfiConverterTypeSendListView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendListView {
        return try SendListView(
            `id`: FfiConverterTypeUuid.read(from: &buf), 
            `accessId`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `type`: FfiConverterTypeSendType.read(from: &buf), 
            `disabled`: FfiConverterBool.read(from: &buf), 
            `revisionDate`: FfiConverterTypeDateTime.read(from: &buf), 
            `deletionDate`: FfiConverterTypeDateTime.read(from: &buf), 
            `expirationDate`: FfiConverterOptionTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: SendListView, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`accessId`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterTypeSendType.write(value.`type`, into: &buf)
        FfiConverterBool.write(value.`disabled`, into: &buf)
        FfiConverterTypeDateTime.write(value.`revisionDate`, into: &buf)
        FfiConverterTypeDateTime.write(value.`deletionDate`, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.`expirationDate`, into: &buf)
    }
}


public func FfiConverterTypeSendListView_lift(_ buf: RustBuffer) throws -> SendListView {
    return try FfiConverterTypeSendListView.lift(buf)
}

public func FfiConverterTypeSendListView_lower(_ value: SendListView) -> RustBuffer {
    return FfiConverterTypeSendListView.lower(value)
}


public struct SendText {
    public var `text`: EncString
    public var `hidden`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`text`: EncString, `hidden`: Bool) {
        self.`text` = `text`
        self.`hidden` = `hidden`
    }
}


extension SendText: Equatable, Hashable {
    public static func ==(lhs: SendText, rhs: SendText) -> Bool {
        if lhs.`text` != rhs.`text` {
            return false
        }
        if lhs.`hidden` != rhs.`hidden` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`text`)
        hasher.combine(`hidden`)
    }
}


public struct FfiConverterTypeSendText: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendText {
        return try SendText(
            `text`: FfiConverterTypeEncString.read(from: &buf), 
            `hidden`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SendText, into buf: inout [UInt8]) {
        FfiConverterTypeEncString.write(value.`text`, into: &buf)
        FfiConverterBool.write(value.`hidden`, into: &buf)
    }
}


public func FfiConverterTypeSendText_lift(_ buf: RustBuffer) throws -> SendText {
    return try FfiConverterTypeSendText.lift(buf)
}

public func FfiConverterTypeSendText_lower(_ value: SendText) -> RustBuffer {
    return FfiConverterTypeSendText.lower(value)
}


public struct SendTextView {
    public var `text`: String
    public var `hidden`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`text`: String, `hidden`: Bool) {
        self.`text` = `text`
        self.`hidden` = `hidden`
    }
}


extension SendTextView: Equatable, Hashable {
    public static func ==(lhs: SendTextView, rhs: SendTextView) -> Bool {
        if lhs.`text` != rhs.`text` {
            return false
        }
        if lhs.`hidden` != rhs.`hidden` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`text`)
        hasher.combine(`hidden`)
    }
}


public struct FfiConverterTypeSendTextView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendTextView {
        return try SendTextView(
            `text`: FfiConverterString.read(from: &buf), 
            `hidden`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SendTextView, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`text`, into: &buf)
        FfiConverterBool.write(value.`hidden`, into: &buf)
    }
}


public func FfiConverterTypeSendTextView_lift(_ buf: RustBuffer) throws -> SendTextView {
    return try FfiConverterTypeSendTextView.lift(buf)
}

public func FfiConverterTypeSendTextView_lower(_ value: SendTextView) -> RustBuffer {
    return FfiConverterTypeSendTextView.lower(value)
}


public struct SendView {
    public var `id`: Uuid
    public var `accessId`: String
    public var `name`: String
    public var `notes`: String?
    public var `key`: EncString
    public var `password`: String?
    public var `type`: SendType
    public var `file`: SendFileView?
    public var `text`: SendTextView?
    public var `maxAccessCount`: UInt32?
    public var `accessCount`: UInt32
    public var `disabled`: Bool
    public var `hideEmail`: Bool
    public var `revisionDate`: DateTime
    public var `deletionDate`: DateTime
    public var `expirationDate`: DateTime?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: Uuid, `accessId`: String, `name`: String, `notes`: String?, `key`: EncString, `password`: String?, `type`: SendType, `file`: SendFileView?, `text`: SendTextView?, `maxAccessCount`: UInt32?, `accessCount`: UInt32, `disabled`: Bool, `hideEmail`: Bool, `revisionDate`: DateTime, `deletionDate`: DateTime, `expirationDate`: DateTime?) {
        self.`id` = `id`
        self.`accessId` = `accessId`
        self.`name` = `name`
        self.`notes` = `notes`
        self.`key` = `key`
        self.`password` = `password`
        self.`type` = `type`
        self.`file` = `file`
        self.`text` = `text`
        self.`maxAccessCount` = `maxAccessCount`
        self.`accessCount` = `accessCount`
        self.`disabled` = `disabled`
        self.`hideEmail` = `hideEmail`
        self.`revisionDate` = `revisionDate`
        self.`deletionDate` = `deletionDate`
        self.`expirationDate` = `expirationDate`
    }
}


extension SendView: Equatable, Hashable {
    public static func ==(lhs: SendView, rhs: SendView) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`accessId` != rhs.`accessId` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`notes` != rhs.`notes` {
            return false
        }
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`password` != rhs.`password` {
            return false
        }
        if lhs.`type` != rhs.`type` {
            return false
        }
        if lhs.`file` != rhs.`file` {
            return false
        }
        if lhs.`text` != rhs.`text` {
            return false
        }
        if lhs.`maxAccessCount` != rhs.`maxAccessCount` {
            return false
        }
        if lhs.`accessCount` != rhs.`accessCount` {
            return false
        }
        if lhs.`disabled` != rhs.`disabled` {
            return false
        }
        if lhs.`hideEmail` != rhs.`hideEmail` {
            return false
        }
        if lhs.`revisionDate` != rhs.`revisionDate` {
            return false
        }
        if lhs.`deletionDate` != rhs.`deletionDate` {
            return false
        }
        if lhs.`expirationDate` != rhs.`expirationDate` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`accessId`)
        hasher.combine(`name`)
        hasher.combine(`notes`)
        hasher.combine(`key`)
        hasher.combine(`password`)
        hasher.combine(`type`)
        hasher.combine(`file`)
        hasher.combine(`text`)
        hasher.combine(`maxAccessCount`)
        hasher.combine(`accessCount`)
        hasher.combine(`disabled`)
        hasher.combine(`hideEmail`)
        hasher.combine(`revisionDate`)
        hasher.combine(`deletionDate`)
        hasher.combine(`expirationDate`)
    }
}


public struct FfiConverterTypeSendView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendView {
        return try SendView(
            `id`: FfiConverterTypeUuid.read(from: &buf), 
            `accessId`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `notes`: FfiConverterOptionString.read(from: &buf), 
            `key`: FfiConverterTypeEncString.read(from: &buf), 
            `password`: FfiConverterOptionString.read(from: &buf), 
            `type`: FfiConverterTypeSendType.read(from: &buf), 
            `file`: FfiConverterOptionTypeSendFileView.read(from: &buf), 
            `text`: FfiConverterOptionTypeSendTextView.read(from: &buf), 
            `maxAccessCount`: FfiConverterOptionUInt32.read(from: &buf), 
            `accessCount`: FfiConverterUInt32.read(from: &buf), 
            `disabled`: FfiConverterBool.read(from: &buf), 
            `hideEmail`: FfiConverterBool.read(from: &buf), 
            `revisionDate`: FfiConverterTypeDateTime.read(from: &buf), 
            `deletionDate`: FfiConverterTypeDateTime.read(from: &buf), 
            `expirationDate`: FfiConverterOptionTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: SendView, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`accessId`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterOptionString.write(value.`notes`, into: &buf)
        FfiConverterTypeEncString.write(value.`key`, into: &buf)
        FfiConverterOptionString.write(value.`password`, into: &buf)
        FfiConverterTypeSendType.write(value.`type`, into: &buf)
        FfiConverterOptionTypeSendFileView.write(value.`file`, into: &buf)
        FfiConverterOptionTypeSendTextView.write(value.`text`, into: &buf)
        FfiConverterOptionUInt32.write(value.`maxAccessCount`, into: &buf)
        FfiConverterUInt32.write(value.`accessCount`, into: &buf)
        FfiConverterBool.write(value.`disabled`, into: &buf)
        FfiConverterBool.write(value.`hideEmail`, into: &buf)
        FfiConverterTypeDateTime.write(value.`revisionDate`, into: &buf)
        FfiConverterTypeDateTime.write(value.`deletionDate`, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.`expirationDate`, into: &buf)
    }
}


public func FfiConverterTypeSendView_lift(_ buf: RustBuffer) throws -> SendView {
    return try FfiConverterTypeSendView.lift(buf)
}

public func FfiConverterTypeSendView_lower(_ value: SendView) -> RustBuffer {
    return FfiConverterTypeSendView.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum CipherRepromptType {
    
    case `none`
    case `password`
}

public struct FfiConverterTypeCipherRepromptType: FfiConverterRustBuffer {
    typealias SwiftType = CipherRepromptType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherRepromptType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`none`
        
        case 2: return .`password`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CipherRepromptType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`none`:
            writeInt(&buf, Int32(1))
        
        
        case .`password`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeCipherRepromptType_lift(_ buf: RustBuffer) throws -> CipherRepromptType {
    return try FfiConverterTypeCipherRepromptType.lift(buf)
}

public func FfiConverterTypeCipherRepromptType_lower(_ value: CipherRepromptType) -> RustBuffer {
    return FfiConverterTypeCipherRepromptType.lower(value)
}


extension CipherRepromptType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum CipherType {
    
    case `login`
    case `secureNote`
    case `card`
    case `identity`
}

public struct FfiConverterTypeCipherType: FfiConverterRustBuffer {
    typealias SwiftType = CipherType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`login`
        
        case 2: return .`secureNote`
        
        case 3: return .`card`
        
        case 4: return .`identity`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CipherType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`login`:
            writeInt(&buf, Int32(1))
        
        
        case .`secureNote`:
            writeInt(&buf, Int32(2))
        
        
        case .`card`:
            writeInt(&buf, Int32(3))
        
        
        case .`identity`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeCipherType_lift(_ buf: RustBuffer) throws -> CipherType {
    return try FfiConverterTypeCipherType.lift(buf)
}

public func FfiConverterTypeCipherType_lower(_ value: CipherType) -> RustBuffer {
    return FfiConverterTypeCipherType.lower(value)
}


extension CipherType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DeviceType {
    
    case `android`
    case `iOs`
    case `chromeExtension`
    case `firefoxExtension`
    case `operaExtension`
    case `edgeExtension`
    case `windowsDesktop`
    case `macOsDesktop`
    case `linuxDesktop`
    case `chromeBrowser`
    case `firefoxBrowser`
    case `operaBrowser`
    case `edgeBrowser`
    case `ieBrowser`
    case `unknownBrowser`
    case `androidAmazon`
    case `uwp`
    case `safariBrowser`
    case `vivaldiBrowser`
    case `vivaldiExtension`
    case `safariExtension`
    case `sdk`
}

public struct FfiConverterTypeDeviceType: FfiConverterRustBuffer {
    typealias SwiftType = DeviceType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`android`
        
        case 2: return .`iOs`
        
        case 3: return .`chromeExtension`
        
        case 4: return .`firefoxExtension`
        
        case 5: return .`operaExtension`
        
        case 6: return .`edgeExtension`
        
        case 7: return .`windowsDesktop`
        
        case 8: return .`macOsDesktop`
        
        case 9: return .`linuxDesktop`
        
        case 10: return .`chromeBrowser`
        
        case 11: return .`firefoxBrowser`
        
        case 12: return .`operaBrowser`
        
        case 13: return .`edgeBrowser`
        
        case 14: return .`ieBrowser`
        
        case 15: return .`unknownBrowser`
        
        case 16: return .`androidAmazon`
        
        case 17: return .`uwp`
        
        case 18: return .`safariBrowser`
        
        case 19: return .`vivaldiBrowser`
        
        case 20: return .`vivaldiExtension`
        
        case 21: return .`safariExtension`
        
        case 22: return .`sdk`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DeviceType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`android`:
            writeInt(&buf, Int32(1))
        
        
        case .`iOs`:
            writeInt(&buf, Int32(2))
        
        
        case .`chromeExtension`:
            writeInt(&buf, Int32(3))
        
        
        case .`firefoxExtension`:
            writeInt(&buf, Int32(4))
        
        
        case .`operaExtension`:
            writeInt(&buf, Int32(5))
        
        
        case .`edgeExtension`:
            writeInt(&buf, Int32(6))
        
        
        case .`windowsDesktop`:
            writeInt(&buf, Int32(7))
        
        
        case .`macOsDesktop`:
            writeInt(&buf, Int32(8))
        
        
        case .`linuxDesktop`:
            writeInt(&buf, Int32(9))
        
        
        case .`chromeBrowser`:
            writeInt(&buf, Int32(10))
        
        
        case .`firefoxBrowser`:
            writeInt(&buf, Int32(11))
        
        
        case .`operaBrowser`:
            writeInt(&buf, Int32(12))
        
        
        case .`edgeBrowser`:
            writeInt(&buf, Int32(13))
        
        
        case .`ieBrowser`:
            writeInt(&buf, Int32(14))
        
        
        case .`unknownBrowser`:
            writeInt(&buf, Int32(15))
        
        
        case .`androidAmazon`:
            writeInt(&buf, Int32(16))
        
        
        case .`uwp`:
            writeInt(&buf, Int32(17))
        
        
        case .`safariBrowser`:
            writeInt(&buf, Int32(18))
        
        
        case .`vivaldiBrowser`:
            writeInt(&buf, Int32(19))
        
        
        case .`vivaldiExtension`:
            writeInt(&buf, Int32(20))
        
        
        case .`safariExtension`:
            writeInt(&buf, Int32(21))
        
        
        case .`sdk`:
            writeInt(&buf, Int32(22))
        
        }
    }
}


public func FfiConverterTypeDeviceType_lift(_ buf: RustBuffer) throws -> DeviceType {
    return try FfiConverterTypeDeviceType.lift(buf)
}

public func FfiConverterTypeDeviceType_lower(_ value: DeviceType) -> RustBuffer {
    return FfiConverterTypeDeviceType.lower(value)
}


extension DeviceType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ExportFormat {
    
    case `csv`
    case `json`
    case `accountEncryptedJson`
    case `encryptedJson`(`password`: String)
}

public struct FfiConverterTypeExportFormat: FfiConverterRustBuffer {
    typealias SwiftType = ExportFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExportFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`csv`
        
        case 2: return .`json`
        
        case 3: return .`accountEncryptedJson`
        
        case 4: return .`encryptedJson`(
            `password`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExportFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`csv`:
            writeInt(&buf, Int32(1))
        
        
        case .`json`:
            writeInt(&buf, Int32(2))
        
        
        case .`accountEncryptedJson`:
            writeInt(&buf, Int32(3))
        
        
        case let .`encryptedJson`(`password`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`password`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeExportFormat_lift(_ buf: RustBuffer) throws -> ExportFormat {
    return try FfiConverterTypeExportFormat.lift(buf)
}

public func FfiConverterTypeExportFormat_lower(_ value: ExportFormat) -> RustBuffer {
    return FfiConverterTypeExportFormat.lower(value)
}


extension ExportFormat: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FieldType {
    
    case `text`
    case `hidden`
    case `boolean`
    case `linked`
}

public struct FfiConverterTypeFieldType: FfiConverterRustBuffer {
    typealias SwiftType = FieldType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FieldType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`text`
        
        case 2: return .`hidden`
        
        case 3: return .`boolean`
        
        case 4: return .`linked`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FieldType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`text`:
            writeInt(&buf, Int32(1))
        
        
        case .`hidden`:
            writeInt(&buf, Int32(2))
        
        
        case .`boolean`:
            writeInt(&buf, Int32(3))
        
        
        case .`linked`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeFieldType_lift(_ buf: RustBuffer) throws -> FieldType {
    return try FfiConverterTypeFieldType.lift(buf)
}

public func FfiConverterTypeFieldType_lower(_ value: FieldType) -> RustBuffer {
    return FfiConverterTypeFieldType.lower(value)
}


extension FieldType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Kdf {
    
    case `pbkdf2`(`iterations`: NonZeroU32)
    case `argon2id`(`iterations`: NonZeroU32, `memory`: NonZeroU32, `parallelism`: NonZeroU32)
}

public struct FfiConverterTypeKdf: FfiConverterRustBuffer {
    typealias SwiftType = Kdf

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Kdf {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`pbkdf2`(
            `iterations`: try FfiConverterTypeNonZeroU32.read(from: &buf)
        )
        
        case 2: return .`argon2id`(
            `iterations`: try FfiConverterTypeNonZeroU32.read(from: &buf), 
            `memory`: try FfiConverterTypeNonZeroU32.read(from: &buf), 
            `parallelism`: try FfiConverterTypeNonZeroU32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Kdf, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`pbkdf2`(`iterations`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNonZeroU32.write(`iterations`, into: &buf)
            
        
        case let .`argon2id`(`iterations`,`memory`,`parallelism`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNonZeroU32.write(`iterations`, into: &buf)
            FfiConverterTypeNonZeroU32.write(`memory`, into: &buf)
            FfiConverterTypeNonZeroU32.write(`parallelism`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeKdf_lift(_ buf: RustBuffer) throws -> Kdf {
    return try FfiConverterTypeKdf.lift(buf)
}

public func FfiConverterTypeKdf_lower(_ value: Kdf) -> RustBuffer {
    return FfiConverterTypeKdf.lower(value)
}


extension Kdf: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SecureNoteType {
    
    case `generic`
}

public struct FfiConverterTypeSecureNoteType: FfiConverterRustBuffer {
    typealias SwiftType = SecureNoteType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureNoteType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`generic`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecureNoteType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`generic`:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeSecureNoteType_lift(_ buf: RustBuffer) throws -> SecureNoteType {
    return try FfiConverterTypeSecureNoteType.lift(buf)
}

public func FfiConverterTypeSecureNoteType_lower(_ value: SecureNoteType) -> RustBuffer {
    return FfiConverterTypeSecureNoteType.lower(value)
}


extension SecureNoteType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SendType {
    
    case `text`
    case `file`
}

public struct FfiConverterTypeSendType: FfiConverterRustBuffer {
    typealias SwiftType = SendType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`text`
        
        case 2: return .`file`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`text`:
            writeInt(&buf, Int32(1))
        
        
        case .`file`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeSendType_lift(_ buf: RustBuffer) throws -> SendType {
    return try FfiConverterTypeSendType.lift(buf)
}

public func FfiConverterTypeSendType_lower(_ value: SendType) -> RustBuffer {
    return FfiConverterTypeSendType.lower(value)
}


extension SendType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum UriMatchType {
    
    case `domain`
    case `host`
    case `startsWith`
    case `exact`
    case `regularExpression`
    case `never`
}

public struct FfiConverterTypeUriMatchType: FfiConverterRustBuffer {
    typealias SwiftType = UriMatchType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UriMatchType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`domain`
        
        case 2: return .`host`
        
        case 3: return .`startsWith`
        
        case 4: return .`exact`
        
        case 5: return .`regularExpression`
        
        case 6: return .`never`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UriMatchType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`domain`:
            writeInt(&buf, Int32(1))
        
        
        case .`host`:
            writeInt(&buf, Int32(2))
        
        
        case .`startsWith`:
            writeInt(&buf, Int32(3))
        
        
        case .`exact`:
            writeInt(&buf, Int32(4))
        
        
        case .`regularExpression`:
            writeInt(&buf, Int32(5))
        
        
        case .`never`:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeUriMatchType_lift(_ buf: RustBuffer) throws -> UriMatchType {
    return try FfiConverterTypeUriMatchType.lift(buf)
}

public func FfiConverterTypeUriMatchType_lower(_ value: UriMatchType) -> RustBuffer {
    return FfiConverterTypeUriMatchType.lower(value)
}


extension UriMatchType: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCard: FfiConverterRustBuffer {
    typealias SwiftType = Card?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCard.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCard.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCardView: FfiConverterRustBuffer {
    typealias SwiftType = CardView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCardView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCardView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIdentity: FfiConverterRustBuffer {
    typealias SwiftType = Identity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIdentity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIdentity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIdentityView: FfiConverterRustBuffer {
    typealias SwiftType = IdentityView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIdentityView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIdentityView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLocalData: FfiConverterRustBuffer {
    typealias SwiftType = LocalData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLocalData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLocalData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLocalDataView: FfiConverterRustBuffer {
    typealias SwiftType = LocalDataView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLocalDataView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLocalDataView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLogin: FfiConverterRustBuffer {
    typealias SwiftType = Login?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLogin.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLogin.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLoginView: FfiConverterRustBuffer {
    typealias SwiftType = LoginView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLoginView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLoginView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSecureNote: FfiConverterRustBuffer {
    typealias SwiftType = SecureNote?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSecureNote.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSecureNote.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSecureNoteView: FfiConverterRustBuffer {
    typealias SwiftType = SecureNoteView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSecureNoteView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSecureNoteView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSendFile: FfiConverterRustBuffer {
    typealias SwiftType = SendFile?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendFile.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendFile.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSendFileView: FfiConverterRustBuffer {
    typealias SwiftType = SendFileView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendFileView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendFileView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSendText: FfiConverterRustBuffer {
    typealias SwiftType = SendText?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendText.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendText.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSendTextView: FfiConverterRustBuffer {
    typealias SwiftType = SendTextView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendTextView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendTextView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUriMatchType: FfiConverterRustBuffer {
    typealias SwiftType = UriMatchType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUriMatchType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUriMatchType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDateTime: FfiConverterRustBuffer {
    typealias SwiftType = DateTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDateTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDateTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEncString: FfiConverterRustBuffer {
    typealias SwiftType = EncString?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEncString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEncString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLinkedIdType: FfiConverterRustBuffer {
    typealias SwiftType = LinkedIdType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLinkedIdType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLinkedIdType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUuid: FfiConverterRustBuffer {
    typealias SwiftType = Uuid?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUuid.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceTypeAttachment: FfiConverterRustBuffer {
    typealias SwiftType = [Attachment]

    public static func write(_ value: [Attachment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAttachment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Attachment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Attachment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAttachment.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAttachmentView: FfiConverterRustBuffer {
    typealias SwiftType = [AttachmentView]

    public static func write(_ value: [AttachmentView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAttachmentView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AttachmentView] {
        let len: Int32 = try readInt(&buf)
        var seq = [AttachmentView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAttachmentView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeField: FfiConverterRustBuffer {
    typealias SwiftType = [Field]

    public static func write(_ value: [Field], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Field] {
        let len: Int32 = try readInt(&buf)
        var seq = [Field]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeField.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFieldView: FfiConverterRustBuffer {
    typealias SwiftType = [FieldView]

    public static func write(_ value: [FieldView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFieldView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FieldView] {
        let len: Int32 = try readInt(&buf)
        var seq = [FieldView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFieldView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLoginUri: FfiConverterRustBuffer {
    typealias SwiftType = [LoginUri]

    public static func write(_ value: [LoginUri], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLoginUri.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LoginUri] {
        let len: Int32 = try readInt(&buf)
        var seq = [LoginUri]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLoginUri.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLoginUriView: FfiConverterRustBuffer {
    typealias SwiftType = [LoginUriView]

    public static func write(_ value: [LoginUriView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLoginUriView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LoginUriView] {
        let len: Int32 = try readInt(&buf)
        var seq = [LoginUriView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLoginUriView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePasswordHistory: FfiConverterRustBuffer {
    typealias SwiftType = [PasswordHistory]

    public static func write(_ value: [PasswordHistory], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePasswordHistory.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PasswordHistory] {
        let len: Int32 = try readInt(&buf)
        var seq = [PasswordHistory]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePasswordHistory.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePasswordHistoryView: FfiConverterRustBuffer {
    typealias SwiftType = [PasswordHistoryView]

    public static func write(_ value: [PasswordHistoryView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePasswordHistoryView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PasswordHistoryView] {
        let len: Int32 = try readInt(&buf)
        var seq = [PasswordHistoryView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePasswordHistoryView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUuid: FfiConverterRustBuffer {
    typealias SwiftType = [Uuid]

    public static func write(_ value: [Uuid], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUuid.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Uuid] {
        let len: Int32 = try readInt(&buf)
        var seq = [Uuid]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUuid.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryTypeUuidString: FfiConverterRustBuffer {
    public static func write(_ value: [Uuid: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeUuid.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Uuid: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [Uuid: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeUuid.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DateTime = Date
public struct FfiConverterTypeDateTime: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DateTime {
        return try FfiConverterTimestamp.read(from: &buf)
    }

    public static func write(_ value: DateTime, into buf: inout [UInt8]) {
        return FfiConverterTimestamp.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DateTime {
        return try FfiConverterTimestamp.lift(value)
    }

    public static func lower(_ value: DateTime) -> RustBuffer {
        return FfiConverterTimestamp.lower(value)
    }
}


public func FfiConverterTypeDateTime_lift(_ value: RustBuffer) throws -> DateTime {
    return try FfiConverterTypeDateTime.lift(value)
}

public func FfiConverterTypeDateTime_lower(_ value: DateTime) -> RustBuffer {
    return FfiConverterTypeDateTime.lower(value)
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias EncString = String
public struct FfiConverterTypeEncString: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncString {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: EncString, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> EncString {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: EncString) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeEncString_lift(_ value: RustBuffer) throws -> EncString {
    return try FfiConverterTypeEncString.lift(value)
}

public func FfiConverterTypeEncString_lower(_ value: EncString) -> RustBuffer {
    return FfiConverterTypeEncString.lower(value)
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias LinkedIdType = UInt32
public struct FfiConverterTypeLinkedIdType: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LinkedIdType {
        return try FfiConverterUInt32.read(from: &buf)
    }

    public static func write(_ value: LinkedIdType, into buf: inout [UInt8]) {
        return FfiConverterUInt32.write(value, into: &buf)
    }

    public static func lift(_ value: UInt32) throws -> LinkedIdType {
        return try FfiConverterUInt32.lift(value)
    }

    public static func lower(_ value: LinkedIdType) -> UInt32 {
        return FfiConverterUInt32.lower(value)
    }
}


public func FfiConverterTypeLinkedIdType_lift(_ value: UInt32) throws -> LinkedIdType {
    return try FfiConverterTypeLinkedIdType.lift(value)
}

public func FfiConverterTypeLinkedIdType_lower(_ value: LinkedIdType) -> UInt32 {
    return FfiConverterTypeLinkedIdType.lower(value)
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias NonZeroU32 = UInt32
public struct FfiConverterTypeNonZeroU32: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonZeroU32 {
        return try FfiConverterUInt32.read(from: &buf)
    }

    public static func write(_ value: NonZeroU32, into buf: inout [UInt8]) {
        return FfiConverterUInt32.write(value, into: &buf)
    }

    public static func lift(_ value: UInt32) throws -> NonZeroU32 {
        return try FfiConverterUInt32.lift(value)
    }

    public static func lower(_ value: NonZeroU32) -> UInt32 {
        return FfiConverterUInt32.lower(value)
    }
}


public func FfiConverterTypeNonZeroU32_lift(_ value: UInt32) throws -> NonZeroU32 {
    return try FfiConverterTypeNonZeroU32.lift(value)
}

public func FfiConverterTypeNonZeroU32_lower(_ value: NonZeroU32) -> UInt32 {
    return FfiConverterTypeNonZeroU32.lower(value)
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Uuid = String
public struct FfiConverterTypeUuid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Uuid, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Uuid {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Uuid) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeUuid_lift(_ value: RustBuffer) throws -> Uuid {
    return try FfiConverterTypeUuid.lift(value)
}

public func FfiConverterTypeUuid_lower(_ value: Uuid) -> RustBuffer {
    return FfiConverterTypeUuid.lower(value)
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 22
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_bitwarden_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}