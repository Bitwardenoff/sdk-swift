// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(BitwardenFFI)
import BitwardenFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_bitwarden_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_bitwarden_uniffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol ClientProtocol : AnyObject {
    
    /**
     * Auth operations
     */
    func auth()  -> ClientAuth
    
    /**
     * Crypto operations
     */
    func crypto()  -> ClientCrypto
    
    /**
     * Test method, echoes back the input
     */
    func echo(msg: String)  -> String
    
    /**
     * Exporters
     */
    func exporters()  -> ClientExporters
    
    /**
     * Generator operations
     */
    func generators()  -> ClientGenerators
    
    func platform()  -> ClientPlatform
    
    /**
     * Sends operations
     */
    func sends()  -> ClientSends
    
    /**
     * Vault item operations
     */
    func vault()  -> ClientVault
    
}

open class Client:
    ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_client(self.pointer, $0) }
    }
    /**
     * Initialize a new instance of the SDK client
     */
public convenience init(settings: ClientSettings?) {
    let pointer =
        try! rustCall() {
    uniffi_bitwarden_uniffi_fn_constructor_client_new(
        FfiConverterOptionTypeClientSettings.lower(settings),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_client(pointer, $0) }
    }

    

    
    /**
     * Auth operations
     */
open func auth() -> ClientAuth {
    return try!  FfiConverterTypeClientAuth.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_client_auth(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Crypto operations
     */
open func crypto() -> ClientCrypto {
    return try!  FfiConverterTypeClientCrypto.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_client_crypto(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Test method, echoes back the input
     */
open func echo(msg: String) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_client_echo(self.uniffiClonePointer(),
        FfiConverterString.lower(msg),$0
    )
})
}
    
    /**
     * Exporters
     */
open func exporters() -> ClientExporters {
    return try!  FfiConverterTypeClientExporters.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_client_exporters(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Generator operations
     */
open func generators() -> ClientGenerators {
    return try!  FfiConverterTypeClientGenerators.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_client_generators(self.uniffiClonePointer(),$0
    )
})
}
    
open func platform() -> ClientPlatform {
    return try!  FfiConverterTypeClientPlatform.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_client_platform(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Sends operations
     */
open func sends() -> ClientSends {
    return try!  FfiConverterTypeClientSends.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_client_sends(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Vault item operations
     */
open func vault() -> ClientVault {
    return try!  FfiConverterTypeClientVault.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_client_vault(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}




public protocol ClientAttachmentsProtocol : AnyObject {
    
    /**
     * Decrypt an attachment file in memory
     */
    func decryptBuffer(cipher: Cipher, attachment: Attachment, buffer: Data) throws  -> Data
    
    /**
     * Decrypt an attachment file located in the file system
     */
    func decryptFile(cipher: Cipher, attachment: Attachment, encryptedFilePath: String, decryptedFilePath: String) throws 
    
    /**
     * Encrypt an attachment file in memory
     */
    func encryptBuffer(cipher: Cipher, attachment: AttachmentView, buffer: Data) throws  -> AttachmentEncryptResult
    
    /**
     * Encrypt an attachment file located in the file system
     */
    func encryptFile(cipher: Cipher, attachment: AttachmentView, decryptedFilePath: String, encryptedFilePath: String) throws  -> Attachment
    
}

open class ClientAttachments:
    ClientAttachmentsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientattachments(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientattachments(pointer, $0) }
    }

    

    
    /**
     * Decrypt an attachment file in memory
     */
open func decryptBuffer(cipher: Cipher, attachment: Attachment, buffer: Data)throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientattachments_decrypt_buffer(self.uniffiClonePointer(),
        FfiConverterTypeCipher_lower(cipher),
        FfiConverterTypeAttachment_lower(attachment),
        FfiConverterData.lower(buffer),$0
    )
})
}
    
    /**
     * Decrypt an attachment file located in the file system
     */
open func decryptFile(cipher: Cipher, attachment: Attachment, encryptedFilePath: String, decryptedFilePath: String)throws  {try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientattachments_decrypt_file(self.uniffiClonePointer(),
        FfiConverterTypeCipher_lower(cipher),
        FfiConverterTypeAttachment_lower(attachment),
        FfiConverterString.lower(encryptedFilePath),
        FfiConverterString.lower(decryptedFilePath),$0
    )
}
}
    
    /**
     * Encrypt an attachment file in memory
     */
open func encryptBuffer(cipher: Cipher, attachment: AttachmentView, buffer: Data)throws  -> AttachmentEncryptResult {
    return try  FfiConverterTypeAttachmentEncryptResult_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientattachments_encrypt_buffer(self.uniffiClonePointer(),
        FfiConverterTypeCipher_lower(cipher),
        FfiConverterTypeAttachmentView_lower(attachment),
        FfiConverterData.lower(buffer),$0
    )
})
}
    
    /**
     * Encrypt an attachment file located in the file system
     */
open func encryptFile(cipher: Cipher, attachment: AttachmentView, decryptedFilePath: String, encryptedFilePath: String)throws  -> Attachment {
    return try  FfiConverterTypeAttachment_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientattachments_encrypt_file(self.uniffiClonePointer(),
        FfiConverterTypeCipher_lower(cipher),
        FfiConverterTypeAttachmentView_lower(attachment),
        FfiConverterString.lower(decryptedFilePath),
        FfiConverterString.lower(encryptedFilePath),$0
    )
})
}
    

}

public struct FfiConverterTypeClientAttachments: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientAttachments

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientAttachments {
        return ClientAttachments(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientAttachments) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientAttachments {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientAttachments, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientAttachments_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientAttachments {
    return try FfiConverterTypeClientAttachments.lift(pointer)
}

public func FfiConverterTypeClientAttachments_lower(_ value: ClientAttachments) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientAttachments.lower(value)
}




public protocol ClientAuthProtocol : AnyObject {
    
    /**
     * Approve an auth request
     */
    func approveAuthRequest(publicKey: String) throws  -> AsymmetricEncString
    
    /**
     * Hash the user password
     */
    func hashPassword(email: String, password: String, kdfParams: Kdf, purpose: HashPurpose) async throws  -> String
    
    /**
     * Generate keys needed to onboard a new user without master key to key connector
     */
    func makeKeyConnectorKeys() throws  -> KeyConnectorResponse
    
    /**
     * Generate keys needed for registration process
     */
    func makeRegisterKeys(email: String, password: String, kdf: Kdf) throws  -> RegisterKeyResponse
    
    /**
     * Generate keys needed for TDE process
     */
    func makeRegisterTdeKeys(email: String, orgPublicKey: String, rememberDevice: Bool) throws  -> RegisterTdeKeyResponse
    
    /**
     * Initialize a new auth request
     */
    func newAuthRequest(email: String) throws  -> AuthRequestResponse
    
    /**
     * **API Draft:** Calculate Password Strength
     */
    func passwordStrength(password: String, email: String, additionalInputs: [String])  -> UInt8
    
    /**
     * Evaluate if the provided password satisfies the provided policy
     */
    func satisfiesPolicy(password: String, strength: UInt8, policy: MasterPasswordPolicyOptions)  -> Bool
    
    /**
     * Trust the current device
     */
    func trustDevice() throws  -> TrustDeviceResponse
    
    /**
     * Validate the user password
     *
     * To retrieve the user's password hash, use [`ClientAuth::hash_password`] with
     * `HashPurpose::LocalAuthentication` during login and persist it. If the login method has no
     * password, use the email OTP.
     */
    func validatePassword(password: String, passwordHash: String) throws  -> Bool
    
    /**
     * Validate the user password without knowing the password hash
     *
     * Used for accounts that we know have master passwords but that have not logged in with a
     * password. Some example are login with device or TDE.
     *
     * This works by comparing the provided password against the encrypted user key.
     */
    func validatePasswordUserKey(password: String, encryptedUserKey: String) throws  -> String
    
    /**
     * Validate the user PIN
     *
     * To validate the user PIN, you need to have the user's pin_protected_user_key. This key is
     * obtained when enabling PIN unlock on the account with the `derive_pin_key` method.
     *
     * This works by comparing the decrypted user key with the current user key, so the client must
     * be unlocked.
     */
    func validatePin(pin: String, pinProtectedUserKey: EncString) throws  -> Bool
    
}

open class ClientAuth:
    ClientAuthProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientauth(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientauth(pointer, $0) }
    }

    

    
    /**
     * Approve an auth request
     */
open func approveAuthRequest(publicKey: String)throws  -> AsymmetricEncString {
    return try  FfiConverterTypeAsymmetricEncString_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientauth_approve_auth_request(self.uniffiClonePointer(),
        FfiConverterString.lower(publicKey),$0
    )
})
}
    
    /**
     * Hash the user password
     */
open func hashPassword(email: String, password: String, kdfParams: Kdf, purpose: HashPurpose)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_clientauth_hash_password(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(email),FfiConverterString.lower(password),FfiConverterTypeKdf_lower(kdfParams),FfiConverterTypeHashPurpose_lower(purpose)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeBitwardenError.lift
        )
}
    
    /**
     * Generate keys needed to onboard a new user without master key to key connector
     */
open func makeKeyConnectorKeys()throws  -> KeyConnectorResponse {
    return try  FfiConverterTypeKeyConnectorResponse_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientauth_make_key_connector_keys(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Generate keys needed for registration process
     */
open func makeRegisterKeys(email: String, password: String, kdf: Kdf)throws  -> RegisterKeyResponse {
    return try  FfiConverterTypeRegisterKeyResponse_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientauth_make_register_keys(self.uniffiClonePointer(),
        FfiConverterString.lower(email),
        FfiConverterString.lower(password),
        FfiConverterTypeKdf_lower(kdf),$0
    )
})
}
    
    /**
     * Generate keys needed for TDE process
     */
open func makeRegisterTdeKeys(email: String, orgPublicKey: String, rememberDevice: Bool)throws  -> RegisterTdeKeyResponse {
    return try  FfiConverterTypeRegisterTdeKeyResponse_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientauth_make_register_tde_keys(self.uniffiClonePointer(),
        FfiConverterString.lower(email),
        FfiConverterString.lower(orgPublicKey),
        FfiConverterBool.lower(rememberDevice),$0
    )
})
}
    
    /**
     * Initialize a new auth request
     */
open func newAuthRequest(email: String)throws  -> AuthRequestResponse {
    return try  FfiConverterTypeAuthRequestResponse_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientauth_new_auth_request(self.uniffiClonePointer(),
        FfiConverterString.lower(email),$0
    )
})
}
    
    /**
     * **API Draft:** Calculate Password Strength
     */
open func passwordStrength(password: String, email: String, additionalInputs: [String]) -> UInt8 {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_clientauth_password_strength(self.uniffiClonePointer(),
        FfiConverterString.lower(password),
        FfiConverterString.lower(email),
        FfiConverterSequenceString.lower(additionalInputs),$0
    )
})
}
    
    /**
     * Evaluate if the provided password satisfies the provided policy
     */
open func satisfiesPolicy(password: String, strength: UInt8, policy: MasterPasswordPolicyOptions) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_clientauth_satisfies_policy(self.uniffiClonePointer(),
        FfiConverterString.lower(password),
        FfiConverterUInt8.lower(strength),
        FfiConverterTypeMasterPasswordPolicyOptions_lower(policy),$0
    )
})
}
    
    /**
     * Trust the current device
     */
open func trustDevice()throws  -> TrustDeviceResponse {
    return try  FfiConverterTypeTrustDeviceResponse_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientauth_trust_device(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Validate the user password
     *
     * To retrieve the user's password hash, use [`ClientAuth::hash_password`] with
     * `HashPurpose::LocalAuthentication` during login and persist it. If the login method has no
     * password, use the email OTP.
     */
open func validatePassword(password: String, passwordHash: String)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientauth_validate_password(self.uniffiClonePointer(),
        FfiConverterString.lower(password),
        FfiConverterString.lower(passwordHash),$0
    )
})
}
    
    /**
     * Validate the user password without knowing the password hash
     *
     * Used for accounts that we know have master passwords but that have not logged in with a
     * password. Some example are login with device or TDE.
     *
     * This works by comparing the provided password against the encrypted user key.
     */
open func validatePasswordUserKey(password: String, encryptedUserKey: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientauth_validate_password_user_key(self.uniffiClonePointer(),
        FfiConverterString.lower(password),
        FfiConverterString.lower(encryptedUserKey),$0
    )
})
}
    
    /**
     * Validate the user PIN
     *
     * To validate the user PIN, you need to have the user's pin_protected_user_key. This key is
     * obtained when enabling PIN unlock on the account with the `derive_pin_key` method.
     *
     * This works by comparing the decrypted user key with the current user key, so the client must
     * be unlocked.
     */
open func validatePin(pin: String, pinProtectedUserKey: EncString)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientauth_validate_pin(self.uniffiClonePointer(),
        FfiConverterString.lower(pin),
        FfiConverterTypeEncString_lower(pinProtectedUserKey),$0
    )
})
}
    

}

public struct FfiConverterTypeClientAuth: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientAuth

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientAuth {
        return ClientAuth(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientAuth) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientAuth {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientAuth, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientAuth_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientAuth {
    return try FfiConverterTypeClientAuth.lift(pointer)
}

public func FfiConverterTypeClientAuth_lower(_ value: ClientAuth) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientAuth.lower(value)
}




public protocol ClientCiphersProtocol : AnyObject {
    
    /**
     * Decrypt cipher
     */
    func decrypt(cipher: Cipher) throws  -> CipherView
    
    func decryptFido2Credentials(cipherView: CipherView) throws  -> [Fido2CredentialView]
    
    /**
     * Decrypt cipher list
     */
    func decryptList(ciphers: [Cipher]) throws  -> [CipherListView]
    
    /**
     * Encrypt cipher
     */
    func encrypt(cipherView: CipherView) throws  -> Cipher
    
    /**
     * Move a cipher to an organization, reencrypting the cipher key if necessary
     */
    func moveToOrganization(cipher: CipherView, organizationId: Uuid) throws  -> CipherView
    
}

open class ClientCiphers:
    ClientCiphersProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientciphers(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientciphers(pointer, $0) }
    }

    

    
    /**
     * Decrypt cipher
     */
open func decrypt(cipher: Cipher)throws  -> CipherView {
    return try  FfiConverterTypeCipherView_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientciphers_decrypt(self.uniffiClonePointer(),
        FfiConverterTypeCipher_lower(cipher),$0
    )
})
}
    
open func decryptFido2Credentials(cipherView: CipherView)throws  -> [Fido2CredentialView] {
    return try  FfiConverterSequenceTypeFido2CredentialView.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientciphers_decrypt_fido2_credentials(self.uniffiClonePointer(),
        FfiConverterTypeCipherView_lower(cipherView),$0
    )
})
}
    
    /**
     * Decrypt cipher list
     */
open func decryptList(ciphers: [Cipher])throws  -> [CipherListView] {
    return try  FfiConverterSequenceTypeCipherListView.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientciphers_decrypt_list(self.uniffiClonePointer(),
        FfiConverterSequenceTypeCipher.lower(ciphers),$0
    )
})
}
    
    /**
     * Encrypt cipher
     */
open func encrypt(cipherView: CipherView)throws  -> Cipher {
    return try  FfiConverterTypeCipher_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientciphers_encrypt(self.uniffiClonePointer(),
        FfiConverterTypeCipherView_lower(cipherView),$0
    )
})
}
    
    /**
     * Move a cipher to an organization, reencrypting the cipher key if necessary
     */
open func moveToOrganization(cipher: CipherView, organizationId: Uuid)throws  -> CipherView {
    return try  FfiConverterTypeCipherView_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientciphers_move_to_organization(self.uniffiClonePointer(),
        FfiConverterTypeCipherView_lower(cipher),
        FfiConverterTypeUuid_lower(organizationId),$0
    )
})
}
    

}

public struct FfiConverterTypeClientCiphers: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientCiphers

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientCiphers {
        return ClientCiphers(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientCiphers) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientCiphers {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientCiphers, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientCiphers_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientCiphers {
    return try FfiConverterTypeClientCiphers.lift(pointer)
}

public func FfiConverterTypeClientCiphers_lower(_ value: ClientCiphers) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientCiphers.lower(value)
}




public protocol ClientCollectionsProtocol : AnyObject {
    
    /**
     * Decrypt collection
     */
    func decrypt(collection: Collection) throws  -> CollectionView
    
    /**
     * Decrypt collection list
     */
    func decryptList(collections: [Collection]) throws  -> [CollectionView]
    
}

open class ClientCollections:
    ClientCollectionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientcollections(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientcollections(pointer, $0) }
    }

    

    
    /**
     * Decrypt collection
     */
open func decrypt(collection: Collection)throws  -> CollectionView {
    return try  FfiConverterTypeCollectionView_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientcollections_decrypt(self.uniffiClonePointer(),
        FfiConverterTypeCollection_lower(collection),$0
    )
})
}
    
    /**
     * Decrypt collection list
     */
open func decryptList(collections: [Collection])throws  -> [CollectionView] {
    return try  FfiConverterSequenceTypeCollectionView.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientcollections_decrypt_list(self.uniffiClonePointer(),
        FfiConverterSequenceTypeCollection.lower(collections),$0
    )
})
}
    

}

public struct FfiConverterTypeClientCollections: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientCollections

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientCollections {
        return ClientCollections(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientCollections) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientCollections {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientCollections, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientCollections_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientCollections {
    return try FfiConverterTypeClientCollections.lift(pointer)
}

public func FfiConverterTypeClientCollections_lower(_ value: ClientCollections) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientCollections.lower(value)
}




public protocol ClientCryptoProtocol : AnyObject {
    
    /**
     * Derive the master key for migrating to the key connector
     */
    func deriveKeyConnector(request: DeriveKeyConnectorRequest) throws  -> String
    
    /**
     * Generates a PIN protected user key from the provided PIN. The result can be stored and later
     * used to initialize another client instance by using the PIN and the PIN key with
     * `initialize_user_crypto`.
     */
    func derivePinKey(pin: String) throws  -> DerivePinKeyResponse
    
    /**
     * Derives the pin protected user key from encrypted pin. Used when pin requires master
     * password on first unlock.
     */
    func derivePinUserKey(encryptedPin: EncString) throws  -> EncString
    
    func enrollAdminPasswordReset(publicKey: String) throws  -> AsymmetricEncString
    
    /**
     * Get the uses's decrypted encryption key. Note: It's very important
     * to keep this key safe, as it can be used to decrypt all of the user's data
     */
    func getUserEncryptionKey() async throws  -> String
    
    /**
     * Initialization method for the organization crypto. Needs to be called after
     * `initialize_user_crypto` but before any other crypto operations.
     */
    func initializeOrgCrypto(req: InitOrgCryptoRequest) async throws 
    
    /**
     * Initialization method for the user crypto. Needs to be called before any other crypto
     * operations.
     */
    func initializeUserCrypto(req: InitUserCryptoRequest) async throws 
    
    /**
     * Update the user's password, which will re-encrypt the user's encryption key with the new
     * password. This returns the new encrypted user key and the new password hash.
     */
    func updatePassword(newPassword: String) throws  -> UpdatePasswordResponse
    
}

open class ClientCrypto:
    ClientCryptoProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientcrypto(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientcrypto(pointer, $0) }
    }

    

    
    /**
     * Derive the master key for migrating to the key connector
     */
open func deriveKeyConnector(request: DeriveKeyConnectorRequest)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientcrypto_derive_key_connector(self.uniffiClonePointer(),
        FfiConverterTypeDeriveKeyConnectorRequest_lower(request),$0
    )
})
}
    
    /**
     * Generates a PIN protected user key from the provided PIN. The result can be stored and later
     * used to initialize another client instance by using the PIN and the PIN key with
     * `initialize_user_crypto`.
     */
open func derivePinKey(pin: String)throws  -> DerivePinKeyResponse {
    return try  FfiConverterTypeDerivePinKeyResponse_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientcrypto_derive_pin_key(self.uniffiClonePointer(),
        FfiConverterString.lower(pin),$0
    )
})
}
    
    /**
     * Derives the pin protected user key from encrypted pin. Used when pin requires master
     * password on first unlock.
     */
open func derivePinUserKey(encryptedPin: EncString)throws  -> EncString {
    return try  FfiConverterTypeEncString_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientcrypto_derive_pin_user_key(self.uniffiClonePointer(),
        FfiConverterTypeEncString_lower(encryptedPin),$0
    )
})
}
    
open func enrollAdminPasswordReset(publicKey: String)throws  -> AsymmetricEncString {
    return try  FfiConverterTypeAsymmetricEncString_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientcrypto_enroll_admin_password_reset(self.uniffiClonePointer(),
        FfiConverterString.lower(publicKey),$0
    )
})
}
    
    /**
     * Get the uses's decrypted encryption key. Note: It's very important
     * to keep this key safe, as it can be used to decrypt all of the user's data
     */
open func getUserEncryptionKey()async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_clientcrypto_get_user_encryption_key(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeBitwardenError.lift
        )
}
    
    /**
     * Initialization method for the organization crypto. Needs to be called after
     * `initialize_user_crypto` but before any other crypto operations.
     */
open func initializeOrgCrypto(req: InitOrgCryptoRequest)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_clientcrypto_initialize_org_crypto(
                    self.uniffiClonePointer(),
                    FfiConverterTypeInitOrgCryptoRequest_lower(req)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_void,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_void,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeBitwardenError.lift
        )
}
    
    /**
     * Initialization method for the user crypto. Needs to be called before any other crypto
     * operations.
     */
open func initializeUserCrypto(req: InitUserCryptoRequest)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_clientcrypto_initialize_user_crypto(
                    self.uniffiClonePointer(),
                    FfiConverterTypeInitUserCryptoRequest_lower(req)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_void,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_void,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeBitwardenError.lift
        )
}
    
    /**
     * Update the user's password, which will re-encrypt the user's encryption key with the new
     * password. This returns the new encrypted user key and the new password hash.
     */
open func updatePassword(newPassword: String)throws  -> UpdatePasswordResponse {
    return try  FfiConverterTypeUpdatePasswordResponse_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientcrypto_update_password(self.uniffiClonePointer(),
        FfiConverterString.lower(newPassword),$0
    )
})
}
    

}

public struct FfiConverterTypeClientCrypto: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientCrypto

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientCrypto {
        return ClientCrypto(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientCrypto) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientCrypto {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientCrypto, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientCrypto_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientCrypto {
    return try FfiConverterTypeClientCrypto.lift(pointer)
}

public func FfiConverterTypeClientCrypto_lower(_ value: ClientCrypto) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientCrypto.lower(value)
}




public protocol ClientExportersProtocol : AnyObject {
    
    /**
     * **API Draft:** Export organization vault
     */
    func exportOrganizationVault(collections: [Collection], ciphers: [Cipher], format: ExportFormat) throws  -> String
    
    /**
     * **API Draft:** Export user vault
     */
    func exportVault(folders: [Folder], ciphers: [Cipher], format: ExportFormat) throws  -> String
    
}

open class ClientExporters:
    ClientExportersProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientexporters(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientexporters(pointer, $0) }
    }

    

    
    /**
     * **API Draft:** Export organization vault
     */
open func exportOrganizationVault(collections: [Collection], ciphers: [Cipher], format: ExportFormat)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientexporters_export_organization_vault(self.uniffiClonePointer(),
        FfiConverterSequenceTypeCollection.lower(collections),
        FfiConverterSequenceTypeCipher.lower(ciphers),
        FfiConverterTypeExportFormat_lower(format),$0
    )
})
}
    
    /**
     * **API Draft:** Export user vault
     */
open func exportVault(folders: [Folder], ciphers: [Cipher], format: ExportFormat)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientexporters_export_vault(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFolder.lower(folders),
        FfiConverterSequenceTypeCipher.lower(ciphers),
        FfiConverterTypeExportFormat_lower(format),$0
    )
})
}
    

}

public struct FfiConverterTypeClientExporters: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientExporters

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientExporters {
        return ClientExporters(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientExporters) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientExporters {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientExporters, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientExporters_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientExporters {
    return try FfiConverterTypeClientExporters.lift(pointer)
}

public func FfiConverterTypeClientExporters_lower(_ value: ClientExporters) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientExporters.lower(value)
}




public protocol ClientFido2Protocol : AnyObject {
    
    func authenticator(userInterface: Fido2UserInterface, credentialStore: Fido2CredentialStore)  -> ClientFido2Authenticator
    
    func client(userInterface: Fido2UserInterface, credentialStore: Fido2CredentialStore)  -> ClientFido2Client
    
    func decryptFido2AutofillCredentials(cipherView: CipherView) throws  -> [Fido2CredentialAutofillView]
    
}

open class ClientFido2:
    ClientFido2Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientfido2(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientfido2(pointer, $0) }
    }

    

    
open func authenticator(userInterface: Fido2UserInterface, credentialStore: Fido2CredentialStore) -> ClientFido2Authenticator {
    return try!  FfiConverterTypeClientFido2Authenticator.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_clientfido2_authenticator(self.uniffiClonePointer(),
        FfiConverterTypeFido2UserInterface.lower(userInterface),
        FfiConverterTypeFido2CredentialStore.lower(credentialStore),$0
    )
})
}
    
open func client(userInterface: Fido2UserInterface, credentialStore: Fido2CredentialStore) -> ClientFido2Client {
    return try!  FfiConverterTypeClientFido2Client.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_clientfido2_client(self.uniffiClonePointer(),
        FfiConverterTypeFido2UserInterface.lower(userInterface),
        FfiConverterTypeFido2CredentialStore.lower(credentialStore),$0
    )
})
}
    
open func decryptFido2AutofillCredentials(cipherView: CipherView)throws  -> [Fido2CredentialAutofillView] {
    return try  FfiConverterSequenceTypeFido2CredentialAutofillView.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientfido2_decrypt_fido2_autofill_credentials(self.uniffiClonePointer(),
        FfiConverterTypeCipherView_lower(cipherView),$0
    )
})
}
    

}

public struct FfiConverterTypeClientFido2: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientFido2

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientFido2 {
        return ClientFido2(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientFido2) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientFido2 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientFido2, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientFido2_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientFido2 {
    return try FfiConverterTypeClientFido2.lift(pointer)
}

public func FfiConverterTypeClientFido2_lower(_ value: ClientFido2) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientFido2.lower(value)
}




public protocol ClientFido2AuthenticatorProtocol : AnyObject {
    
    func credentialsForAutofill() async throws  -> [Fido2CredentialAutofillView]
    
    func getAssertion(request: GetAssertionRequest) async throws  -> GetAssertionResult
    
    func makeCredential(request: MakeCredentialRequest) async throws  -> MakeCredentialResult
    
    func silentlyDiscoverCredentials(rpId: String) async throws  -> [Fido2CredentialAutofillView]
    
}

open class ClientFido2Authenticator:
    ClientFido2AuthenticatorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientfido2authenticator(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientfido2authenticator(pointer, $0) }
    }

    

    
open func credentialsForAutofill()async throws  -> [Fido2CredentialAutofillView] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_clientfido2authenticator_credentials_for_autofill(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFido2CredentialAutofillView.lift,
            errorHandler: FfiConverterTypeBitwardenError.lift
        )
}
    
open func getAssertion(request: GetAssertionRequest)async throws  -> GetAssertionResult {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_clientfido2authenticator_get_assertion(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGetAssertionRequest_lower(request)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeGetAssertionResult_lift,
            errorHandler: FfiConverterTypeBitwardenError.lift
        )
}
    
open func makeCredential(request: MakeCredentialRequest)async throws  -> MakeCredentialResult {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_clientfido2authenticator_make_credential(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMakeCredentialRequest_lower(request)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeMakeCredentialResult_lift,
            errorHandler: FfiConverterTypeBitwardenError.lift
        )
}
    
open func silentlyDiscoverCredentials(rpId: String)async throws  -> [Fido2CredentialAutofillView] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_clientfido2authenticator_silently_discover_credentials(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(rpId)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFido2CredentialAutofillView.lift,
            errorHandler: FfiConverterTypeBitwardenError.lift
        )
}
    

}

public struct FfiConverterTypeClientFido2Authenticator: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientFido2Authenticator

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientFido2Authenticator {
        return ClientFido2Authenticator(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientFido2Authenticator) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientFido2Authenticator {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientFido2Authenticator, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientFido2Authenticator_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientFido2Authenticator {
    return try FfiConverterTypeClientFido2Authenticator.lift(pointer)
}

public func FfiConverterTypeClientFido2Authenticator_lower(_ value: ClientFido2Authenticator) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientFido2Authenticator.lower(value)
}




public protocol ClientFido2ClientProtocol : AnyObject {
    
    func authenticate(origin: String, request: String, clientData: ClientData) async throws  -> PublicKeyCredentialAuthenticatorAssertionResponse
    
    func register(origin: String, request: String, clientData: ClientData) async throws  -> PublicKeyCredentialAuthenticatorAttestationResponse
    
}

open class ClientFido2Client:
    ClientFido2ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientfido2client(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientfido2client(pointer, $0) }
    }

    

    
open func authenticate(origin: String, request: String, clientData: ClientData)async throws  -> PublicKeyCredentialAuthenticatorAssertionResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_clientfido2client_authenticate(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(origin),FfiConverterString.lower(request),FfiConverterTypeClientData_lower(clientData)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePublicKeyCredentialAuthenticatorAssertionResponse_lift,
            errorHandler: FfiConverterTypeBitwardenError.lift
        )
}
    
open func register(origin: String, request: String, clientData: ClientData)async throws  -> PublicKeyCredentialAuthenticatorAttestationResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_clientfido2client_register(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(origin),FfiConverterString.lower(request),FfiConverterTypeClientData_lower(clientData)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePublicKeyCredentialAuthenticatorAttestationResponse_lift,
            errorHandler: FfiConverterTypeBitwardenError.lift
        )
}
    

}

public struct FfiConverterTypeClientFido2Client: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientFido2Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientFido2Client {
        return ClientFido2Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientFido2Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientFido2Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientFido2Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientFido2Client_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientFido2Client {
    return try FfiConverterTypeClientFido2Client.lift(pointer)
}

public func FfiConverterTypeClientFido2Client_lower(_ value: ClientFido2Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientFido2Client.lower(value)
}




public protocol ClientFoldersProtocol : AnyObject {
    
    /**
     * Decrypt folder
     */
    func decrypt(folder: Folder) throws  -> FolderView
    
    /**
     * Decrypt folder list
     */
    func decryptList(folders: [Folder]) throws  -> [FolderView]
    
    /**
     * Encrypt folder
     */
    func encrypt(folder: FolderView) throws  -> Folder
    
}

open class ClientFolders:
    ClientFoldersProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientfolders(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientfolders(pointer, $0) }
    }

    

    
    /**
     * Decrypt folder
     */
open func decrypt(folder: Folder)throws  -> FolderView {
    return try  FfiConverterTypeFolderView_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientfolders_decrypt(self.uniffiClonePointer(),
        FfiConverterTypeFolder_lower(folder),$0
    )
})
}
    
    /**
     * Decrypt folder list
     */
open func decryptList(folders: [Folder])throws  -> [FolderView] {
    return try  FfiConverterSequenceTypeFolderView.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientfolders_decrypt_list(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFolder.lower(folders),$0
    )
})
}
    
    /**
     * Encrypt folder
     */
open func encrypt(folder: FolderView)throws  -> Folder {
    return try  FfiConverterTypeFolder_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientfolders_encrypt(self.uniffiClonePointer(),
        FfiConverterTypeFolderView_lower(folder),$0
    )
})
}
    

}

public struct FfiConverterTypeClientFolders: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientFolders

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientFolders {
        return ClientFolders(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientFolders) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientFolders {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientFolders, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientFolders_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientFolders {
    return try FfiConverterTypeClientFolders.lift(pointer)
}

public func FfiConverterTypeClientFolders_lower(_ value: ClientFolders) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientFolders.lower(value)
}




public protocol ClientGeneratorsProtocol : AnyObject {
    
    /**
     * **API Draft:** Generate Passphrase
     */
    func passphrase(settings: PassphraseGeneratorRequest) throws  -> String
    
    /**
     * **API Draft:** Generate Password
     */
    func password(settings: PasswordGeneratorRequest) throws  -> String
    
    /**
     * **API Draft:** Generate Username
     */
    func username(settings: UsernameGeneratorRequest) async throws  -> String
    
}

open class ClientGenerators:
    ClientGeneratorsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientgenerators(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientgenerators(pointer, $0) }
    }

    

    
    /**
     * **API Draft:** Generate Passphrase
     */
open func passphrase(settings: PassphraseGeneratorRequest)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientgenerators_passphrase(self.uniffiClonePointer(),
        FfiConverterTypePassphraseGeneratorRequest_lower(settings),$0
    )
})
}
    
    /**
     * **API Draft:** Generate Password
     */
open func password(settings: PasswordGeneratorRequest)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientgenerators_password(self.uniffiClonePointer(),
        FfiConverterTypePasswordGeneratorRequest_lower(settings),$0
    )
})
}
    
    /**
     * **API Draft:** Generate Username
     */
open func username(settings: UsernameGeneratorRequest)async throws  -> String {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_clientgenerators_username(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUsernameGeneratorRequest_lower(settings)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeBitwardenError.lift
        )
}
    

}

public struct FfiConverterTypeClientGenerators: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientGenerators

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientGenerators {
        return ClientGenerators(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientGenerators) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientGenerators {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientGenerators, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientGenerators_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientGenerators {
    return try FfiConverterTypeClientGenerators.lift(pointer)
}

public func FfiConverterTypeClientGenerators_lower(_ value: ClientGenerators) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientGenerators.lower(value)
}




public protocol ClientPasswordHistoryProtocol : AnyObject {
    
    /**
     * Decrypt password history
     */
    func decryptList(list: [PasswordHistory]) throws  -> [PasswordHistoryView]
    
    /**
     * Encrypt password history
     */
    func encrypt(passwordHistory: PasswordHistoryView) throws  -> PasswordHistory
    
}

open class ClientPasswordHistory:
    ClientPasswordHistoryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientpasswordhistory(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientpasswordhistory(pointer, $0) }
    }

    

    
    /**
     * Decrypt password history
     */
open func decryptList(list: [PasswordHistory])throws  -> [PasswordHistoryView] {
    return try  FfiConverterSequenceTypePasswordHistoryView.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientpasswordhistory_decrypt_list(self.uniffiClonePointer(),
        FfiConverterSequenceTypePasswordHistory.lower(list),$0
    )
})
}
    
    /**
     * Encrypt password history
     */
open func encrypt(passwordHistory: PasswordHistoryView)throws  -> PasswordHistory {
    return try  FfiConverterTypePasswordHistory_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientpasswordhistory_encrypt(self.uniffiClonePointer(),
        FfiConverterTypePasswordHistoryView_lower(passwordHistory),$0
    )
})
}
    

}

public struct FfiConverterTypeClientPasswordHistory: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientPasswordHistory

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientPasswordHistory {
        return ClientPasswordHistory(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientPasswordHistory) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientPasswordHistory {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientPasswordHistory, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientPasswordHistory_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientPasswordHistory {
    return try FfiConverterTypeClientPasswordHistory.lift(pointer)
}

public func FfiConverterTypeClientPasswordHistory_lower(_ value: ClientPasswordHistory) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientPasswordHistory.lower(value)
}




public protocol ClientPlatformProtocol : AnyObject {
    
    /**
     * FIDO2 operations
     */
    func fido2()  -> ClientFido2
    
    /**
     * Fingerprint (public key)
     */
    func fingerprint(req: FingerprintRequest) throws  -> String
    
    /**
     * Load feature flags into the client
     */
    func loadFlags(flags: [String: Bool]) throws 
    
    /**
     * Fingerprint using logged in user's public key
     */
    func userFingerprint(fingerprintMaterial: String) throws  -> String
    
}

open class ClientPlatform:
    ClientPlatformProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientplatform(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientplatform(pointer, $0) }
    }

    

    
    /**
     * FIDO2 operations
     */
open func fido2() -> ClientFido2 {
    return try!  FfiConverterTypeClientFido2.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_clientplatform_fido2(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Fingerprint (public key)
     */
open func fingerprint(req: FingerprintRequest)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientplatform_fingerprint(self.uniffiClonePointer(),
        FfiConverterTypeFingerprintRequest_lower(req),$0
    )
})
}
    
    /**
     * Load feature flags into the client
     */
open func loadFlags(flags: [String: Bool])throws  {try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientplatform_load_flags(self.uniffiClonePointer(),
        FfiConverterDictionaryStringBool.lower(flags),$0
    )
}
}
    
    /**
     * Fingerprint using logged in user's public key
     */
open func userFingerprint(fingerprintMaterial: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientplatform_user_fingerprint(self.uniffiClonePointer(),
        FfiConverterString.lower(fingerprintMaterial),$0
    )
})
}
    

}

public struct FfiConverterTypeClientPlatform: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientPlatform

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientPlatform {
        return ClientPlatform(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientPlatform) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientPlatform {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientPlatform, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientPlatform_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientPlatform {
    return try FfiConverterTypeClientPlatform.lift(pointer)
}

public func FfiConverterTypeClientPlatform_lower(_ value: ClientPlatform) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientPlatform.lower(value)
}




public protocol ClientSendsProtocol : AnyObject {
    
    /**
     * Decrypt send
     */
    func decrypt(send: Send) throws  -> SendView
    
    /**
     * Decrypt a send file in memory
     */
    func decryptBuffer(send: Send, buffer: Data) throws  -> Data
    
    /**
     * Decrypt a send file located in the file system
     */
    func decryptFile(send: Send, encryptedFilePath: String, decryptedFilePath: String) throws 
    
    /**
     * Decrypt send list
     */
    func decryptList(sends: [Send]) throws  -> [SendListView]
    
    /**
     * Encrypt send
     */
    func encrypt(send: SendView) throws  -> Send
    
    /**
     * Encrypt a send file in memory
     */
    func encryptBuffer(send: Send, buffer: Data) throws  -> Data
    
    /**
     * Encrypt a send file located in the file system
     */
    func encryptFile(send: Send, decryptedFilePath: String, encryptedFilePath: String) throws 
    
}

open class ClientSends:
    ClientSendsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientsends(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientsends(pointer, $0) }
    }

    

    
    /**
     * Decrypt send
     */
open func decrypt(send: Send)throws  -> SendView {
    return try  FfiConverterTypeSendView_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt(self.uniffiClonePointer(),
        FfiConverterTypeSend_lower(send),$0
    )
})
}
    
    /**
     * Decrypt a send file in memory
     */
open func decryptBuffer(send: Send, buffer: Data)throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt_buffer(self.uniffiClonePointer(),
        FfiConverterTypeSend_lower(send),
        FfiConverterData.lower(buffer),$0
    )
})
}
    
    /**
     * Decrypt a send file located in the file system
     */
open func decryptFile(send: Send, encryptedFilePath: String, decryptedFilePath: String)throws  {try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt_file(self.uniffiClonePointer(),
        FfiConverterTypeSend_lower(send),
        FfiConverterString.lower(encryptedFilePath),
        FfiConverterString.lower(decryptedFilePath),$0
    )
}
}
    
    /**
     * Decrypt send list
     */
open func decryptList(sends: [Send])throws  -> [SendListView] {
    return try  FfiConverterSequenceTypeSendListView.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientsends_decrypt_list(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSend.lower(sends),$0
    )
})
}
    
    /**
     * Encrypt send
     */
open func encrypt(send: SendView)throws  -> Send {
    return try  FfiConverterTypeSend_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientsends_encrypt(self.uniffiClonePointer(),
        FfiConverterTypeSendView_lower(send),$0
    )
})
}
    
    /**
     * Encrypt a send file in memory
     */
open func encryptBuffer(send: Send, buffer: Data)throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientsends_encrypt_buffer(self.uniffiClonePointer(),
        FfiConverterTypeSend_lower(send),
        FfiConverterData.lower(buffer),$0
    )
})
}
    
    /**
     * Encrypt a send file located in the file system
     */
open func encryptFile(send: Send, decryptedFilePath: String, encryptedFilePath: String)throws  {try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientsends_encrypt_file(self.uniffiClonePointer(),
        FfiConverterTypeSend_lower(send),
        FfiConverterString.lower(decryptedFilePath),
        FfiConverterString.lower(encryptedFilePath),$0
    )
}
}
    

}

public struct FfiConverterTypeClientSends: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientSends

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientSends {
        return ClientSends(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientSends) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientSends {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientSends, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientSends_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientSends {
    return try FfiConverterTypeClientSends.lift(pointer)
}

public func FfiConverterTypeClientSends_lower(_ value: ClientSends) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientSends.lower(value)
}




public protocol ClientVaultProtocol : AnyObject {
    
    /**
     * Attachment file operations
     */
    func attachments()  -> ClientAttachments
    
    /**
     * Ciphers operations
     */
    func ciphers()  -> ClientCiphers
    
    /**
     * Collections operations
     */
    func collections()  -> ClientCollections
    
    /**
     * Folder operations
     */
    func folders()  -> ClientFolders
    
    /**
     * Generate a TOTP code from a provided key.
     *
     * The key can be either:
     * - A base32 encoded string
     * - OTP Auth URI
     * - Steam URI
     */
    func generateTotp(key: String, time: DateTime?) throws  -> TotpResponse
    
    /**
     * Generate a TOTP code from a provided cipher list view.
     */
    func generateTotpCipherView(view: CipherListView, time: DateTime?) throws  -> TotpResponse
    
    /**
     * Password history operations
     */
    func passwordHistory()  -> ClientPasswordHistory
    
}

open class ClientVault:
    ClientVaultProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_clientvault(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_clientvault(pointer, $0) }
    }

    

    
    /**
     * Attachment file operations
     */
open func attachments() -> ClientAttachments {
    return try!  FfiConverterTypeClientAttachments.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_clientvault_attachments(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Ciphers operations
     */
open func ciphers() -> ClientCiphers {
    return try!  FfiConverterTypeClientCiphers.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_clientvault_ciphers(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Collections operations
     */
open func collections() -> ClientCollections {
    return try!  FfiConverterTypeClientCollections.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_clientvault_collections(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Folder operations
     */
open func folders() -> ClientFolders {
    return try!  FfiConverterTypeClientFolders.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_clientvault_folders(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Generate a TOTP code from a provided key.
     *
     * The key can be either:
     * - A base32 encoded string
     * - OTP Auth URI
     * - Steam URI
     */
open func generateTotp(key: String, time: DateTime?)throws  -> TotpResponse {
    return try  FfiConverterTypeTotpResponse_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientvault_generate_totp(self.uniffiClonePointer(),
        FfiConverterString.lower(key),
        FfiConverterOptionTypeDateTime.lower(time),$0
    )
})
}
    
    /**
     * Generate a TOTP code from a provided cipher list view.
     */
open func generateTotpCipherView(view: CipherListView, time: DateTime?)throws  -> TotpResponse {
    return try  FfiConverterTypeTotpResponse_lift(try rustCallWithError(FfiConverterTypeBitwardenError.lift) {
    uniffi_bitwarden_uniffi_fn_method_clientvault_generate_totp_cipher_view(self.uniffiClonePointer(),
        FfiConverterTypeCipherListView_lower(view),
        FfiConverterOptionTypeDateTime.lower(time),$0
    )
})
}
    
    /**
     * Password history operations
     */
open func passwordHistory() -> ClientPasswordHistory {
    return try!  FfiConverterTypeClientPasswordHistory.lift(try! rustCall() {
    uniffi_bitwarden_uniffi_fn_method_clientvault_password_history(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeClientVault: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientVault

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientVault {
        return ClientVault(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientVault) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientVault {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientVault, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeClientVault_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientVault {
    return try FfiConverterTypeClientVault.lift(pointer)
}

public func FfiConverterTypeClientVault_lower(_ value: ClientVault) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientVault.lower(value)
}




public protocol Fido2CredentialStore : AnyObject {
    
    func findCredentials(ids: [Data]?, ripId: String) async throws  -> [CipherView]
    
    func allCredentials() async throws  -> [CipherView]
    
    func saveCredential(cred: Cipher) async throws 
    
}

open class Fido2CredentialStoreImpl:
    Fido2CredentialStore {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_fido2credentialstore(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_fido2credentialstore(pointer, $0) }
    }

    

    
open func findCredentials(ids: [Data]?, ripId: String)async throws  -> [CipherView] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_fido2credentialstore_find_credentials(
                    self.uniffiClonePointer(),
                    FfiConverterOptionSequenceData.lower(ids),FfiConverterString.lower(ripId)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeCipherView.lift,
            errorHandler: FfiConverterTypeFido2CallbackError.lift
        )
}
    
open func allCredentials()async throws  -> [CipherView] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_fido2credentialstore_all_credentials(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeCipherView.lift,
            errorHandler: FfiConverterTypeFido2CallbackError.lift
        )
}
    
open func saveCredential(cred: Cipher)async throws  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_fido2credentialstore_save_credential(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCipher_lower(cred)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_void,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_void,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeFido2CallbackError.lift
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFido2CredentialStore {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFido2CredentialStore = UniffiVTableCallbackInterfaceFido2CredentialStore(
        findCredentials: { (
            uniffiHandle: UInt64,
            ids: RustBuffer,
            ripId: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [CipherView] in
                guard let uniffiObj = try? FfiConverterTypeFido2CredentialStore.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.findCredentials(
                     ids: try FfiConverterOptionSequenceData.lift(ids),
                     ripId: try FfiConverterString.lift(ripId)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [CipherView]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeCipherView.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeFido2CallbackError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        allCredentials: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [CipherView] in
                guard let uniffiObj = try? FfiConverterTypeFido2CredentialStore.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.allCredentials(
                )
            }

            let uniffiHandleSuccess = { (returnValue: [CipherView]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeCipherView.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeFido2CallbackError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        saveCredential: { (
            uniffiHandle: UInt64,
            cred: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFido2CredentialStore.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveCredential(
                     cred: try FfiConverterTypeCipher_lift(cred)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeFido2CallbackError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFido2CredentialStore.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Fido2CredentialStore: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFido2CredentialStore() {
    uniffi_bitwarden_uniffi_fn_init_callback_vtable_fido2credentialstore(&UniffiCallbackInterfaceFido2CredentialStore.vtable)
}

public struct FfiConverterTypeFido2CredentialStore: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<Fido2CredentialStore>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Fido2CredentialStore

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Fido2CredentialStore {
        return Fido2CredentialStoreImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Fido2CredentialStore) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fido2CredentialStore {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Fido2CredentialStore, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeFido2CredentialStore_lift(_ pointer: UnsafeMutableRawPointer) throws -> Fido2CredentialStore {
    return try FfiConverterTypeFido2CredentialStore.lift(pointer)
}

public func FfiConverterTypeFido2CredentialStore_lower(_ value: Fido2CredentialStore) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFido2CredentialStore.lower(value)
}




public protocol Fido2UserInterface : AnyObject {
    
    func checkUser(options: CheckUserOptions, hint: UiHint) async throws  -> CheckUserResult
    
    func pickCredentialForAuthentication(availableCredentials: [CipherView]) async throws  -> CipherViewWrapper
    
    func checkUserAndPickCredentialForCreation(options: CheckUserOptions, newCredential: Fido2CredentialNewView) async throws  -> CheckUserAndPickCredentialForCreationResult
    
    func isVerificationEnabled() async  -> Bool
    
}

open class Fido2UserInterfaceImpl:
    Fido2UserInterface {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bitwarden_uniffi_fn_clone_fido2userinterface(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bitwarden_uniffi_fn_free_fido2userinterface(pointer, $0) }
    }

    

    
open func checkUser(options: CheckUserOptions, hint: UiHint)async throws  -> CheckUserResult {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_fido2userinterface_check_user(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCheckUserOptions_lower(options),FfiConverterTypeUIHint.lower(hint)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeCheckUserResult.lift,
            errorHandler: FfiConverterTypeFido2CallbackError.lift
        )
}
    
open func pickCredentialForAuthentication(availableCredentials: [CipherView])async throws  -> CipherViewWrapper {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_fido2userinterface_pick_credential_for_authentication(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeCipherView.lower(availableCredentials)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeCipherViewWrapper.lift,
            errorHandler: FfiConverterTypeFido2CallbackError.lift
        )
}
    
open func checkUserAndPickCredentialForCreation(options: CheckUserOptions, newCredential: Fido2CredentialNewView)async throws  -> CheckUserAndPickCredentialForCreationResult {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_fido2userinterface_check_user_and_pick_credential_for_creation(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCheckUserOptions_lower(options),FfiConverterTypeFido2CredentialNewView_lower(newCredential)
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeCheckUserAndPickCredentialForCreationResult.lift,
            errorHandler: FfiConverterTypeFido2CallbackError.lift
        )
}
    
open func isVerificationEnabled()async  -> Bool {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bitwarden_uniffi_fn_method_fido2userinterface_is_verification_enabled(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bitwarden_uniffi_rust_future_poll_i8,
            completeFunc: ffi_bitwarden_uniffi_rust_future_complete_i8,
            freeFunc: ffi_bitwarden_uniffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFido2UserInterface {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFido2UserInterface = UniffiVTableCallbackInterfaceFido2UserInterface(
        checkUser: { (
            uniffiHandle: UInt64,
            options: RustBuffer,
            hint: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> CheckUserResult in
                guard let uniffiObj = try? FfiConverterTypeFido2UserInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.checkUser(
                     options: try FfiConverterTypeCheckUserOptions_lift(options),
                     hint: try FfiConverterTypeUIHint.lift(hint)
                )
            }

            let uniffiHandleSuccess = { (returnValue: CheckUserResult) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeCheckUserResult.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeFido2CallbackError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        pickCredentialForAuthentication: { (
            uniffiHandle: UInt64,
            availableCredentials: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> CipherViewWrapper in
                guard let uniffiObj = try? FfiConverterTypeFido2UserInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.pickCredentialForAuthentication(
                     availableCredentials: try FfiConverterSequenceTypeCipherView.lift(availableCredentials)
                )
            }

            let uniffiHandleSuccess = { (returnValue: CipherViewWrapper) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeCipherViewWrapper.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeFido2CallbackError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        checkUserAndPickCredentialForCreation: { (
            uniffiHandle: UInt64,
            options: RustBuffer,
            newCredential: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> CheckUserAndPickCredentialForCreationResult in
                guard let uniffiObj = try? FfiConverterTypeFido2UserInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.checkUserAndPickCredentialForCreation(
                     options: try FfiConverterTypeCheckUserOptions_lift(options),
                     newCredential: try FfiConverterTypeFido2CredentialNewView_lift(newCredential)
                )
            }

            let uniffiHandleSuccess = { (returnValue: CheckUserAndPickCredentialForCreationResult) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeCheckUserAndPickCredentialForCreationResult.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeFido2CallbackError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        isVerificationEnabled: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteI8,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeFido2UserInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.isVerificationEnabled(
                )
            }

            let uniffiHandleSuccess = { (returnValue: Bool) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructI8(
                        returnValue: FfiConverterBool.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructI8(
                        returnValue: 0,
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFido2UserInterface.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Fido2UserInterface: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFido2UserInterface() {
    uniffi_bitwarden_uniffi_fn_init_callback_vtable_fido2userinterface(&UniffiCallbackInterfaceFido2UserInterface.vtable)
}

public struct FfiConverterTypeFido2UserInterface: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<Fido2UserInterface>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Fido2UserInterface

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Fido2UserInterface {
        return Fido2UserInterfaceImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Fido2UserInterface) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fido2UserInterface {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Fido2UserInterface, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeFido2UserInterface_lift(_ pointer: UnsafeMutableRawPointer) throws -> Fido2UserInterface {
    return try FfiConverterTypeFido2UserInterface.lift(pointer)
}

public func FfiConverterTypeFido2UserInterface_lower(_ value: Fido2UserInterface) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFido2UserInterface.lower(value)
}


public struct CheckUserAndPickCredentialForCreationResult {
    public let cipher: CipherViewWrapper
    public let checkUserResult: CheckUserResult

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cipher: CipherViewWrapper, checkUserResult: CheckUserResult) {
        self.cipher = cipher
        self.checkUserResult = checkUserResult
    }
}



extension CheckUserAndPickCredentialForCreationResult: Equatable, Hashable {
    public static func ==(lhs: CheckUserAndPickCredentialForCreationResult, rhs: CheckUserAndPickCredentialForCreationResult) -> Bool {
        if lhs.cipher != rhs.cipher {
            return false
        }
        if lhs.checkUserResult != rhs.checkUserResult {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cipher)
        hasher.combine(checkUserResult)
    }
}


public struct FfiConverterTypeCheckUserAndPickCredentialForCreationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckUserAndPickCredentialForCreationResult {
        return
            try CheckUserAndPickCredentialForCreationResult(
                cipher: FfiConverterTypeCipherViewWrapper.read(from: &buf), 
                checkUserResult: FfiConverterTypeCheckUserResult.read(from: &buf)
        )
    }

    public static func write(_ value: CheckUserAndPickCredentialForCreationResult, into buf: inout [UInt8]) {
        FfiConverterTypeCipherViewWrapper.write(value.cipher, into: &buf)
        FfiConverterTypeCheckUserResult.write(value.checkUserResult, into: &buf)
    }
}


public func FfiConverterTypeCheckUserAndPickCredentialForCreationResult_lift(_ buf: RustBuffer) throws -> CheckUserAndPickCredentialForCreationResult {
    return try FfiConverterTypeCheckUserAndPickCredentialForCreationResult.lift(buf)
}

public func FfiConverterTypeCheckUserAndPickCredentialForCreationResult_lower(_ value: CheckUserAndPickCredentialForCreationResult) -> RustBuffer {
    return FfiConverterTypeCheckUserAndPickCredentialForCreationResult.lower(value)
}


public struct CheckUserResult {
    public let userPresent: Bool
    public let userVerified: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userPresent: Bool, userVerified: Bool) {
        self.userPresent = userPresent
        self.userVerified = userVerified
    }
}



extension CheckUserResult: Equatable, Hashable {
    public static func ==(lhs: CheckUserResult, rhs: CheckUserResult) -> Bool {
        if lhs.userPresent != rhs.userPresent {
            return false
        }
        if lhs.userVerified != rhs.userVerified {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userPresent)
        hasher.combine(userVerified)
    }
}


public struct FfiConverterTypeCheckUserResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckUserResult {
        return
            try CheckUserResult(
                userPresent: FfiConverterBool.read(from: &buf), 
                userVerified: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CheckUserResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.userPresent, into: &buf)
        FfiConverterBool.write(value.userVerified, into: &buf)
    }
}


public func FfiConverterTypeCheckUserResult_lift(_ buf: RustBuffer) throws -> CheckUserResult {
    return try FfiConverterTypeCheckUserResult.lift(buf)
}

public func FfiConverterTypeCheckUserResult_lower(_ value: CheckUserResult) -> RustBuffer {
    return FfiConverterTypeCheckUserResult.lower(value)
}


public struct CipherViewWrapper {
    public let cipher: CipherView

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cipher: CipherView) {
        self.cipher = cipher
    }
}



extension CipherViewWrapper: Equatable, Hashable {
    public static func ==(lhs: CipherViewWrapper, rhs: CipherViewWrapper) -> Bool {
        if lhs.cipher != rhs.cipher {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cipher)
    }
}


public struct FfiConverterTypeCipherViewWrapper: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherViewWrapper {
        return
            try CipherViewWrapper(
                cipher: FfiConverterTypeCipherView.read(from: &buf)
        )
    }

    public static func write(_ value: CipherViewWrapper, into buf: inout [UInt8]) {
        FfiConverterTypeCipherView.write(value.cipher, into: &buf)
    }
}


public func FfiConverterTypeCipherViewWrapper_lift(_ buf: RustBuffer) throws -> CipherViewWrapper {
    return try FfiConverterTypeCipherViewWrapper.lift(buf)
}

public func FfiConverterTypeCipherViewWrapper_lower(_ value: CipherViewWrapper) -> RustBuffer {
    return FfiConverterTypeCipherViewWrapper.lower(value)
}


public enum BitwardenError {

    
    
    case E(message: String)
    
}


public struct FfiConverterTypeBitwardenError: FfiConverterRustBuffer {
    typealias SwiftType = BitwardenError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitwardenError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .E(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BitwardenError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .E(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


extension BitwardenError: Equatable, Hashable {}

extension BitwardenError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum Fido2CallbackError {

    
    
    case UserInterfaceRequired
    case OperationCancelled
    case Unknown(reason: String
    )
}


public struct FfiConverterTypeFido2CallbackError: FfiConverterRustBuffer {
    typealias SwiftType = Fido2CallbackError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fido2CallbackError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .UserInterfaceRequired
        case 2: return .OperationCancelled
        case 3: return .Unknown(
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Fido2CallbackError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .UserInterfaceRequired:
            writeInt(&buf, Int32(1))
        
        
        case .OperationCancelled:
            writeInt(&buf, Int32(2))
        
        
        case let .Unknown(reason):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


extension Fido2CallbackError: Equatable, Hashable {}

extension Fido2CallbackError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UiHint {
    
    case informExcludedCredentialFound(CipherView
    )
    case informNoCredentialsFound
    case requestNewCredential(PublicKeyCredentialUserEntity,PublicKeyCredentialRpEntity
    )
    case requestExistingCredential(CipherView
    )
}


public struct FfiConverterTypeUIHint: FfiConverterRustBuffer {
    typealias SwiftType = UiHint

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UiHint {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .informExcludedCredentialFound(try FfiConverterTypeCipherView.read(from: &buf)
        )
        
        case 2: return .informNoCredentialsFound
        
        case 3: return .requestNewCredential(try FfiConverterTypePublicKeyCredentialUserEntity.read(from: &buf), try FfiConverterTypePublicKeyCredentialRpEntity.read(from: &buf)
        )
        
        case 4: return .requestExistingCredential(try FfiConverterTypeCipherView.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UiHint, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .informExcludedCredentialFound(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeCipherView.write(v1, into: &buf)
            
        
        case .informNoCredentialsFound:
            writeInt(&buf, Int32(2))
        
        
        case let .requestNewCredential(v1,v2):
            writeInt(&buf, Int32(3))
            FfiConverterTypePublicKeyCredentialUserEntity.write(v1, into: &buf)
            FfiConverterTypePublicKeyCredentialRpEntity.write(v2, into: &buf)
            
        
        case let .requestExistingCredential(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeCipherView.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeUIHint_lift(_ buf: RustBuffer) throws -> UiHint {
    return try FfiConverterTypeUIHint.lift(buf)
}

public func FfiConverterTypeUIHint_lower(_ value: UiHint) -> RustBuffer {
    return FfiConverterTypeUIHint.lower(value)
}



extension UiHint: Equatable, Hashable {}



fileprivate struct FfiConverterOptionSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeClientSettings: FfiConverterRustBuffer {
    typealias SwiftType = ClientSettings?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeClientSettings.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeClientSettings.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDateTime: FfiConverterRustBuffer {
    typealias SwiftType = DateTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDateTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDateTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]

    public static func write(_ value: [Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data] {
        let len: Int32 = try readInt(&buf)
        var seq = [Data]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterData.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFido2CredentialAutofillView: FfiConverterRustBuffer {
    typealias SwiftType = [Fido2CredentialAutofillView]

    public static func write(_ value: [Fido2CredentialAutofillView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFido2CredentialAutofillView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Fido2CredentialAutofillView] {
        let len: Int32 = try readInt(&buf)
        var seq = [Fido2CredentialAutofillView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFido2CredentialAutofillView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSend: FfiConverterRustBuffer {
    typealias SwiftType = [Send]

    public static func write(_ value: [Send], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSend.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Send] {
        let len: Int32 = try readInt(&buf)
        var seq = [Send]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSend.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSendListView: FfiConverterRustBuffer {
    typealias SwiftType = [SendListView]

    public static func write(_ value: [SendListView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSendListView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SendListView] {
        let len: Int32 = try readInt(&buf)
        var seq = [SendListView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSendListView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCipher: FfiConverterRustBuffer {
    typealias SwiftType = [Cipher]

    public static func write(_ value: [Cipher], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCipher.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Cipher] {
        let len: Int32 = try readInt(&buf)
        var seq = [Cipher]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCipher.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCipherListView: FfiConverterRustBuffer {
    typealias SwiftType = [CipherListView]

    public static func write(_ value: [CipherListView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCipherListView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CipherListView] {
        let len: Int32 = try readInt(&buf)
        var seq = [CipherListView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCipherListView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCipherView: FfiConverterRustBuffer {
    typealias SwiftType = [CipherView]

    public static func write(_ value: [CipherView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCipherView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CipherView] {
        let len: Int32 = try readInt(&buf)
        var seq = [CipherView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCipherView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCollection: FfiConverterRustBuffer {
    typealias SwiftType = [Collection]

    public static func write(_ value: [Collection], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCollection.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Collection] {
        let len: Int32 = try readInt(&buf)
        var seq = [Collection]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCollection.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCollectionView: FfiConverterRustBuffer {
    typealias SwiftType = [CollectionView]

    public static func write(_ value: [CollectionView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCollectionView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CollectionView] {
        let len: Int32 = try readInt(&buf)
        var seq = [CollectionView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCollectionView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFido2CredentialView: FfiConverterRustBuffer {
    typealias SwiftType = [Fido2CredentialView]

    public static func write(_ value: [Fido2CredentialView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFido2CredentialView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Fido2CredentialView] {
        let len: Int32 = try readInt(&buf)
        var seq = [Fido2CredentialView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFido2CredentialView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFolder: FfiConverterRustBuffer {
    typealias SwiftType = [Folder]

    public static func write(_ value: [Folder], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFolder.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Folder] {
        let len: Int32 = try readInt(&buf)
        var seq = [Folder]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFolder.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFolderView: FfiConverterRustBuffer {
    typealias SwiftType = [FolderView]

    public static func write(_ value: [FolderView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFolderView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FolderView] {
        let len: Int32 = try readInt(&buf)
        var seq = [FolderView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFolderView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePasswordHistory: FfiConverterRustBuffer {
    typealias SwiftType = [PasswordHistory]

    public static func write(_ value: [PasswordHistory], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePasswordHistory.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PasswordHistory] {
        let len: Int32 = try readInt(&buf)
        var seq = [PasswordHistory]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePasswordHistory.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePasswordHistoryView: FfiConverterRustBuffer {
    typealias SwiftType = [PasswordHistoryView]

    public static func write(_ value: [PasswordHistoryView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePasswordHistoryView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PasswordHistoryView] {
        let len: Int32 = try readInt(&buf)
        var seq = [PasswordHistoryView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePasswordHistoryView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringBool: FfiConverterRustBuffer {
    public static func write(_ value: [String: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}








































































































private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountBitwardenUniffi() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_bitwarden_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_client_auth() != 15410) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_client_crypto() != 21064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_client_echo() != 61009) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_client_exporters() != 13095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_client_generators() != 50372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_client_platform() != 32492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_client_sends() != 47933) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_client_vault() != 54396) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientattachments_decrypt_buffer() != 780) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientattachments_decrypt_file() != 10409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientattachments_encrypt_buffer() != 62018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientattachments_encrypt_file() != 37551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientauth_approve_auth_request() != 61442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientauth_hash_password() != 58719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientauth_make_key_connector_keys() != 11807) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientauth_make_register_keys() != 4847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientauth_make_register_tde_keys() != 58720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientauth_new_auth_request() != 57627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientauth_password_strength() != 16282) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientauth_satisfies_policy() != 49223) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientauth_trust_device() != 36124) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientauth_validate_password() != 38760) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientauth_validate_password_user_key() != 37923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientauth_validate_pin() != 12802) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientciphers_decrypt() != 40270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientciphers_decrypt_fido2_credentials() != 26766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientciphers_decrypt_list() != 32397) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientciphers_encrypt() != 52392) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientciphers_move_to_organization() != 55923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientcollections_decrypt() != 36056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientcollections_decrypt_list() != 34441) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientcrypto_derive_key_connector() != 31169) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientcrypto_derive_pin_key() != 33793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientcrypto_derive_pin_user_key() != 34017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientcrypto_enroll_admin_password_reset() != 27014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientcrypto_get_user_encryption_key() != 5136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientcrypto_initialize_org_crypto() != 7197) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientcrypto_initialize_user_crypto() != 33028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientcrypto_update_password() != 10481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientexporters_export_organization_vault() != 49791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientexporters_export_vault() != 27241) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientfido2_authenticator() != 50893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientfido2_client() != 33583) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientfido2_decrypt_fido2_autofill_credentials() != 12395) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientfido2authenticator_credentials_for_autofill() != 13813) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientfido2authenticator_get_assertion() != 30) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientfido2authenticator_make_credential() != 60687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientfido2authenticator_silently_discover_credentials() != 47262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientfido2client_authenticate() != 55420) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientfido2client_register() != 51611) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientfolders_decrypt() != 1331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientfolders_decrypt_list() != 47737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientfolders_encrypt() != 16835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientgenerators_passphrase() != 23031) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientgenerators_password() != 61260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientgenerators_username() != 58695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientpasswordhistory_decrypt_list() != 33793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientpasswordhistory_encrypt() != 22092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientplatform_fido2() != 37766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientplatform_fingerprint() != 43559) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientplatform_load_flags() != 15151) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientplatform_user_fingerprint() != 37450) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt() != 13894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt_buffer() != 20414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt_file() != 20370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientsends_decrypt_list() != 14490) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientsends_encrypt() != 15255) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientsends_encrypt_buffer() != 2726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientsends_encrypt_file() != 54341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientvault_attachments() != 8984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientvault_ciphers() != 29501) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientvault_collections() != 36479) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientvault_folders() != 44601) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientvault_generate_totp() != 46339) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientvault_generate_totp_cipher_view() != 12034) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_clientvault_password_history() != 59154) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_fido2credentialstore_find_credentials() != 37125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_fido2credentialstore_all_credentials() != 34338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_fido2credentialstore_save_credential() != 55817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_fido2userinterface_check_user() != 19175) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_fido2userinterface_pick_credential_for_authentication() != 7910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_fido2userinterface_check_user_and_pick_credential_for_creation() != 20994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_method_fido2userinterface_is_verification_enabled() != 40866) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bitwarden_uniffi_checksum_constructor_client_new() != 59311) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitFido2CredentialStore()
    uniffiCallbackInitFido2UserInterface()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all